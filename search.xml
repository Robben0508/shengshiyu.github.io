<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于指针和数组]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组和指针之间可以说是联系非常紧密，但我们要清楚的明白，数组和指针并不相同。虽然我们总能听到一种声音“数组和指针是相同的，数组名就是一个指向数组首元素的指针，对于a[2]这样的数组，其实就相当于*(a + 2)”，我们就自然而然地认为数组和指针看起来是一样的，可以互换，除非是在我们实际应用过程中发现了问题，我们才会在不断修正中明白，其实数组和指针并不同，只有在满足一些条件的情况下，数组和指针才可以进行互换。 指针和数组的不同指针是用来保存数据的地址的变量，而数组则是用来保存数据；我们可以通过指针进行间接访问，取得里面的地址值，再通过那个地址值提取数据，如果p是一个指针，它有一个下标，例如p[2],它就把指针里储存的地址值与2相加，再从这个新地址求值，而数组则是直接访问数据，a[2]只是简单的以a + 2的偏移量取得数据；指针通常指向匿名数据，而数组自身就是数据名，所以指针依赖于malloc(),free()这类函数来解决内存问题，而数组的话是隐式的分配和删除 什么情况下指针可以和数组互换首先表达式里的数组名被编译器当做一个指向该数组第一个元素的指针时，例如1int a[5],*b,i = 2; 那么我们访问a[i]时，可以通过以下方式12b = a;b[i]; 12b = a;*(b+i); 12b = a + i;*b; C语言把数组下标改写为指针偏移量的根本原因是因为指针和偏移量是底层硬件使用的基本模型。当下标总是与指针的偏移量相同时，也可以互换。例如：12for(i = 0; i&lt;=10; i ++) a[i] = 0; 相当于123b = a;for (i = 0; i&lt;=10; i++) b[i] = 0; 其中的b[i] = 0又可以写成*(b + i) = 0 如果声明是int *a[]呢，由于下标的优先级更高所以他表示一个数组，它里面的元素类型是指向整型的指针，所以它相当于一个指针数组。指针数组最频繁的用处在于储存长度不同的字符串，因为你不用固定分配大小去浪费储存空间，指针数组更具动态扩展性。 我们可以使用括号，使得int (*a)[]，那么它就表示一个指向整型数组的指针 还有一种情况数组名等于指针，那就是当一个数组作为函数参数时，因为编译器会把数组的形式改写为指向数组的第一个元素的指针的形式，他只像函数传递一个地址值，而不是整个数组的拷贝，这更多是出于效率考虑。例如int (*abc())[10],abc是一个函数，他返回一个指向包含10个int元素的数组的指针 在C语言中，严格来说，函数是不能直接返回函数和数组的，但可以让函数返回一个指向任何数据类型的指针，例如int *a(),它的返回值是一个指向整型的指针，而int (*a)()，左边的一对对括号迫使间接访问在函数调用之前进行，使a成为一个函数指针,它所指向的函数返回一个整型值。 我们再来看下int *(*a)(),它所指向的函数的返回值是一个指向整型的指针。如果声明是int (*a[])()，可能有点复杂，但实质上它表示一个数组，数组的类型是指向函数的指针，它所指向的函数的返回值是一个整数，如果声明是int *(*a[])()，我们就知道，它表示一个数组，数组的类型是指向函数的指针，而它所指向的函数的返回值是一个指向整型的指针。 关于指针和多维数组对于C语言而言，定义和引用一个多维数组的办法就是使用数组的数组，也就是数组的嵌套，例如a[3][5]，那么a是啥呢，我们可以把它看作是一个一维数组，它包含三个元素，每个元素包含五个整型值，所以a所指向的就是一个包含五个元素的数组而a+1就相当于指向a的另一行数组，如果是*(a+1)则表示他指向那一行的第一个元素而*（a+1)+1，其实就相当于比原来的表达式向后移动了一个元素，如果对整个表达式进一步处理一下，*(*（a+1)+1),那么它作为右值就相当于对那个位置的值间接引用，而作为左值，这个位置就代表那块空间，它可以被赋予新值。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和操作符]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%8C%87%E9%92%88%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[关于操作符你需要知道在谈论指针之前，我们很有必要说一下C语言里的操作符，C语言里有着种类繁多的操作符，大致分为算术操作符(+ - / %)、移位操作符(&lt;&lt; &gt;&gt;)、位操作符(&amp; | ^)、赋值符(=)、复合赋值符(+= -= = %= /= &lt;&lt;= &gt;&gt;= &amp;= |= ^=)、单目操作符(! ++ – - &amp; sizeof ~ + )关系操作符(&gt; &lt; == &gt;= &lt;= !=)逻辑操作符(&amp;&amp; ||)条件操作符(expression1 ? expression2 : expression3)、*逗号操作符(,) 操作符的复杂体现在它的优先级和结合性，两个相邻的操作符哪一个先执行取决于它的优先级，在他们优先级相同的情况下又要考虑它们的结合性，是左结合还是右结合，尤其是和指针联系在一起时很容易产生错误的执行结果，因为相对于其他语言，诸如Java、Python来说，指针是C语言的一个特色，也是一个难点。 对于操作符的优先级问题，可能一个最直接有效的办法就是添加括号，但是当表达式有太多的括号时反而不容易理解，所以适当的记住一些常见易混的操作符优先级，并适当的使用括号来辅助是一种很不错的方法。我们需要记住任何一个逻辑运算符的优先级要低于任何一个关系运算符，而移位操作符的优先级比算术操作符要低，但要比关系操作符高。 关于指针你需要知道指针实质是表示内存地址的变量，指针主要做两件事：避免副本和共享数据。由于C语言中的一切函数调用中，值传递都是“按值传递”的，它会创建一个拷贝的副本来进行操作，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成，也就是“按址传递”，而这个过程数据是共享的。所有赋值都会复制数据，如果你想复制数据的引用，就应该赋指针。 对指针进行间接访问之前，确认它们已经被初始化，否则仅仅声明了一个指针却没有对他进行初始化，例如：12int *a;*a = 12; 是没法得知它的正确地址的，因为声明一个指针变量并不会分配任何内存。 指针和操作符的问题我们现在作一个声明12int ab = 4;int *cp = &amp;ab; 当不同的表达式作为左值和右值时，它们表达的东西是不同的，对于左值来说，他表示的是一块明确的地址空间，而右值是一块地址空间里的值。 当我们的表达式是&amp;ab时，作为右值他表示变量ab的储存空间地址值，他也有一个地方来储存这个值，但我们没办法知道那块空间的具体位置，没有标识是一个明确的特定位置，所以作为左值，使用取址操作符的变量都是非法的。 当我们的表达式是cp时，作为左值他就表示的是cp本身的地址空间，作为右值就是表示变量ab的地址值。 当我们的表达式是&amp;cp时，我们知道他不能作为左值，对于右值来说，他是一个空间地址的值，也就是指针变量所在的那块空间的地址值，而指针变量中又保存着他指向那个对象的地址值，也就是指针的指针。对于指针的指针，类似于int **a,只有当确实需要时，才应该使用多层间接访问，不然程序会变得难以维护和理解。 当我们的表达式是*cp时，它相当于一个间接访问(解引用)，作为左值就表示ab所在那块空间，我们可以将新的值作为右值替换掉里面的原内容，作为右值就表示那块空间里原本存放的内容。 当我们的表达式是*cp + 1时，由于*操作符的优先级高于+，所以首先执行*cp,作为右值也就是ab里保存的内容4,所以作为右值的结果就是5，但作为左值，我们知道这个结果需要一个位置保存，但那个位置没有明确定义，所以作为左值是不合法的。 当我们的表达式是*(cp + 1)时,作为右值，我们知道cp他表示ab的地址值，由于有括号，所以优先级更高，地址值+1后对那块地址值空间进行间接引用，获得那块空间里保存的对象。 涉及到前置和后置递增递减运算符时，可能是最容易产生错误的了，无论是前置递增（递减）操作符还是后置递增（递减）操作符时，他都会产生一个原指针的拷贝，也就是里面所保存的指向某一内容的地址值，然后拷贝的这个地址值会放到一个新的空间里，如果是前置递增（递减）操作符会先进行原地址值的自增（自减）操作，所以他复制的拷贝会是自增（自减）后的新地址值，然后新的指针和原指针都将指向一个新的位置，并可以在拷贝上执行间接访问操作，访问那个未知的值；如果是后置，不会先进行自增操作求值，所以拷贝的值会是原指针的地址值，它和原指针指向相同的位置，而之前保存地址的那个位置将进行自增/自减操作，地址值更新并指向一个新的位置，由于我们是在拷贝的指针上执行间接访问操作，所以依然指向原地址值。C语言中所有对象，包括指针本身都是 “复制传值” 传递。例如： ++cp,在进行运算前他会先获取一个自增后的拷贝，我们知道作为右值时，cp代表的就是ab那个位置的地址值，由于自增，所以指向它的下一个地址值，但作为左值，因为自增后的拷贝结果是位于一个无法清晰定义的位置，所以不能作为左值。 cp++,由于是后置自增运算，所以不会先进行自增操作，所以拷贝的值的位置依然指向原地址，而原cp会在运算结束后求值，所以它会指向ab位置的下一块内存空间。 *++cp，通过++cp我们知道它指向的是ab的下一块内存空间，由于*的操作符优先级要比自增（自减）操作符低，所以它相当于(*(++cp))，而对那块空间执行间接引用，作为左值表示那块空间的，而作为右值则表示那块空间里存储的未知值。 *cp++,通过运算符优先级我们知道，它相当于(*(cp++)),由于cp++的结果是指向ab，所以作为左值*cp++就表示ab所在的那个地址空间，而作为右值，它就是ab保存的值——4。 ++*cp,根据运算符优先级，它相当于(++(*cp))，我们确实先进行自增操作，但由于*cp是一个整体，所以先对其本身求值，也就是4，然后我们复制一份拷贝，将运算结束后的新值5保存进去。所以对于字符串的操作，如果使用*++string,会漏掉首字符，所以用*string++可以方便对字符串进行遍历。 (*cp)++，如果不通过括号，我们要表达的就是*cp++，也就是*(cp++)，在这里我们就是先对cp进行间接引用取得ab保存的值，然后进行后置自增运算。 ++*++cp，根据操作符优先级，它的意思就是(++(*(++cp))),由于(*++cp)，我们知道作为右值是对ab的下一块空间的位置的间接引用，再对那个保存的未知值进行前置自增运算，但作为左值它是不合法的，因为自增后新值保存的那块空间位置不明确。 ++*cp++,根据前面的经验，我们可以知道它相当于((++(*(cp++)))),而*cp++作为右值相当于指向ab，进行间接访问的值为4,对其进行前置递增运算，并将拷贝计算的新值保存到一个新的位置，因为那个位置不明确，所以不能作为一个合法的左值。 通过上面的分析，我们发现，优先级上最后进行自增(自减)运算的不能作为一个左值使用，而取址操作符&amp;也一样，因为它们产生的新的值(不是地址值)会被保存到新的未知未知，所以不能作为左值使用。我们也发现”指针 +/- 整数”,只能作为右值，其根本上就是对了里面保存的地址值的运算 #define、typedef和指针C语言里，typedef是一个很不错的机制，他可以给数据类型定义新的名字，和使用#define重定义常量的用法很像，但要注意的是，#define没办法很好的处理指针类型，例如12#define char_pointer char*char_point a,b; 那么其中的b就不能被正确的声明为一个指向字符的指针类型，而用typedef就不一样了，例如：123char *char_pointer;//声明一个指向字符的指针类型typedef char *char_pointer;//把char_pointer作为指向字符的指针的新名字char_pointer a;//声明a是一个指向字符的指针 就可以很好的用来处理指针类型。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F01%2F05%2FMarkdown%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown的语法很简单，以下是它的一些最常用的操作，如果已经熟悉了，可以无视本文档 标题 通常来说如果你需要排列标题，可以在行首插入1到6个#，对应标题的1到6阶,最高可以到六级标题，最好在#后加一个空格例如:# 这是一级标题## 这是二级标题####### 这是六级标题 也可以使用=====表示高级标题，使用------表示次级标题，大于两个=,-都可以用来表示标题 引用如果你需要一个引用，那么你可以使用&gt;符号放于文字开头，例如:&gt;这是一个引用区块引用是可以嵌套的，同时引用的区块内也可以使用其他的Markdown语法，例如 这是一个引用 这是第另一个引用 ##这是标题 列表项 列表项 列表如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种方式，列表本身可以嵌套，例如 列表项 列表项 列表项 嵌套列表 嵌套列表 无序列表可以使用*、+、-这三个符号中的任何一种作为列表标记，也可以和引用结合嵌套 列表项 列表项 列表项 这是一个嵌套的引用 可以进一步嵌套 字体 粗体: 通常用**或者__表示粗体 斜体: 通常用*或者_表示斜体 斜粗体：通常用***或者___表示斜粗体 链接如果你需要链接文字，可以使用[](link)表示一个链接，其中[]内是需要添加链接的文字，()内是链接的地址 代码 使用一对```表示代码块，可以根据Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如： 123public static void main(String[] args) &#123; System.out.println("Hello"); &#125; 使用一对`可以表示一个行内代码，例如：这是一个Java代码 图片如果你需要导入一张图片，可以使用![Text](path)，其中Text表示图片无法显示时显示的文字，path为图片所在的路径，也可以是网上的图片地址 分割线如果你需要一条分割线，可以使用--- 或者***表示水平分割线，只要-,*大于三个就可以表示水平分割线，使用---作分割线时需要前后都空一行，防止被当成标题的标记方式 删除线如果你需要一条删除线,可以使用一对~~表示删除线，但切记和文字之间不能有空格 表格可以使用以下的格式添加表格,注意表格和文字间空一行：12345| name | age | gender | money ||-------|:---:|-----------|-------:|| rhio | 384 | robot | $3,000 || haroo | .3 | bird | $430 || jedi | ? | undefined | $0 | name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $0 其他如果用 Markdwon 的语法却达不到预期效果，或者一些地方的处理用 Markdwon 的语法无法实现，可以考虑用 HTML 和 CSS 引用 123&lt;blockquote&gt;***&lt;/blockquote&gt;/* 如果上下间距小，可以这样写 */&lt;p&gt;&lt;blockquote&gt;***&lt;/blockquote&gt;&lt;/p&gt; 居中和右对齐 123456/* 居中 */&lt;center&gt;**&lt;/center&gt;/* 右对齐 */&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;/* 右对齐 */&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt; 字体大小和颜色 1&lt;font color=&quot;#xxxxxx&quot; size=&quot;number&quot;&gt;**&lt;/font&gt; 分割线和空行 12&lt;hr /&gt;&lt;br /&gt; 关于Markdown的更多细节，可以参看Markdown 语法说明 (简体中文版)]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表解析的效率问题]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在列表，字典，集合中根据条件筛选数据 列表 filter 1filter(lambda x:x &gt; 20,data) 列表解析 字典 字典解析1&#123;for k,v in d.interitems() if v &gt;= 20&#125; 集合 集合解析1&#123;x for x in s if x % 2 == 0&#125; 注意：列表解析也可能会被滥用，例如使用列表解析重复获取一个函数等。所以并非一味地使用列表解析式就是好的。 原则：尽量保持其简洁，列表解析的代码不要超过两行以上，只用它来创建新的列表，否则的话还是考虑使用for循环来重写。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>

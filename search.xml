<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文化与媒介]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%96%87%E5%8C%96%E4%B8%8E%E5%AA%92%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Spring Bean的生命周期和作用域]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP浅析]]></title>
    <url>%2F2018%2F12%2F26%2FTCP%E5%92%8CUDP%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈大众传媒]]></title>
    <url>%2F2018%2F12%2F13%2F%E8%B0%88%E8%B0%88%E5%A4%A7%E4%BC%97%E4%BC%A0%E5%AA%92%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新思想和旧思想]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%96%B0%E6%80%9D%E6%83%B3%E5%92%8C%E6%97%A7%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PO、VO、BO、DTO、POJO、DAO之间的关系]]></title>
    <url>%2F2018%2F11%2F22%2FPO%E3%80%81VO%E3%80%81BO%E3%80%81DTO%E3%80%81POJO%E3%80%81DAO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈产品需求分析]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%B0%88%E8%B0%88%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java线程池]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google实用搜索技巧]]></title>
    <url>%2F2018%2F10%2F24%2FHTTP%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC与需求变化]]></title>
    <url>%2F2018%2F10%2F21%2FIOC%E4%B8%8E%E9%9C%80%E6%B1%82%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声望的陷阱]]></title>
    <url>%2F2018%2F10%2F11%2F%E5%A3%B0%E6%9C%9B%E7%9A%84%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector、ArrayList、LinkedList的区别]]></title>
    <url>%2F2018%2F10%2F02%2FVector%E3%80%81ArrayList%E3%80%81LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为何会选择技术之路]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%88%91%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat学习总结]]></title>
    <url>%2F2018%2F09%2F23%2FTomcat%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Java泛型]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%B5%85%E6%9E%90Java%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本技术类书籍]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%B1%BB%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类的理解]]></title>
    <url>%2F2018%2F09%2F12%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别浅析]]></title>
    <url>%2F2018%2F08%2F26%2FString%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何高效提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Javascript中的继承机制]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、finally、finalize的区别]]></title>
    <url>%2F2018%2F08%2F17%2Ffinal%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈Javascript的”面向对象编程“]]></title>
    <url>%2F2018%2F08%2F17%2FJavascript%E4%B8%AD%E7%9A%84this%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析Java的static关键字]]></title>
    <url>%2F2018%2F08%2F13%2F%E8%A7%A3%E6%9E%90Java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口和抽象类的区别]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Javascript的闭包]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中医与程序员]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%B8%AD%E5%8C%BB%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈Javascript的”面向对象编程“]]></title>
    <url>%2F2018%2F07%2F25%2F%E8%B0%88%E8%B0%88Javascript%E7%9A%84%E2%80%9D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E2%80%9C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式小记]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些值得参考的摄影名言]]></title>
    <url>%2F2018%2F07%2F01%2F%E9%82%A3%E4%BA%9B%E5%80%BC%E5%BE%97%E5%8F%82%E8%80%83%E7%9A%84%E6%91%84%E5%BD%B1%E5%90%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于指针和数组]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组和指针之间可以说是联系非常紧密，但我们要清楚的明白，数组和指针并不相同。虽然我们总能听到一种声音“数组和指针是相同的，数组名就是一个指向数组首元素的指针，对于a[2]这样的数组，其实就相当于*(a + 2)”，我们就自然而然地认为数组和指针看起来是一样的，可以互换，除非是在我们实际应用过程中发现了问题，我们才会在不断修正中明白，其实数组和指针并不同，只有在满足一些条件的情况下，数组和指针才可以进行互换。 指针和数组的不同指针是用来保存数据的地址的变量，而数组则是用来保存数据；我们可以通过指针进行间接访问，取得里面的地址值，再通过那个地址值提取数据，如果p是一个指针，它有一个下标，例如p[2],它就把指针里储存的地址值与2相加，再从这个新地址求值，而数组则是直接访问数据，a[2]只是简单的以a + 2的偏移量取得数据；指针通常指向匿名数据，而数组自身就是数据名，所以指针依赖于malloc(),free()这类函数来解决内存问题，而数组的话是隐式的分配和删除 什么情况下指针可以和数组互换首先表达式里的数组名被编译器当做一个指向该数组第一个元素的指针时，例如1int a[5],*b,i = 2; 那么我们访问a[i]时，可以通过以下方式12b = a;b[i]; 12b = a;*(b+i); 12b = a + i;*b; C语言把数组下标改写为指针偏移量的根本原因是因为指针和偏移量是底层硬件使用的基本模型。当下标总是与指针的偏移量相同时，也可以互换。例如：12for(i = 0; i&lt;=10; i ++) a[i] = 0; 相当于123b = a;for (i = 0; i&lt;=10; i++) b[i] = 0; 其中的b[i] = 0又可以写成*(b + i) = 0 如果声明是int *a[]呢，由于下标的优先级更高所以他表示一个数组，它里面的元素类型是指向整型的指针，所以它相当于一个指针数组。指针数组最频繁的用处在于储存长度不同的字符串，因为你不用固定分配大小去浪费储存空间，指针数组更具动态扩展性。 我们可以使用括号，使得int (*a)[]，那么它就表示一个指向整型数组的指针 还有一种情况数组名等于指针，那就是当一个数组作为函数参数时，因为编译器会把数组的形式改写为指向数组的第一个元素的指针的形式，他只像函数传递一个地址值，而不是整个数组的拷贝，这更多是出于效率考虑。例如int (*abc())[10],abc是一个函数，他返回一个指向包含10个int元素的数组的指针 在C语言中，严格来说，函数是不能直接返回函数和数组的，但可以让函数返回一个指向任何数据类型的指针，例如int *a(),它的返回值是一个指向整型的指针，而int (*a)()，左边的一对对括号迫使间接访问在函数调用之前进行，使a成为一个函数指针,它所指向的函数返回一个整型值。 我们再来看下int *(*a)(),它所指向的函数的返回值是一个指向整型的指针。如果声明是int (*a[])()，可能有点复杂，但实质上它表示一个数组，数组的类型是指向函数的指针，它所指向的函数的返回值是一个整数，如果声明是int *(*a[])()，我们就知道，它表示一个数组，数组的类型是指向函数的指针，而它所指向的函数的返回值是一个指向整型的指针。 关于指针和多维数组对于C语言而言，定义和引用一个多维数组的办法就是使用数组的数组，也就是数组的嵌套，例如a[3][5]，那么a是啥呢，我们可以把它看作是一个一维数组，它包含三个元素，每个元素包含五个整型值，所以a所指向的就是一个包含五个元素的数组而a+1就相当于指向a的另一行数组，如果是*(a+1)则表示他指向那一行的第一个元素而*（a+1)+1，其实就相当于比原来的表达式向后移动了一个元素，如果对整个表达式进一步处理一下，*(*（a+1)+1),那么它作为右值就相当于对那个位置的值间接引用，而作为左值，这个位置就代表那块空间，它可以被赋予新值。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和操作符]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%8C%87%E9%92%88%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[关于操作符你需要知道在谈论指针之前，我们很有必要说一下C语言里的操作符，C语言里有着种类繁多的操作符，大致分为算术操作符(+ - / %)、移位操作符(&lt;&lt; &gt;&gt;)、位操作符(&amp; | ^)、赋值符(=)、复合赋值符(+= -= = %= /= &lt;&lt;= &gt;&gt;= &amp;= |= ^=)、单目操作符(! ++ – - &amp; sizeof ~ + )关系操作符(&gt; &lt; == &gt;= &lt;= !=)逻辑操作符(&amp;&amp; ||)条件操作符(expression1 ? expression2 : expression3)、*逗号操作符(,) 操作符的复杂体现在它的优先级和结合性，两个相邻的操作符哪一个先执行取决于它的优先级，在他们优先级相同的情况下又要考虑它们的结合性，是左结合还是右结合，尤其是和指针联系在一起时很容易产生错误的执行结果，因为相对于其他语言，诸如Java、Python来说，指针是C语言的一个特色，也是一个难点。 对于操作符的优先级问题，可能一个最直接有效的办法就是添加括号，但是当表达式有太多的括号时反而不容易理解，所以适当的记住一些常见易混的操作符优先级，并适当的使用括号来辅助是一种很不错的方法。我们需要记住任何一个逻辑运算符的优先级要低于任何一个关系运算符，而移位操作符的优先级比算术操作符要低，但要比关系操作符高。 关于指针你需要知道指针实质是表示内存地址的变量，指针主要做两件事：避免副本和共享数据。由于C语言中的一切函数调用中，值传递都是“按值传递”的，它会创建一个拷贝的副本来进行操作，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成，也就是“按址传递”，而这个过程数据是共享的。所有赋值都会复制数据，如果你想复制数据的引用，就应该赋指针。 对指针进行间接访问之前，确认它们已经被初始化，否则仅仅声明了一个指针却没有对他进行初始化，例如：12int *a;*a = 12; 是没法得知它的正确地址的，因为声明一个指针变量并不会分配任何内存。 指针和操作符的问题我们现在作一个声明12int ab = 4;int *cp = &amp;ab; 当不同的表达式作为左值和右值时，它们表达的东西是不同的，对于左值来说，他表示的是一块明确的地址空间，而右值是一块地址空间里的值。 当我们的表达式是&amp;ab时，作为右值他表示变量ab的储存空间地址值，他也有一个地方来储存这个值，但我们没办法知道那块空间的具体位置，没有标识是一个明确的特定位置，所以作为左值，使用取址操作符的变量都是非法的。 当我们的表达式是cp时，作为左值他就表示的是cp本身的地址空间，作为右值就是表示变量ab的地址值。 当我们的表达式是&amp;cp时，我们知道他不能作为左值，对于右值来说，他是一个空间地址的值，也就是指针变量所在的那块空间的地址值，而指针变量中又保存着他指向那个对象的地址值，也就是指针的指针。对于指针的指针，类似于int **a,只有当确实需要时，才应该使用多层间接访问，不然程序会变得难以维护和理解。 当我们的表达式是*cp时，它相当于一个间接访问(解引用)，作为左值就表示ab所在那块空间，我们可以将新的值作为右值替换掉里面的原内容，作为右值就表示那块空间里原本存放的内容。 当我们的表达式是*cp + 1时，由于*操作符的优先级高于+，所以首先执行*cp,作为右值也就是ab里保存的内容4,所以作为右值的结果就是5，但作为左值，我们知道这个结果需要一个位置保存，但那个位置没有明确定义，所以作为左值是不合法的。 当我们的表达式是*(cp + 1)时,作为右值，我们知道cp他表示ab的地址值，由于有括号，所以优先级更高，地址值+1后对那块地址值空间进行间接引用，获得那块空间里保存的对象。 涉及到前置和后置递增递减运算符时，可能是最容易产生错误的了，无论是前置递增（递减）操作符还是后置递增（递减）操作符时，他都会产生一个原指针的拷贝，也就是里面所保存的指向某一内容的地址值，然后拷贝的这个地址值会放到一个新的空间里，如果是前置递增（递减）操作符会先进行原地址值的自增（自减）操作，所以他复制的拷贝会是自增（自减）后的新地址值，然后新的指针和原指针都将指向一个新的位置，并可以在拷贝上执行间接访问操作，访问那个未知的值；如果是后置，不会先进行自增操作求值，所以拷贝的值会是原指针的地址值，它和原指针指向相同的位置，而之前保存地址的那个位置将进行自增/自减操作，地址值更新并指向一个新的位置，由于我们是在拷贝的指针上执行间接访问操作，所以依然指向原地址值。C语言中所有对象，包括指针本身都是 “复制传值” 传递。例如： ++cp,在进行运算前他会先获取一个自增后的拷贝，我们知道作为右值时，cp代表的就是ab那个位置的地址值，由于自增，所以指向它的下一个地址值，但作为左值，因为自增后的拷贝结果是位于一个无法清晰定义的位置，所以不能作为左值。 cp++,由于是后置自增运算，所以不会先进行自增操作，所以拷贝的值的位置依然指向原地址，而原cp会在运算结束后求值，所以它会指向ab位置的下一块内存空间。 *++cp，通过++cp我们知道它指向的是ab的下一块内存空间，由于*的操作符优先级要比自增（自减）操作符低，所以它相当于(*(++cp))，而对那块空间执行间接引用，作为左值表示那块空间的，而作为右值则表示那块空间里存储的未知值。 *cp++,通过运算符优先级我们知道，它相当于(*(cp++)),由于cp++的结果是指向ab，所以作为左值*cp++就表示ab所在的那个地址空间，而作为右值，它就是ab保存的值——4。 ++*cp,根据运算符优先级，它相当于(++(*cp))，我们确实先进行自增操作，但由于*cp是一个整体，所以先对其本身求值，也就是4，然后我们复制一份拷贝，将运算结束后的新值5保存进去。所以对于字符串的操作，如果使用*++string,会漏掉首字符，所以用*string++可以方便对字符串进行遍历。 (*cp)++，如果不通过括号，我们要表达的就是*cp++，也就是*(cp++)，在这里我们就是先对cp进行间接引用取得ab保存的值，然后进行后置自增运算。 ++*++cp，根据操作符优先级，它的意思就是(++(*(++cp))),由于(*++cp)，我们知道作为右值是对ab的下一块空间的位置的间接引用，再对那个保存的未知值进行前置自增运算，但作为左值它是不合法的，因为自增后新值保存的那块空间位置不明确。 ++*cp++,根据前面的经验，我们可以知道它相当于((++(*(cp++)))),而*cp++作为右值相当于指向ab，进行间接访问的值为4,对其进行前置递增运算，并将拷贝计算的新值保存到一个新的位置，因为那个位置不明确，所以不能作为一个合法的左值。 通过上面的分析，我们发现，优先级上最后进行自增(自减)运算的不能作为一个左值使用，而取址操作符&amp;也一样，因为它们产生的新的值(不是地址值)会被保存到新的未知未知，所以不能作为左值使用。我们也发现”指针 +/- 整数”,只能作为右值，其根本上就是对了里面保存的地址值的运算 #define、typedef和指针C语言里，typedef是一个很不错的机制，他可以给数据类型定义新的名字，和使用#define重定义常量的用法很像，但要注意的是，#define没办法很好的处理指针类型，例如12#define char_pointer char*char_point a,b; 那么其中的b就不能被正确的声明为一个指向字符的指针类型，而用typedef就不一样了，例如：123char *char_pointer;//声明一个指向字符的指针类型typedef char *char_pointer;//把char_pointer作为指向字符的指针的新名字char_pointer a;//声明a是一个指向字符的指针 就可以很好的用来处理指针类型。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看得见的与看不见的]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E4%B8%8E%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论摄影与摄像]]></title>
    <url>%2F2018%2F05%2F29%2F%E8%AE%BA%E6%91%84%E5%BD%B1%E4%B8%8E%E6%91%84%E5%83%8F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2F2018%2F05%2F19%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ls命令用来显示目标列表或者目录内容的，常用的可选参数有： -a 显示所有子目录和文件，包括隐藏文件 -l 显示文件的详细信息，可以把ls -l简写为ll cp/mv命令用来把一个文件或者多个文件复制/移动到目标目录 rm命令刪除一个目录中的一个或多个文件或目录，其中需要注意的参数有： -f 不需要确认删除多个文件，强制删除 -r 将文件的全部目录和子目录都删除 cat命令可以显示文件内容，也可以连接两个或者多个文件 which命令显示文件的所在路径 man命令用于查看Linux中的命令帮助信息，遇到不会的命名就man一下，它也有一些参数需要注意： -a 在所有的man帮助手册中搜索； -f 等价于whatis指令，显示给定关键字的简短描述信息； ps命令ps命令列出执行这个命令时刻时的那些进程，类似一个当前进程的快照，是最基本也是最强大的进程查看命令，需要注意的参数有： a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 -au 显示较为详细的信息 tar命令很常用的压缩&amp;&amp;解压命令了，但tar这个命令….参数是真的多，看到一种不错的记忆方法，只要记得参数是【必选+自选+f】即可，首先是必选参数，五选一： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 然后是自选参数，必选的话只能选一个，而可以根据需要挑着选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 最后一个参数一定要是f，后面再跟上你要压缩或者解压的文件包名。 一般我们常用的解压方式就是： *.tar -&gt; tar -xf *.tar.gz -&gt; tar -xzf *.tar.bz2 -&gt; tar -xjf *.tar.Z -&gt; tar -xZf *.gz -&gt; gzip -d *.rar -&gt; `unrar e *.zip -&gt; unzip kill命令用于终止指定进程的运行，对于后台进程我们可以先通过ps/pidof/pstree/top等命令获取进程PID，然后用kill结束该进程。不过也可以使用killall命令，直接使用进程的名称结束进程，使用它可以结束一组同名进程，而不用先获取进程PID，killall相当于把这两个过程合二为一，是一个很好用的命令 head命令可以用来查看一个文件的前几行，可以配合其他命令使用，例如配合管道做grep tail命令tail命令和head相反，查看文件的最后几行。不过最常用的还是加上 “-f” 参数后和grep一起使用 grep命令一个极其强大的命令，常用来在很多数据中找到匹配某一模式的字段，可以是正则表达式，常用的几个参数有： -a 以文本文件方式搜索 -c 计算找到的符合行的次数 -i 忽略大小写 -n 顺便输出行号 -v 反向选择，查找没有搜索字符串的行 du命令du命令是对文件和目录磁盘使用空间的查看 top命令用于动态的显示进程的信息，不过也有可以自定义的形式，例如:top -u root可以用来查看某用户进程 find命令查找所需文件的命令，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，常用的参数有： -type 只寻找符合指定的文件类型的文件,其后跟随指定文件类型参数，类型参数有 f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p FIFO -name 根据文件名查找 -size 根据文件的权限或者大小名字类型进行查找 -mtime 查找在指定时间曾被更改过的文件或目录，单位以24小时计算； -print 假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出 -exec 假设find指令的回传值为True，就执行其后跟着的指令 cmp命令用来比较两个文件的差异。如果两个文件完全一样，就不会显示任何信息。如果发现有差异，会标示出第一个不同之处的字符和列数编号。 touch命令修改文件的创建日期，或者以当前的系统日期创建一个空文件 date命令显示当前日期和时间的，可以通过一些参数进行日期的格式化： %Y year %m month (01~12) %d day of month %H hour (00~23) %I hour (01~12) %M minute (00~59) %S second (00~60)例如：1234date + &quot;%Y%m%d %H%M%S&quot;20180519 223856date + &quot;%Y-%m-%d %H:%M:%S&quot;2018-05-19 22:39:07 wc命令统计指定文件中的字节数、字数、行数，并将统计结果输出，需要了解的参数有： -c 统计字节数 -l 统计行数 -m 统计字符数，不能与-c参数一起使用 -w 统计字数 env/export命令env: 查看当前环境变量 类似于配置Python环境，在一台不熟悉的机器上，如果出现了配置问题，可以通过env命令查看shell下的所有环境配置，看一下路径是否正确。 export: 设置或显示环境变量 useradd命令useradd命令用于创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。其中有几个需要注意的参数： -e 指定帐号的有效期限 -g 指定用户所属的群组 -G 指定用户所属的附加群组 -r 建立系统帐号 -u 指定用户id，设定ID值时尽量要大于500，以免冲突 groupadd命令用于创建一个新的工作组，也可以用groupdel命令删除工作组，常用的参数有： -g 指定新建工作组的id -r 创建系统工作组，系统工作组的组ID小于500 curl/wget命令curl命令是一个利用URL规则在命令行下工作的文件传输工具,而wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。 netstat命令用来显示网络系统的状态信息，可让你了解整个系统的网络情况，需要注意的参数有： -a 显示所有连线中的Socket -n 直接使用ip地址，而不通过域名服务器 -t 显示TCP传输协议的连线状况 -u 显示UDP传输协议的连线状况 -l 显示监控中的服务器的Socket -s 显示网络工作信息统计表 -n 直接使用ip地址，而不通过域名服务器 可以通过参数的组合实现不同的功能，例如1234567netstat -at #列出所有tcp端口netstat -au #列出所有udp端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -st #显示TCP端口的统计信息netstat -su #显示UDP端口的统计信息netstat -an | grep &apos;:80&apos; #找出运行在指定端口的进程]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匠人的情怀]]></title>
    <url>%2F2018%2F05%2F11%2F%E5%8C%A0%E4%BA%BA%E7%9A%84%E6%83%85%E6%80%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google实用搜索技巧]]></title>
    <url>%2F2018%2F04%2F20%2FGoogle%E5%AE%9E%E7%94%A8%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[善用搜索引擎的都是信息时代的富翁，不懂搜索引擎的都是信息时代的负翁。 完整匹配在Google的搜索框里，所有的空格都被视为”+”号，可能对于用惯了百度的人很好理解，因为我们要搜啥时，肯定是搜索关键词，加了空格就相当于多个并列的关键词，那搜索结果就会把所有包含相关关键词的内容都全部罗列出来。 也可以搜索一个具体的问题，而这样的一句话，在中文里基本没空格的，但我们使用Google时更多是用英文，英文关键词是没问题的，当你使用英文描述一个具体问题时，就需要在搜索字段的前后加上引号，无论是全角字符(“或者”)还是半角字符(“)，Google都能正确处理，这就是完整匹配。 筛选过滤为了进一步筛选搜索结果，我们可以使用”-“操作符，如&quot;mysql connect error&quot; - &quot;nodejs&quot;就要求Google返回含有mysql connect error但不包括nodejs的文章。当然，中文搜索也是适用的。 也可以使用”+”操作符，因为Google会忽略和过滤一些常用的英文词汇，例如and，how之类的，使用”+”操作符可以让搜索引擎强制包括它们，也可以强制过滤掉关键词的一些特定时态形式。 通配符其实就是我们熟知的符号”“，举个例子，当我们搜索`”mysql connect error “`就会返回所有已知的关于MySQL连接错误的文章。 其他操作符我们熟知的常用的一些操作符，可以辅助完成一些特定搜索，也可以在Google里使用，例如： ~ 关键词前加上它，可以显示同义词 | 作用和OR一样 .. 用来限定数值的范围，例如2015..2018 站内搜索可以根据特定的网站搜索对应网站内所有相关内容，例如：&quot;mysql connect error&quot; site:stackoverflow.com就会返回Stackoverflow内所有关于MySQL连接错误的文章。 搜索指定文件格式我们可以搜索特定的文件格式，不过一些文件类型是不支持的，但日常那来搜索一些PDF资源或者搜索特定图片格式也是很方便的，只需要加上filetype: + 特定格式,就可以了,不过对于图片搜索还可以限定搜索的图片尺寸，加上imagesize:，例如：imagesize:500x500 搜索相似网页可以通过related:这个关键字搜索到相关相仿的网页或相关页面，例如：related:www.taobao.com 关闭安全搜索最直接简便的方式就是在搜索网址时附加一个参数：&amp;safe=off]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪辑的艺术]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%89%AA%E8%BE%91%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于碎片化阅读的思考]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%85%B3%E4%BA%8E%E7%A2%8E%E7%89%87%E5%8C%96%E9%98%85%E8%AF%BB%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小记]]></title>
    <url>%2F2018%2F03%2F16%2FGit%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常用命令设置和配置 git config12345678git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on git 创建和获取项目 git init初始化本地git仓库（创建新仓库） git cloneclone远程仓库 快照 git add 12git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至index git commit 123git commit -m &apos;xxx&apos; # 提交git commit --amend -m &apos;xxx&apos; # 合并上一次提交（用于反复修改）git commit -am &apos;xxx&apos; # 将add和commit合为一步 git diff 123456git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git rm 12git rm xxx # 删除index中的文件git rm -r * # 递归删除 git mv 1git mv README README2 # 重命名文件README为README2 git status用来查看当前版本状态，查看是否进行了修改 分支与合并 git log 123456git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log --stat # 显示提交日志及相关变动文件git log -p -mgit log v1.0 # 显示v1.0的日志git log --pretty=format:&apos;%h %s&apos; --graph # 图示提交日志 git tag 12git tag # 显示已存在的taggit tag -a v1.0 -m &apos;xxx&apos; # 增加v1.0的tag git branch可以列出你所拥有的分支、创建的新分支、删除分支以及重命名分支 123456789git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git checkout用于切换分支并将内容检出到工作目录 1234567git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v1.0 # 检出版本v1.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退） git merge用于将一个或多个分支合并，然后将合并的分支作为当前分支 1git merge origin/master # 合并远程master分支至当前分支 git stash 123git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存 项目共享和更新 git remote可以用来管理远程仓库记录，将一段很冗杂的URL地址保存成一个简单的字符串句柄，比如origin，方便操作 1git remote add &lt;name&gt; &lt;url&gt; # 增加远程定义（用于push/pull/fetch） git push与其他仓库通信，确定本地内容和远程仓库异同，然后将差异推送到其他仓库 123git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库 git fetch 12git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支 git pull可以理解为git fetch和git merge的组合，先从远程仓库获取内容，再尝试合并进你所在分支 1git pull origin master # 获取远程分支master并merge到当前分支 git reset 1git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） 检视和比较 git show能够以简单易读的形式显示Git对象，通常用来显示标签或提交的相关信息 12345678git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git show v1.0 # 显示v1.0的日志及详细内容git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git show HEAD~3git show -s --pretty=raw 2be7fcb476 git ls-files 1git ls-files # 列出git index包含的文件 git show-branch 12git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史 调试 git grep可以帮助你在源代码的所有文件中找到任意字符串12git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e &apos;#define&apos; --and -e SORT_DIRENT 打补丁 git cherry-pick 1git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git rebase基本上就是一个自动化的git cherry-pick命令，它确定一系列提交，然后在别处以相同的顺序逐个对其挑拣。 git revert与git cherry-pick命令的效果恰好相反，将变更撤销或还原 1git revert dfb02e6e4f2f7b # 撤销提交dfb02e6e4f2f7b 管理 git reflog显示所有提交，包括孤立节点 git gc执行”垃圾回收“，删除无用文件，将余下的文件打包成一种更有效的形式 git fsck用于检查内部数据库存在的问题或不一致性]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非“你”不可]]></title>
    <url>%2F2018%2F02%2F16%2F%E9%9D%9E%E2%80%9C%E4%BD%A0%E2%80%9D%E4%B8%8D%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实用技巧]]></title>
    <url>%2F2018%2F02%2F14%2FPython%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的字符串拼接技巧汇总]]></title>
    <url>%2F2018%2F01%2F24%2FPython%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“视界”]]></title>
    <url>%2F2018%2F01%2F12%2F%E2%80%9C%E8%A7%86%E7%95%8C%E2%80%9D%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python中\_\_str\_\_和\_\_repr\_\_的区别]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%85%B3%E4%BA%8EPython%E4%B8%AD-str-%E5%92%8C-repr-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[比较__repr__和__str____repr__和__str__这两个方法都是用于显示的，在学习Python的过程中，往往会产生疑惑，似乎他们表面上看都是差不多的，但实际却存在许多差异，我们可以通过一个例子来比较一下它们之间不同。 123456789101112class Hello(object): pass&gt;&gt;&gt; a = Hello()&gt;&gt;&gt; a&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(a)&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(str(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(repr(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt; 这里我们想要打印类对象，但显示的确是对象的内存地址，而且无论通过__repr__或是__str__,结果都一样，下面我们重写一下这个类的__repr__方法： 12345678910111213class Hello(object): def __repr__(object): return &apos;hello&apos;&gt;&gt;&gt; b = Hello()&gt;&gt;&gt; bhello&gt;&gt;&gt; print(b)hello&gt;&gt;&gt; print(str(b))hello&gt;&gt;&gt; print(repr(b))hello 然后我们就发现不管输出对象，调用__repr__和__str__方法，还是通过print()方法，打印的信息都是按我们__repr__方法中定义的格式进行显示的。现在我们重写一下__str__： 12345678910111213class Hello(object): def __str__(object): return &apos;hello&apos;&gt;&gt;&gt; c = Hello()&gt;&gt;&gt; c&lt;__main__.Hello object at 0x000001DE00450CC0&gt;&gt;&gt;&gt; print(c)hello&gt;&gt;&gt; print(str(c))hello&gt;&gt;&gt; print(repr(c))&lt;__main__.Hello object at 0x000001DE00450CC0&gt; 现在就很明显了，直接输出对象c时，显示出来的依旧是它的内存地址，而当我们调用print方法时，就会按我们定义的格式输出信息。由于我们覆盖了先前的__repr__方法，可是即使没有提前覆盖__repr__方法，我们得出的结果也是一样的。 总结一下，__repr__和__str__这两个方法都是用于显示的，但__str__更适用于用户，而__repr__更适用于开发人员。 打印操作会首先尝试__str__和str内置函数（print运行的内部等价形式），它通常应该返回一个友好的显示 __repr__用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str，它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F01%2F05%2FMarkdown%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Markdown的语法很简单，以下是它的一些最常用的操作，如果已经熟悉了，可以无视本文档 标题 通常来说如果你需要排列标题，可以在行首插入1到6个#，对应标题的1到6阶,最高可以到六级标题，最好在#后加一个空格例如:# 这是一级标题## 这是二级标题####### 这是六级标题 也可以使用=====表示高级标题，使用------表示次级标题，大于两个=,-都可以用来表示标题 引用如果你需要一个引用，那么你可以使用&gt;符号放于文字开头，例如:&gt;这是一个引用区块引用是可以嵌套的，同时引用的区块内也可以使用其他的Markdown语法，例如 这是一个引用 这是第另一个引用 ##这是标题 列表项 列表项 列表如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种方式，列表本身可以嵌套，例如 列表项 列表项 列表项 嵌套列表 嵌套列表 无序列表可以使用*、+、-这三个符号中的任何一种作为列表标记，也可以和引用结合嵌套 列表项 列表项 列表项 这是一个嵌套的引用 可以进一步嵌套 字体 粗体: 通常用**或者__表示粗体 斜体: 通常用*或者_表示斜体 斜粗体：通常用***或者___表示斜粗体 链接如果你需要链接文字，可以使用[](link)表示一个链接，其中[]内是需要添加链接的文字，()内是链接的地址 代码 使用一对```表示代码块，可以根据Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如： 123public static void main(String[] args) &#123; System.out.println("Hello"); &#125; 使用一对`可以表示一个行内代码，例如：这是一个Java代码 图片如果你需要导入一张图片，可以使用![Text](path)，其中Text表示图片无法显示时显示的文字，path为图片所在的路径，也可以是网上的图片地址 分割线如果你需要一条分割线，可以使用--- 或者***表示水平分割线，只要-,*大于三个就可以表示水平分割线，使用---作分割线时需要前后都空一行，防止被当成标题的标记方式 删除线如果你需要一条删除线,可以使用一对~~表示删除线，但切记和文字之间不能有空格 表格可以使用以下的格式添加表格,注意表格和文字间空一行：12345| name | age | gender | money ||-------|:---:|-----------|-------:|| rhio | 384 | robot | $3,000 || haroo | .3 | bird | $430 || jedi | ? | undefined | $0 | name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $0 其他如果用 Markdwon 的语法却达不到预期效果，或者一些地方的处理用 Markdwon 的语法无法实现，可以考虑用 HTML 和 CSS 引用 123&lt;blockquote&gt;***&lt;/blockquote&gt;/* 如果上下间距小，可以这样写 */&lt;p&gt;&lt;blockquote&gt;***&lt;/blockquote&gt;&lt;/p&gt; 居中和右对齐 123456/* 居中 */&lt;center&gt;**&lt;/center&gt;/* 右对齐 */&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;/* 右对齐 */&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt; 字体大小和颜色 1&lt;font color=&quot;#xxxxxx&quot; size=&quot;number&quot;&gt;**&lt;/font&gt; 分割线和空行 12&lt;hr /&gt;&lt;br /&gt; 关于Markdown的更多细节，可以参看Markdown 语法说明 (简体中文版)]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使自己看起来更Pythonic]]></title>
    <url>%2F2017%2F12%2F21%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E8%87%AA%E5%B7%B1%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4Pythonic%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表解析的效率问题]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在列表，字典，集合中根据条件筛选数据 列表 filter 1filter(lambda x:x &gt; 20,data) 列表解析 字典 字典解析1&#123;for k,v in d.interitems() if v &gt;= 20&#125; 集合 集合解析1&#123;x for x in s if x % 2 == 0&#125; 注意：列表解析也可能会被滥用，例如使用列表解析重复获取一个函数等。所以并非一味地使用列表解析式就是好的。 原则：尽量保持其简洁，列表解析的代码不要超过两行以上，只用它来创建新的列表，否则的话还是考虑使用for循环来重写。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>

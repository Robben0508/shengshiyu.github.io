<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文化与媒介]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%96%87%E5%8C%96%E4%B8%8E%E5%AA%92%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Spring Bean的生命周期和作用域]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP浅析]]></title>
    <url>%2F2018%2F12%2F26%2FTCP%E5%92%8CUDP%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[关于UDP你需要知道UDP继承了IP包的特性，不保证不丢失，不保证顺序到达，它只管发出去，打个比方，它就像懵懂无知的小孩，它认为只要是发出去的东西，很容易就能送达，不会丢包。而且它不会建立连接，它也不会进行拥塞控制，只管往外发就行，一根筋。 虽然UDP报文没有可靠性保证、顺序保证和拥塞控制，可靠性较差。但也正因为如此，UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，需要处理速度快，时延低，可以容忍少数丢包，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。 在网络质量很差的环境下，UDP协议数据包丢失会比较严重。但是由于它传输过程中资源消耗小，处理速度快，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包到达的消息及时反馈回来，那么网络就是通的。在默认状态下，一次“ping”操作发送4个数据包，对方主机发回的确认收到的数据包也是4包，这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。 UDP协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据包在传输过程中被篡改或者损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测出是否出错。 关于TCP你需要知道TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来，也因为多了这样一个过程，TCP要比UDP复杂很多，可以看一下TCP头的格式。 TCP的包是没有IP地址的，那是IP层上的事。可以对比看出，相对于UDP来说，TCP多了一个序号，这个序号的作用是为了给发送的包标号，防止乱序，这样我们好知道哪一个应该先来，哪一个后来，做到有理有序。 其次，它还具有一个滑动窗口，我们可以理解为这就是一个管道的大小，越大自然水的流速流量可以更大，越小自然流速就会变小，流量变少，TCP也一样，窗口的大小就是为了能够控制流量的，通过标识窗口大小，就可以知道对方的处理能力，而不会发送过快了，造成拥塞问题，用于解决流控的。 TCP 三次握手TCP连接的建立，我们通常称为“三次握手”，打个比方，大概就是这样：A：你好，我是A，想和你连接B：你好A，我是B，我收到你提出的连接请求了A：好的B，收到了 为啥一定要是三次呢？不是两次或者四次，当A发起一个连接是，如果B没有回复，它又如何知道B收到了呢，它会以为包丢了，或者超时未达，又或者B压根不想和它连接，它会很懵逼，以至于可能再发。 当B收到了请求包，就知道了A的存在，也知道A想和它连接，而且它要是不回复，A会继续重试“骚扰”它一阵子，直到A自己放弃，建立连接失败。如果B愿意连接，OK，立马发个应答包过去，告诉A，我同意和你连接了。 但是，这个过程一样会遇到种种未知错误，比如这个应答包丢了。。。那A不知道啊，继续“骚扰”。。。所以B为了不受其烦，肯定要为了确保应答到达，不断尝试重发，只要一次到达，它就解脱了。至于怎么确认到达，当然是等A收到了应答包，然后欢呼雀跃的再发送一个应答包，表示”收到了，我们连接吧！“不过你可能会觉得，那我们也要确定A这个应答包到达B啊，不然B咋知道A收到他第二次握手发的包，难道不应该四次握手吗？其实四次握手也是可以的，几十上百次都OK，但那也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了。 A当然可以建立连接后空闲着，就是不“搭理”B，对于B来说，对于A这种“占着茅坑不拉屎”的行为，自然可以选择主动关闭，从而把空出的资源给其他客户端使用。 TCP里的序号在“三次握手”中，可以很有效的解决丢包问题，当它俩连接后，A发送了很多个有序排列的包，但中途可能由于种种未知原因，丢了一个，A不知道，但B知道A发的包的总数，它一数，好像差了一个，然后再告诉A。而且这个序号的起始序号是随时间变化的，不会重复，为了防止某些包绕路，等到了其实已经无用了，所以IP包头里有个TTL，也就是生存时间。 这里有个时序图，可以看一下，而且TCP头里还有一些状态位，其中SYN表示发起一个连接，ACK表示回复，RST表示重新连接，FIN表示结束连接，这样这个时序图就好理解了。 TCP 四次挥手嗯，说散就散，说完了连接，该说下“四次挥手”了，它大概是这样的：A：我们分手吧B: 哦，你想分了啊，那好吧，知道了。。。 这个时候，只是A想分手离开了，也就是A不再发送数据，那B能不能在ACK的时候直接选择关闭呢，反正A都要分了，自然是不行的，因为A可能是发完了最后的数据就准备分手了，但是B还没做完它的事情，还是可以发送数据的，处在一种半关闭状态，这个时候A可以选择不再接受数据，也可以选择最后再接受一段数据，等待B也主动关闭。于是就有了：B： OK，那我不陪你了，再见A： 嗯，再见 然后整个连接就关闭了，但是上面是一种理想情况下的分手，可能会遇到很多异常情况，例如，A说完分手后，直接走了，B不知道，B发的回复A就收不到了，B会陷入不知所措。也有可能是B说完分手后，他倒是处于半关闭的还在着，B直接生气走了，A也会陷入两难抉择，究竟B是还有事没处理完，还是一会就关闭了，针对这一系列问题，我们来看断开连接时候的时序图。 从图中我们可以看到，当A说分手了，就进入FIN_WAIT_1的状态，可以理解为等待结束第一阶段，而B回复完A后也相应进入CLOSE_WAIT状态，理解为等待关闭。A收到B的回复，就进入了FIN_WAIT_2状态，如果此时B直接离开了，那A就一直保持在这个状态。如果B没有离开，主动地又说“再见”，然后它就进入了LSAT_ASK状态，然后A收到了B说得“再见”他也发送响应，“嗯，再见”然后进入了TIME_WAIT状态，当B收到A的ASK就会关闭了。而假如这个ASK没有到达，因为只有到达B才会进入关闭，但A已经进入关闭倒计时了，它会保持在这个状态一段时间，然后自动的关闭了，所以这段时间里，B会不断地发送“再见”，直到收到一条A的ASK为止。 假如B在A的最后这段“停留期”，还是没有等来一个回复，虽然它还是会发，当A收到这个后，就会直接回复一个RST，B就知道A跑了，就不再发“再见”了。 TCP 状态机其实就是将TCP连接和分手的两个时序图结合起来，就是表面看起来高大上的TCP状态机了。网络上的传输是没有连接的，包括TCP也是一样的，所谓的连接不过是通讯的双方维护的一个“连接状态”]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈大众传媒]]></title>
    <url>%2F2018%2F12%2F13%2F%E8%B0%88%E8%B0%88%E5%A4%A7%E4%BC%97%E4%BC%A0%E5%AA%92%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新思想和旧思想]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%96%B0%E6%80%9D%E6%83%B3%E5%92%8C%E6%97%A7%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PO、VO、BO、DTO、POJO、DAO之间的关系]]></title>
    <url>%2F2018%2F11%2F22%2FPO%E3%80%81VO%E3%80%81BO%E3%80%81DTO%E3%80%81POJO%E3%80%81DAO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈产品需求分析]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%B0%88%E8%B0%88%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java线程池]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP指北]]></title>
    <url>%2F2018%2F10%2F24%2FHTTP%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[HTTP概述HTTP是应用层的协议，当我们打开一个网页时，例如：http://www.baidu.com,浏览器会将这个域名地址发送给DNS服务器，然后解析为具体的IP地址。 建立好连接后，浏览器就可以发送HTTP的请求了，而一个完整的HTTP请求报文由三部分组成：请求行、请求头（首部）、请求体（实体）。每一行的末尾都有回车和换行，在请求体和请求头之间另起一行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是以key:value这样的键值对的形式存在的，请求体就是要传输的数据。 HTTP里有很多请求方法，其中最常用的就那么几个，对于访问网页来说，使用的最多的就是GET方法，用来向服务器端获取一些资源，具体返回什么，由服务端来决定。 另一个常用的请求方法类型是POST，它需要你主动告诉服务端一些信息，一般这些信息放在请求体里，与GET不同，POST更多是用来更新资源信息，GET提交请求的数据实体是放在URL后面，用?来分割，参数用&amp;连接，而且数据长度是有限制的，视具体的客户端而定，而POST没有限制，而且GET提交的数据是不安全的，因为相关参数会暴露在URL上。 还有一种类型，叫做PUT，它的作用是向指定资源位置上传最新内容，类似于FTP协议，文件内容包含在请求体里，不过HTTP服务器一般是不允许上传文件的，所以PUT和POST就都变成了要传给服务器内容的方法。 最后一种比较常见的方法就是DELETE，主要就是用来删除文件，是与PUT相反的方法，DELETE是要求返回URL指定的资源。 请求行的下面就是请求头了，保存了一些很重要的字段，例如, Content-Type 是指正文格式，如果是JSON格式的，就要把值设为JSON，而类似 Accept-Charset 则表示客户端可以接受的字符集，避免不必要的乱码。首部字段有很多，其实通过名字我们就能大概它的用法的，用到的时候可以想了解细节再去查。 当我们使用HTTP发送请求时，由于它是基于TCP协议，所以它使用面向连接的方式发送请求，在发送每段报文时，都需要对方回应一个ACK，确认已经到达，如果没有收到对方的回复，TCP就会重新进行传输，直到到达为止，而这个过程是TCP负责的，也就是说无论重新传输了几次，对于HTTP来说它只进行了一次传输，由TCP来完成这个送达的过程。 TCP每发送一个报文都会加上自己本身所在的地址以及它想要到达的另一端的位置，将它们放在IP头里，然后交给IP层进行传输。IP层会查看目标地址和自己所在的地址是否同在一个局域网里，如果在的话就发送ARP协议，获取目标地址的MAC地址，然后把自己的MAC地址和目标MAC地址放到MAC头发送出去，由另一端来进行层层对比确认，然后发送一个ACK，确认到达。如果不在一个局域网里，就要经过网关，而MAC头里放的就是网关的地址，因为我们不知道目标的MAC地址，网关再根据路由协议来获取下一跳的路由器MAC地址，然后加入到目标MAC地址那，由于还不是真正的目标MAC地址，会不断重复这个“寻找”的过程，直到下一跳是目标所在，然后获取到目标的MAC地址。 在TCP头里还有端口号，通过确认MAC地址，IP地址后，通过端口号，目标机器就会知道哪一个进程需要这个包，然后发送给那个进程，例如HTTP服务器，然后HTTP服务器就知道请求的资源是什么，然后把相关资源发送给客户端。 HTTP的返回报文和响应报文类似，简单来说响应报文由状态行、响应头（首部）、响应体（实体）组成，其中第一行是状态行，包含HTTP版本，状态码和状态短语，在一个回车换行之后是响应头，也是以键值对的形式，之后是响应体，也就是要传输的数据。 HTTP协议的特点 HTTP协议是无状态的什么是无状态，就是协议对于事务处理没有记忆能力，对于同一个URL请求没有上下文的联系，每一次的请求都是独立的，不会受前后结果的差异影响响应，但为了使它具有状态的特点，于是引入了 cookis 和 session 机制。 基于TCP协议HTTP协议属于应用层，它的目的是规定客户端和服务端数据传输的格式和数据交互行为，而数据传输的实现，它是基于传输层TCP协议实现的，它本身并不能进行数据传输。 HTTP的响应状态码状态码是用来告知客户端服务器端处理请求的结果。凭借状态码用户可以知道服务器是请求处理成功、失败或者是被转发；这样出现了错误也好定位。状态码是由3位数字加原因短语组成。3位数字中的第一位是用来指定状态的类别。共有五个类别。不过常用的也就16种，下面来详细介绍下： 1. 200：OK代表请求被正常的处理成功 2. 204：No Content请求处理成功，但是没有数据实体返回，也不允许有实体返回。比如说HEAD请求，可能就会返回204 No Content，因为HEAD就是只获取头信息。 3. 206：Partial Content这是客户端使用Content-Range指定了需要的实体数据的范围，然后服务端处理请求成功之后返回用户需要的这一部分数据而不是全部，执行的请求就是GET。返回码就是206：Partial Content。 4. 301： Moved Permanently代表永久性定向。该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL。也就是说如果已经把资源对应的URL保存为书签了，这是应该按照Location首部字段提示的URL重新保存。 5. 302：Found代表临时重定向。该状态码表示请求的资源已经被分配了新的URL，但是和301的区别是302代表的不是永久性的移动，只是临时的。就是说这个URL还可能会发生改变。如果保存成书签了也不会更新。 6. 303：See Other和302的区别是303明确规定客户端应当使用GET方法。 7. 304：Not Modified该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但是没有满足条件。304状态码返回时不包含任何数据实体。304虽然被划分在3XX中但是和重定向没有关系。 8. 307：Temporary Redirect临时重定向，与302 Found相同，但是302会把POST改成GET，而307就不会。 9. 400：Bad Request表示请求报文中存在语法错误。需要修改后再次发送。 10. 401：Unauthorized表示发送的请求需要有通过HTTP认证的认证信息。 11. 403：Forbidden表明请求访问的资源被拒绝了。没有获得服务器的访问权限，IP被禁止等。 12. 404：Not Found表明请求的资源在服务器上找不到。当然也可以在服务器拒绝请求且不想说明理由时使用。 13. 408：Request Timeout表示客户端请求超时，就是在客户端和服务器建立连接后服务器在一定时间内没有收到客户端的请求。 14. 500：Internal Server Error表明服务器端在执行请求时发生了错误，很有可能是服务端程序的Bug或者临时故障。 15. 503：Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After字段再返回给客户端。 16. 504：Getaway Timeout网关超时，是代理服务器等待应用服务器响应时的超时，和408 Request Timeout的却别就是504是服务器的原因而不是客户端的原因。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC与需求变化]]></title>
    <url>%2F2018%2F10%2F21%2FIOC%E4%B8%8E%E9%9C%80%E6%B1%82%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声望的陷阱]]></title>
    <url>%2F2018%2F10%2F11%2F%E5%A3%B0%E6%9C%9B%E7%9A%84%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[命运是解不开的谜团，声望是没有实际意义的云烟。 什么是声望？一个官方的解释是：声望是众所仰望的名声。人生在世，我们总有为声望所累的时候，但我的阅历尚浅，对于“声望”不好妄作评判，仅仅只能按我的理解，谈谈在当前时代下的“声望”的影响。 个人具有声望，组织和团体也具有声望，声望是一种看不见的影响力，它不好量化，但它却能无形中影响很多东西，就像我们玩的游戏，会有所谓的声望值，当你具备不同声望值时，就有权限获得一些稀有物品一样。 但游戏终究和现实不同，现实世界充满着许许多多的不确定性。可能具有很高声望的人或事物，会对人们的判断施加一定的影响，因为我们辨别和判断一件事物的好坏需要经过深思熟虑，这个过程对很多人而言并不那么“友好”，而具有了高声望，就能在判断上给予一定的肯定，简化了“深思熟虑”这项工作的任务量，因为声望的积累是基于大量的评价和时间的考量的，更能使人确信“它”对自身是有益的，由于思维的“惯性”我们就会自然而然选择了相信。 如同品牌效应，大厂出品一定会因为它完善的工艺和流程，质量上一定比同类产品更好。但销量高并不一定代表质量好，它们之间并不存在绝对意义上的正相关。对外部具有很高声望事物的盲目肯定，终会使我们的判断受制于对方。 假如没有了声望对判断施加的影响，那么真正吸引我们的，又是对方的什么呢？就拿衣食住行来说，我们选购一件衣物的判断，究竟是基于对品牌所积累的声望的信任，认为它一定用了优质的物料，一流的设计，还是商品本身质量就很不错呢？毕竟我们的世界是变化的，同样的产品或是服务，终究会随着时间的流逝产生差异的变动，很难“始终如一”。 如果商品和服务是我们还能切身在短时间内能感受到变化的，比较容易减小声望对人判断的影响。那么人呢？评判和了解一个人或许是一件复杂度极高的任务，我们难以短时间真正了解一个人，我们所基于的判断，来源于那个人的过去经历，例如他的受教育水平，是否具有本科学历，进而又要细分是否是名牌一流大学，因为那些大学本身所具有的声望能证明很多东西。如果是在校时就看在校的比赛获奖情况，进而又要区别看比赛的规模和大小，因为一些比赛具备参考价值，它确实选拔出了许多出色的人才，随着时间的积累，这个比赛所积累的声望就成为了一种“隐性标志”，暗示只要我获奖了，那么代表了我和曾经获奖的那些名人也具备同样的素质和潜力，而名人的成功也间接为类似比赛的声望添砖加瓦。但事物是变化的，我们只能保证在那样一个时间段里，它确实具有参考价值，含金量十足，但随着时代的发展，事物的更迭，能时刻保持领先，并始终拥有与之匹配的声望的事物是何其稀少。 当前的时代是网络时代，处于这个时代背景下的我们无法避免声望对我们判断施加的影响，而且网络的虚拟化，谁又知道一切是真的，而非虚张声势搭建起来的声望呢？网上购物商城的一些评价可以通过刷单刷好评取得消费者的信任，而最近大火的抖音，我们可以搬运别人的创意，成为自己涨粉的途径，哪怕只是从一些科普常识上搬运一些看起来有价值的东西，加上一个相关行业的背景，却能带来巨大的流量，点赞量和粉丝量无形为其树立起了某种声望，因为这类开放平台的用户量太多了，聚集了不同层次的人，但点赞量和粉丝量却是“一视同仁”的。 在这样的时代里，最能直接影响声望变化的，或许就是建立于社交媒体之上的舆论导向的，通过巧妙刻意的包装，引起舆论的关注，随即带来巨大的流量，无论是提高声望还是影响竞争对手的声望，都是无形的，如果对方的公关不能应对得当，那么就会陷入舆论的漩涡，或许可以通过一些形式“洗白”，但也依然会产生一些无形的影响，而往往这些“看不见”的东西更具风险性。 不要因为“声望”影响了我们对真实世界的认知，它可以作为评判的依据和参考，但不能作为先入为主的第一选择，无论是对任何事物，亦或是任何人，我们要关注于那些真正决定其本身的东西，避免陷入声望的陷阱。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector、ArrayList、LinkedList的区别]]></title>
    <url>%2F2018%2F10%2F02%2FVector%E3%80%81ArrayList%E3%80%81LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为何会选择技术之路]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%88%91%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat学习总结]]></title>
    <url>%2F2018%2F09%2F23%2FTomcat%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[#]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Java泛型]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%B5%85%E6%9E%90Java%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本技术类书籍]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%B1%BB%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类的理解]]></title>
    <url>%2F2018%2F09%2F12%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别浅析]]></title>
    <url>%2F2018%2F08%2F26%2FString%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript中的继承机制]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[原型链传统的面向对象语言里，基本都支持继承的两种方式：接口继承和实现继承。接口继承继承方法签名，而实现继承则继承实际的方法。至于JavaScript里的继承，由于函数没有签名，只能支持实现继承，而且主要通过原型链来实现的。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例又都包含一个指向原型对象的内部指针，通过使用原型，将方法添加在”父类“的原型里，然后”子类“的原型就是父类的一个实例化对象。1SubClass.prototype = new SuperClass() ; 如此层层递进，就构成了实例与原型的链条，这就是原型链。但原型链也有问题，原先实例的属性会在这个继承的过程中顺理成章的成为其“子类”的原型属性。而且创建的”子类“的实例，无法在不影响所有对象实例的情况下，像”超类“的构造函数传递参数，于是有了构造函数继承。 构造函数继承构造函数继承的核心思想就是SuperClass.call(this),通过call()和apply()方法，在新创建的对象上执行构造函数，然后改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题。123456function SuperClass()&#123; this.colors = ["read","blue","yellow"];&#125;function SubClsss()&#123; SuperClass.call(this);&#125; 组合式继承组合式继承，也叫作伪经典继承，结合了前两者的特点，既不会使每个实例化的“子类”互相影响，也避免了内存的浪费。它使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。既可以在原型上定义方法实现实现函数复用，又能保证每个实例都有它自己单独的属性。123456789101112131415161718192021function SuperClass()&#123; this.name = name; this.colors = ["read","blue","yellow"];&#125;SuperClass.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubClass(name, age)&#123; //继承属性 SuperClass.call(this, name); this.age = age&#125;//继承方法SubClass.prototype = new SuperClassSubClass.prototype.constructor = SubClass;SubClass.prototype.sayAge = function() &#123; console.log(this.age);&#125; 寄生式继承寄生式继承的思路是创建一个仅用于封装继承过程的函数，该函数的内部以某种方式来增强对象，然后返回对象，就像所有都是它做的一样，很像工厂模式。12345678function MyClass(original)&#123; //通过调用函数创建一个新对象 var clone = object(original); clone.sayHello = function() &#123; console.log("Hello"); &#125;; return clone;&#125; 不过使用这种模式来为对象添加函数，会因为不能做到函数复用而降低效率，所以出现了寄生组合式继承。 寄生组合式继承组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。集寄生式继承和组合继承的优点于一身，本质上就是使用寄生式继承来继承“超类”的原型，然后再将结果指定给“子类”的原型。123456789101112131415161718192021222324function inheritObject(subClass,superClass) &#123; //复制一份父类的原型保存在变量中 var p = inheritObject(superClass.prototype); //修正因为重写子类原型导致子类constructor属性被修改 p.constructor = subClass; //设置子类的原型 subClass.prototype = p; &#125; //定义父类var SuperClass = function (name) &#123; this.name = name; this.books = ['javascript','html','css'] &#125;;//定义父类原型方法SuperClass.prototype.getBooks = function () &#123; console.log(this.books)&#125;;//定义子类var SubClass = function (name) &#123; SuperClass.call(this,name)&#125;inheritObject(SubClass,SuperClass);var subclass1 = new SubClass('Java')]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何高效提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、finally、finalize的区别]]></title>
    <url>%2F2018%2F08%2F17%2Ffinal%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this原理]]></title>
    <url>%2F2018%2F08%2F17%2FJavaScript%E4%B8%AD%E7%9A%84this%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于this为啥要有这个关键字呢？如果不使用this，我们在写代码时就需要显示的传入上下文对象。会很麻烦，随着代码量的增多，会使代码变得混乱，而this可以隐式“传递”一个对象的引用，利于代码复用，因为它会动态的判断上下文环境，然后引用合适的上下文对象。 我们可能会在学习时产生片面的误解，一种是我们认为this指向函数自身，另一种是我们认为this指向函数的作用域。因为在一些情况下，它们是对的，但有时却是错误的，举例来说：12345678function foo() &#123;var a = 2;this.bar();&#125;function bar() &#123;console.log( this.a );&#125;foo(); // ReferenceError: a is not defined 如果按之间的观点，那这段代码应该能正确调用，但实则不能，可见this关键字不是我们之前想的那样。 this是什么 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。 理解this的前提，我们需要知道什么叫做调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置，通过调用位置我们才好判断this究竟引用的是什么。 this的指向this永远指向最后调用它的那个对象，通过这句话就能很容易判断this的指向，因为调用位置就在当前正在执行的函数的前一个调用中。 默认绑定12345function foo() &#123;console.log( this.a );&#125;var a = 1;foo(); // 1 我们可以看到，最后调用foo()的地方，它的前面没有明显的调用对象，所以就是全局对象window，相当于window.foo()那么this的指向就是就是window这个全局对象，所以window.a的值就是1。这是默认的绑定情况。 隐式绑定我们有时候还要考虑调用位置是否具有上下文对象，可以看一个例子：12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;obj.foo(); // 1 这就简单了，因为this永远指向最后调用它的那个对象，最后调用它的是obj，所以就相当于obj.a，所以值为1，下面是另一种情况，可能我们调用时是在一个属性引用链上：123456789101112function foo() &#123;console.log( this.a );&#125;var obj2 = &#123;a: 2,foo: foo&#125;;var obj1 = &#123;a: 1,obj2: obj2&#125;;obj1.obj2.foo(); // 2 不用在意obj1，这里我们要强调“最后调用”，所以最后调用的是obj2，obj1先调用obj2，obj2再调用foo(),所以结果就是obj2.a，所以值为2。 但假如我们给函数起了别名，可以通过一个例子看一下：12345678910function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;var bar = obj.foo; // 函数别名！var a = "hello"; // a 是全局对象的属性bar(); // "hello" 虽然我们将 obj 对象的 foo 方法赋值给变量 bar 了，但是没有调用，所以bar()最后还是被全局对象window调用了，this的指向就是window，就相当于window.a，所以值为hello。 不过我们需要尤为注意回调函数里的this的指向问题，因为回调函数里我们传入的函数，实际上它相当于给里面的形参取了一个别名。当我们分析this的指向时，它实际的指向会被误导，但实质上它还是指向最后调用它的那个对象。 显式绑定如果我们想在某个对象上强制调用函数，可以直接指定this指向的对象，什么意思呢，我们先看一个例子：12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:1&#125;;var a = 2;foo.call( obj ); // 1 我们通过call()函数，将obj的作用域传递进了foo中，因为JavaScript存在一个作用域链，相当于我们window.obj.foo(),所以最后调用的是obj对象，所以值为1。我们把foo的this绑定到了obj上。也可以通过apply()和bind()方法。 new绑定12345function foo(a) &#123;this.a = a;&#125;var bar = new foo(1);console.log( bar.a ); // 1 使用new来调用foo()时，我们会构造一个新对象，这个新对象会绑定到foo()调用中的this上，所以bar.a的值就是1，和隐式绑定里的取别名是不一样的，它依然指向最后调用它的那个对象。 箭头函数ES6里，我们可以使用箭头函数始终指向函数定义时的this，不用担心执行时改变，在箭头函数里也没有this绑定了，上面四条绑定原则也不存在了，要根据作用域链来决定它的值，箭头函数会继承外层函数调用的 this 绑定。12345678910111213var a = "hello";var ogj = &#123; b : "hi" func1: function () &#123; console.log(this.b); &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;obj.func2() // hi 总结总之，我们要记住”this永远指向最后调用它的那个对象“，具体绑定的方式，如果是由new调用，那它就绑定到了新创建的对象上，如果由call()、apply()、bind()调用，那么就是在绑定的那个对象上，如果包含上下文调用的隐式绑定，要注意上下文对象，如果包含回调函数，要格外小心。如果使用了箭头函数，注意根据作用域链来决定“this”的指向。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析Java的static关键字]]></title>
    <url>%2F2018%2F08%2F13%2F%E8%A7%A3%E6%9E%90Java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口和抽象类的区别]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript的闭包]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[JavaScript里的闭包是它的一个特色，这也是静态语言所不具备的一个特性，很多高级功能都依靠闭包来实现，理解闭包其实一点都不困难。 变量作用域理解闭包的前提是理解JavaScript的变量作用域，变量的作用域分为全局变量和局部变量， JavaScript具有基于函数的作用域，每声明一个函数都会为其自身创建一个自己的执行环境，而且在函数内部就可以直接访问全局变量。12345var a = 1function func1()&#123; console.log(a);&#125;func1(); // 1 但是在函数外是无法访问函数内的局部变量的。不过如果不使用var关键字，就会在内部作用域声明一个全局变量。1234function func1()&#123; var a = 1&#125;console.log(a); // error 这里就涉及到一个问题，假如我们需要读取函数内部的变量怎么办？于是我们只能在函数的内部再定义一个函数。123456789function func1()&#123; var a = 1 function func2()&#123; console.log(a); &#125; return func2;&#125;var n = func1();n(); // 1 此时，func1内的所有局部变量对于func2来说都是可见的，func1的返回值，也就是func2（），赋值给变量n，然后调用n(),实际只是通过不同的标识符来引用调用了内部的函数func2(). 闭包说了半天，那么闭包到底是啥，我的理解是：闭包就是函数的局部变量的集合，能够读取其他函数的局部变量，只有定义在函数内部的子函数才可以获取局部变量，当一个函数定义在另一个函数内，并且试图通过子函数获得局部变量，它就是闭包。 闭包使得函数内部作用域和函数外部作用域的连接成为了可能，局部变量可以在函数返回后被访问，而且闭包里变量的值可以始终保持在内存中，我们可以通过一个例子来看：123456789101112131415function func1()&#123; var n=1; Add = function()&#123; n += 1 &#125; function func2()&#123; console.log(n); &#125; return func2;&#125;var result = func1();result(); // 1Add();result(); // 2 可以看到局部变量n一直保存在内存中，不会随着函数调用的结束而被垃圾回收，func2是func1的子函数，但作为func1的返回值，却被赋值给了一个全局变量result，这就使得func2始终在内存中，因为func2的存在依赖于func1，所以func1也就跟着保存在了内存中。 前面提到，如果不使用var关键字，会在内部声明一个全局变量，所以Add就是一个全局变量，但它可以在函数外部对内部的局部变量进行操作，实则它也是一个闭包。 过渡的使用闭包，内存消耗会很大，但闭包的用处也很多，在定时器、事件监听器、Ajax 请求、跨窗口通信或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上就是在使用闭包。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中医与程序员]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%B8%AD%E5%8C%BB%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[在我看来，计算机产业还是一个很“年轻”的行业，相比于其他传统的行业起步要晚，但它发展迅猛，短短几十年便跻身影响当今世界发展的重要产业之一。而且从事计算机这个行业可以说“门槛”很低，这个门槛并不是入行的门槛，而是能让你不断提高有机会成为这个领域大牛的门槛，相对于其他复杂度接近的行业来说。因为技术是相对开放和自由的，只要你愿意，你能获得很多的资源，像 Github这样的开源社区，亦或是 stackoverflow 这样的技术问答网站，你都能从中了解和学习到很多流行的技术。 计算机科学里很多概念可以让我们从一种新的角度来理解事物，若利用得当，可以避免陷入解决不同问题时，总用使用“一把锤子”的思维局限，不同的问题若用同样的方式来处理，真的能把问题处理好吗？ 例如中医和西医，如果从计算机专业的角度，中医更像是“应用型程序员”，他们通过现有的框架和API的调用，建立在抽象的角度来解决不同的问题，为此他们需要熟知各类方法，API接口的作用和组合后产生的影响，很像中医里对草药作用的了解和应用。 《thinking Java》里说“万物皆为对象”，其实创造这些草药的“库程序员”正是大自然本身，它所采用的构建方式极其复杂，抽象层次很高，它把这一系列的细节都已经封装好了，使得传统中医并不需要知道这些草药中究竟是哪一具体的物质是对特定病症有效的，因为“草药对象”本身封装了“数据”和“方法”，传统中医只需知道它们的作用以及用法对症下药即可。 西医与中医不同，对于医药研究来说，它们更像是“库程序员”，需要对自然界不同的物质进行分析、提取和研究，以便真正弄清是哪一具体物质对人体的哪一具体细胞组织产生作用，因而也要研究人体的生理层次的构造。或是进行组合，看这种变化是否符合预期，而对于产生作用了的新物质，会用一个特定的标识符来为其命名。 但有一个问题，它们所研究的这些“对象”本身就是由自然界这个最伟大的“库程序员”经历漫长的演化而来的，所以生命是伟大的，看似简单，但那是因为它们“构建”于不同的抽象层次并封装了一系列的实现细节，我们研究“抽象”，而“抽象”也形塑我们。 西医的一些研究过程，就如同抽丝剥茧般的去“解封装”，通过不同的工具去试图解构更底层的实现，通过了解物质之间的相互作用，就能获取特定的物质，再以此为基础研究新型的药物，这些新药是“自然界”之前所没有的，被人为创造出来，如同通过一个旧有的框架和库，依托于它产生了一个新的框架和库。 有趣的是，中医更多依赖于于大自然这个“标准库”，依靠大自然这位最伟大的“库程序员”来提供解决问题的方法，而西医更多通过“解封装”，再进行抽象的形式自建“第三方库”，来解决问题，谈不上哪个更为高明，本质上就是不同的。西医也无法保证，已经“解封装”到了最底层，弄清了各个原子对象及其所有实现细节，需要不断地去推进对于“对象构建”本身的研究。而中医也不可能完全驾驭“自然界”这个庞大的库，因为宇宙是无垠而未知的，我们对它的探索也远未到极限。 只要存在了可能性，中医也好西医也罢都会在各自的道路上不断前进。那个推动我们朝一个领域前进的动力又是什么呢？]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript的“面向对象”编程]]></title>
    <url>%2F2018%2F07%2F17%2F%E8%B0%88%E8%B0%88JavaScript%E7%9A%84%E2%80%9C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[初识JavaScript面向对象相对于Java里的面向对象来说，JavaScript里的面向对象机制绝对可以称之为“另类”了，因为如果我们具有Java/C++这类传统面向对象语言的使用经验，以那样的思维来学习JavaScript的面向对象令你产生很多疑惑。 定义一个JavaScript对象很简单，我们可以：1var a = &#123;&#125;; 也可以用其他的方式：12function f() &#123;&#125; 可能你会产生疑惑，这不应该是一个函数吗？咋就变成对象了，因为在JavaScript里函数也是对象，而且还是一等公民。而在很多传统语言中，例如Java、C/C++等，函数都是二等公民的身份。什么叫二等公民呢？你只能用语言的关键字声明一个函数然后调用它，如果需要把函数作为参数传给另一个函数，或者赋值给一个本地变量，又或是作为返回值，就需要通过函数指针、代理等特殊的方式周折一番。 而在JavaScript里的函数，它不仅拥有一切传统函数的使用方式，而且可以做到像简单值一样赋值、传参、返回，而且JavaScript中的函数还可以充当“类”的构造函数，同时又是一个Function类的实例，这样的多重身份让JavaScript里的函数变得极其重要，使得 JavaScript 更像是 Scheme （一种函数式语言）。 JavaScript提供了一个构造函数模式来在创建对象时初始化对象，而构造函数也只是一个普通的函数，只不过它内部使用this，使用new生成实例，在这一点上很像传统的面向对象语言。而this总是指向当前对象，无论是添加属性还是方法，都只在当前对象添加，实例化一个新对象时，就会在内存里复制一份，但过多的新对象不可避免会造成大量的内存浪费。 为了解决这一问题，于是有了原型prototype的形式，在JavaScript里，每一个构造函数都有一个prototype属性，指向另一个对象，这个对象的所有实例和方法都会被构造函数的实例继承，对于不变的属性和方法，可以直接添加在类的prototype对象上。功能上来看，很像Java里接口的概念，尤其是Java 8引入了接口的默认方法，二者在功能上看上去更为接近。123456function Dog(name,color)&#123; this.name = name; this.color = color; &#125; Dog.prototype.type = "宠物"; Dog.prototype.eat = function()&#123;alert("吃狗粮")&#125;; 当我们生成实例时，实例里的属性和方法其实都在同一个内存地址，指向prototype对象，避免了不必要的内存浪费。但也会因为改动一个对象的属性而可能影响到其他相关的对象，而利用构造函数的形式则没有这样的弊端。 传统的面向对象语言里，例如Java，会有相应的访问控制功能，借助于public、protected、private这三个关键字，而JavaScript里则没有类似的关键字，但为了实现类似的功能，例如属性和方法的私有，就可以借助于函数作用域的特性，因为函数内的局部变量如果不通过闭包等方式是无法直接访问的，对外层作用域而言就是“私有”的。 Javascript里的“类”在ES6之前，JavaScript只有一些近似类的语法元素。JavaScript里没有“子类”和“父类”的区分，也没有“类”和”实例“的区别，我们可以模拟出传统面向对象语言里类的特点，但它的机制和我们理解的类的概念是完全不同的，只是通过”语法糖“的包装和”类“库的存在让我们误以为JavaScript的类存在而已。 那么”类“中的继承又是如何做到的呢？JavaScript主要依靠继承链来解决继承的问题。传统情况下，我们在JavaScript生成一个实例的方法都是通过构造函数，类似于这样：12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 而在其他传统面向对象语言里，一般情况下，都是生成一个class，然后再通过类的构造器来生成相应的实例对象，所以JavaScript显得很特别。在ES6里引入了“class”的概念和关键字，通过这个关键字，可以定义一个“类”。像这样：12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 这样的形式就不容易使人困惑了，它就更接近我们认知里的类的概念了。ES5里的Point构造方法就是ES6里Point“类”里的构造方法,而且toString方法也定义在了“类”里，而在“类”里的方法是不需要function关键字的。 某种意义上ES6里的“类”就是一个语法糖而已。。。实际上基本可以看作传统构造函数的一种简便写法。因为类里的所有方法实际上还是定义在prototype属性上面。12345678910111213class Point &#123; constructor() &#123; &#125; toString() &#123; &#125;&#125;//等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;,&#125;; 而在“类”的实例上调用方法，其实就是在调用原型上的方法。不过也有一些差别，在“类”的内部所有定义的方法都是不可枚举的。 在JavaScript里，定义函数的方式有两种，一种是函数声明，一种是函数表达式：1234567//函数声明function functionName(arg)&#123;&#125;//等同于函数表达式var functionName = function(arg)&#123;&#125;; 对于类来说一样也可以通过表达式定义12345const MyClass = class Point &#123; getClassName() &#123; return Point.name; &#125;&#125;; 只不过这个类的名字不再是Point，而是MyClass，Point只在class的内部使用，指代当前类。 JavaScript里的函数声明具有函数声明提升的特征，即使放在相关调用语句之后，也会在执行代码之前先读取函数声明，而类不存在这样的提升特性。因为ES6里的“类”，依然只是之前的构造函数的一层包装罢了。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式小记]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于正则表达式正则表达式是为了从大量数据中检索匹配出所需数据的一种强有力的工具，它赋予使用者描述和分析文本的能力，如果没有正则表达式，我们也可以实现同样的功能，只是需要通过循环遍历，通过大量的条件判断才能得到想要的结果。而正则表达式只需要简单的而命令，就能够检索所有文件。 常用元字符“ . “: 使用.字符匹配任意单个字符、字母、数字或者.字符本身，不过要在.的前面加上 \ ，对它进行转义，匹配其他元字符也一样。“^”: 使用^会匹配行或者字符串的起始位置“$”: 使用$会匹配行或者字符串的末位“\d”: 匹配数字，如果是匹配非数字字符，只用把d大写就行\D“\w”: 匹配字母数字和下划线，等价于[a-zA-Z0-9_],如果是匹配非字母数字或下划线字符，只用把w大写就行\W“\s”: 匹配空白字符，如果是匹配非空白字符，只用把s大写就行\S“\b”: 匹配一个单词的开始或是结尾，这个“单词”在正则表达式看来就是一个与\w相匹配的字符和一个与\W相匹配的字符之间的位置，它只匹配一个位置，不匹配任何字符，\B表示不匹配一个单词的边界“ [ ] “: 只匹配括号内定义的字符集合，字符集合可以按字符区间来表示区间内所有字符，以下是一些合法的字符区间例子: A-Z 匹配A到Z的所有大写字母 a-z 匹配A到Z的所有小写字母 A-z 匹配ASCII字符A到ASCALL字符z的所有字符，其中也包含[或是^等类似字符，可能匹配到多余结果。 POSIX字符类POSIX字符类是一种正则表达式的简写形式，可以通过元字符和POSIX字符类的组合来简化正则表达式。 重复匹配正则表达式可以进行重复匹配，匹配多个连续出现的字符或者字符集。 “ * “：匹配零次或多次例如：a*会匹配到所有的字符或字符集为”a”的情况 “ + “：匹配一次或多次，至少一次例如：a+会匹配到字符或字符集中为”a”的情况，a+与a*不同在于”+”至少是一次而”*” 可以是0次 “ ? “：匹配零次或一次例如：a?只会匹配一次，也就是结果可能只有单个字符a “{n}”：重复n次匹配例如：a{3}结果就是匹配到满足3个a字符的情况 “aaa” “{n,m}”：重复n到m次匹配例如：a{2,3} 将a重复匹配2次或者3次 所以匹配到的字符可以是两个”aa”也可以是三个”aaa” “{n,}”：重复n次或更多次匹配，至少匹配n次 子表达式子表达式是为了解决一些特殊匹配情况下使用的，使用一对圆括号把正则表达式括起来，按我的理解，其实它就是解决一个优先级和整体匹配的问题，类似于C语言里的双括号，为了显式增强操作符优先级顺序，避免混乱。 举个例子：&amp;nbsp;{2,4} 这个正则表达式的原意是为了匹配&amp;nbsp两次到四次，但实际{2,4}只作用于它的前一个字符，相当于它只会匹配到&amp;nbsp;; 、 &amp;nbsp;;; 、 &amp;nbsp;;;;。 所以引入了子表达式，(&amp;nbsp;){2,4}这样就能按我们预期的结果进行匹配了，它会把&amp;nbsp;看成一个整体进行匹配。 子表达式也是可以进行嵌套使用的，但我们要尽量避免嵌套次数过多引起的逻辑混乱，阅读困难。 常见问题的正则表达式这里是一些网上搜集的常见的正则表达式匹配的例子，学习正则表达式最好的方式就是多练习多思考，通过这些简单的例子作为参考来学习，由浅入深，而不是直接复制拿来用，真正掌握了正则表达式才能灵活应对各种情况。它仅仅是一个方法的参考，而非方法本身。 检验数字 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m - n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1 - 2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1 - 3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 非零的负整数： ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 非负浮点数：^\d+(\.\d+)?$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 浮点数：^(-?\d+)(\.\d+)?$ 校验字符 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 可以输入含有\^\%\&amp;\’\,\;\=\?\$\“等字符：[^%&amp;&#39;,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 其他需求 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? URL地址：^https?://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^([1][3,4,5,6,7,8,9])\d{9}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[\da-zA-Z]{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代，如果你觉得空字符串也可以接受的话，最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 双字节字符 (包括汉字在内，可以用来计算字符串的长度，一个双字节字符长度计2，ASCII字符计1)：[^\x00-\xff] 空白行的正则表达式 (可以用来删除空白行，windows的换行是\n\r，而linux和unix中换行是\n，这点需要注意)：\n\s*\r HTML标记 (仅仅能部分匹配，对于复杂的嵌套标记依旧无能为力)：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; 首尾空白字符(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等，非常实用)：^\s*|\s*$或(^\s*)|(\s*$) 腾讯QQ号(腾讯QQ号从10000开始) ：[1-9][0-9]{4,} 中国邮政编码 (中国邮政编码为6位数字)：[1-9]\d{5}(?!\d) IP地址 (提取IP地址时有用)：(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5])) 或 ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 参考文章： http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些值得参考的摄影名言]]></title>
    <url>%2F2018%2F07%2F01%2F%E9%82%A3%E4%BA%9B%E5%80%BC%E5%BE%97%E5%8F%82%E8%80%83%E7%9A%84%E6%91%84%E5%BD%B1%E5%90%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于指针和数组]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组和指针之间的关系很微妙，我们有时会遇到这样的例子，对于a[2]这样的数组，其实就相当于*(a + 2)，然后我们就自然而然地认为数组和指针是一样的了，可以互换，除非是在我们实际应用过程中出现了问题，我们才会在不断修正中明白，其实数组和指针并不同，只有在满足一些条件的情况下，数组和指针才可以进行互换。 指针和数组的不同指针是用来保存数据的地址的变量，而数组则是用来保存数据；我们可以通过指针进行间接访问，取得里面的地址值，再通过那个地址值提取数据，如果p是一个指针，它有一个下标，例如p[2],它就把指针里储存的地址值与2相加，再从这个新地址求值，而数组则是直接访问数据，a[2]只是简单的以a + 2的偏移量取得数据。指针通常指向匿名数据，而数组自身就是数据名，所以指针依赖于malloc(),free()这类函数来解决内存问题，而数组的话则是隐式的分配和删除。 什么情况下指针可以和数组互换首先表达式里的数组名被编译器当做一个指向该数组第一个元素的指针时，例如1int a[5],*b,i = 2; 那么我们访问a[i]时，可以通过以下方式12b = a;b[i]; 12b = a;*(b+i); 12b = a + i;*b; C语言把数组下标改写为指针偏移量的根本原因是因为指针和偏移量是底层硬件使用的基本模型。当下标总是与指针的偏移量相同时，就可以互换。例如：12for(i = 0; i&lt;=10; i ++) a[i] = 0; 相当于123b = a;for (i = 0; i&lt;=10; i++) b[i] = 0; 其中的b[i] = 0又可以写成*(b + i) = 0 如果声明是int *a[]呢，由于下标的优先级更高所以它表示一个数组，它里面的元素类型是指向整型的指针，所以它相当于一个指针数组。指针数组最频繁的用处在于储存长度不同的字符串，因为你不用固定分配大小去浪费储存空间，指针数组更具动态扩展性。 我们可以使用括号，使得int (*a)[]，那么它就表示一个指向整型数组的指针。 还有一种情况数组名等于指针，那就是当一个数组作为函数参数时，因为编译器会把数组的形式改写为指向数组的第一个元素的指针的形式，它只向函数传递一个地址值，而不是整个数组的拷贝，这更多是出于效率考虑。例如int (*abc())[10],abc是一个函数，它返回一个指向包含10个int元素的数组的指针。 在C语言中，严格来说，函数是不能直接返回函数和数组的，但可以让函数返回一个指向任何数据类型的指针，例如int *a(),它的返回值是一个指向整型的指针，而int (*a)()，左边的一对对括号迫使间接访问在函数调用之前进行，使a成为一个函数指针,它所指向的函数返回一个整型值。 我们再来看下int *(*a)(),它所指向的函数的返回值是一个指向整型的指针。如果声明是int (*a[])()，可能有点复杂，但实质上它表示一个数组，数组的类型是指向函数的指针，它所指向的函数的返回值是一个整数，如果声明是int *(*a[])()，我们就知道，它表示一个数组，数组的类型是指向函数的指针，而它所指向的函数的返回值是一个指向整型的指针。 关于指针和多维数组对于C语言而言，定义和引用一个多维数组的办法就是使用数组的数组，也就是数组的嵌套，例如a[3][5]，那么a是啥呢，我们可以把它看作是一个一维数组，它包含三个元素，每个元素包含五个整型值，所以a所指向的就是一个包含五个元素的数组而a+1就相当于指向a的另一行数组，如果是*(a+1)则表示它指向那一行的第一个元素而*（a+1)+1，其实就相当于比原来的表达式向后移动了一个元素，如果对整个表达式进一步处理一下，*(*（a+1)+1),那么它作为右值就相当于对那个位置的值间接引用，而作为左值，这个位置就代表那块空间，它可以被赋予新值。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和操作符]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%8C%87%E9%92%88%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[关于操作符你需要知道在谈论指针之前，我们很有必要说一下C语言里的操作符，C语言里有着种类繁多的各式操作符，大致可以分为算术操作符（+ - / %）、移位操作符（&lt;&lt; &gt;&gt;）、位操作符（&amp; | ^）、赋值符（=）、复合赋值符（+= -= = %= /= &lt;&lt;= &gt;&gt;= &amp;= |= ^=）、单目操作符（! ++ – - &amp; sizeof ~ + ）关系操作符（&gt; &lt; == &gt;= &lt;= !=）逻辑操作符（&amp;&amp; ||）条件操作符（expression1 ? expression2 : expression3）、*逗号操作符（,）。 操作符的复杂主要体现在它的优先级和结合性，两个相邻的操作符哪一个先执行取决于它的优先级，在它们优先级相同的情况下又要考虑它们的结合性，是左结合还是右结合，尤其是和指针联系在一起时更容易产生错误的执行结果，因为相对于其他语言，诸如Java、Python来说，指针是C语言的一个特色，也是一个难点。 对于操作符的优先级问题，可能一个最直接有效的办法就是添加括号，但是当表达式有太多的括号时反而不容易理解，所以适当的记住一些常见易混的操作符优先级，并适当的使用括号来辅助理解是一种很不错的方法。为此我们需要记住任何一个逻辑运算符的优先级都要低于任何一个关系运算符，而移位操作符的优先级比算术操作符要低，但要比关系操作符高。 关于指针你需要知道指针实质是表示内存地址的变量，指针主要做两件事：避免副本和共享数据。由于C语言中的一切函数调用，值传递都是“按值传递”的，它会创建一个拷贝的副本来进行操作，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成，也就是“按址传递”，而这个过程数据是共享的。所有赋值都会复制数据，如果你想复制数据的引用，就应该赋指针。 对指针进行间接访问之前，要确认它们已经被初始化，否则仅仅声明了一个指针却没有对他进行初始化，例如：12int *a;*a = 12; 是无法得知它的正确地址的，因为声明一个指针变量并不会分配任何内存。 指针和操作符的问题举个例子，就拿以下代码来说12int ab = 4;int *cp = &amp;ab; 当不同的表达式作为左值和右值时，它们表达的东西是不同的，对于左值来说，他表示的是一块明确的地址空间，而右值是一块地址空间里的值。 当我们的表达式是&amp;ab时，作为右值他表示变量ab的储存空间地址值，他也有一个地方来储存这个值，但我们没办法知道那块空间的具体位置，没有标识是一个明确的特定位置，所以作为左值，使用取址操作符的变量都是非法的。 当我们的表达式是cp时，作为左值他就表示的是cp本身的地址空间，作为右值就是表示变量ab的地址值。 当我们的表达式是&amp;cp时，我们知道它不能作为左值，对于右值来说，他是一个空间地址的值，也就是指针变量所在的那块空间的地址值，而指针变量中又保存着他指向那个对象的地址值，也就是指针的指针。对于指针的指针，类似于int **a,只有当确实需要时，才应该使用多层间接访问，不然程序会变得难以维护和理解。 当我们的表达式是*cp时，它相当于一个间接访问(解引用)，作为左值就表示ab所在那块空间，我们可以将新的值作为右值替换掉里面的原内容，作为右值就表示那块空间里原本存放的内容。 当我们的表达式是*cp + 1时，由于*操作符的优先级高于+，所以首先执行*cp,作为右值，也就是ab里保存的内容4,所以作为右值的结果就是5，但作为左值，我们知道这个结果需要一个位置保存，但那个位置没有明确定义，所以作为左值是不合法的。 当我们的表达式是*(cp + 1)时,作为右值，我们知道cp它表示ab的地址值，由于有括号，所以优先级更高，地址值+1后对那块地址值空间进行间接引用，获得那块空间里保存的对象。 涉及到前置和后置递增递减运算符时，可能是最容易产生错误的了，无论是遇到前置递增（递减）操作符还是后置递增（递减）操作符时，它都会产生一个原指针的拷贝，也就是里面所保存的指向某一内容的地址值，然后拷贝的这个地址值会放到一个新的空间里，如果是前置递增（递减）操作符会先进行原地址值的自增（自减）操作，所以他复制的拷贝会是自增（自减）后的新地址值，然后新的指针和原指针都将指向一个新的位置，并可以在拷贝上执行间接访问操作，访问那个未知的值；如果是后置，不会先进行自增操作求值，所以拷贝的值会是原指针的地址值，它和原指针指向相同的位置，而之前保存地址的那个位置将进行自增/自减操作，地址值更新并指向一个新的位置，由于我们是在拷贝的指针上执行间接访问操作，所以依然指向原地址值。C语言中所有对象，包括指针本身都是 “复制传值” 传递。例如： ++cp,在进行运算前它会先获取一个自增后的拷贝，我们知道作为右值时，cp代表的就是ab那个位置的地址值，由于自增，所以指向它的下一个地址值，但作为左值，因为自增后的拷贝结果是位于一个无法清晰定义的位置，所以不能作为左值。 cp++,由于是后置自增运算，所以不会先进行自增操作，所以拷贝的值的位置依然指向原地址，而原cp会在运算结束后求值，所以它会指向ab位置的下一块内存空间。 *++cp，通过++cp我们知道它指向的是ab的下一块内存空间，由于*的操作符优先级要比自增（自减）操作符低，所以它相当于(*(++cp))，对那块空间执行间接引用，作为左值时表示那块空间的地址，作为右值则表示那块空间里存储的未知值。 *cp++,通过运算符优先级我们知道，它相当于(*(cp++)),由于cp++的结果是指向ab，所以作为左值*cp++就表示ab所在的那个地址空间，而作为右值，它就是ab保存的值：4。 ++*cp,根据运算符优先级，它相当于(++(*cp))，我们确实先进行自增操作，但由于*cp是一个整体，所以先对其本身求值，也就是4，然后我们复制一份拷贝，将运算结束后的新值5保存进去。所以对于字符串的操作，如果使用*++string,会漏掉首字符，所以用*string++可以方便对字符串进行遍历。 (*cp)++，如果不通过括号，我们要表达的就是*cp++，也就是*(cp++)，在这里我们就是先对cp进行间接引用取得ab保存的值，然后进行后置自增运算。 ++*++cp，根据操作符优先级，它的意思就是(++(*(++cp))),由于(*++cp)，我们知道作为右值是对ab的下一块空间的位置的间接引用，再对那个保存的未知值进行前置自增运算，但作为左值它是不合法的，因为自增后新值保存的那块空间位置不明确。 ++*cp++,根据前面的经验，我们可以知道它相当于((++(*(cp++)))),而*cp++作为右值相当于指向ab，进行间接访问的值为4,对其进行前置递增运算，并将拷贝计算的新值保存到一个新的位置，因为那个位置不明确，所以不能作为一个合法的左值。 通过上面的分析，我们发现，优先级上最后进行自增(自减)运算的不能作为一个左值使用，而取址操作符&amp;也一样，因为它们产生的新的值(不是地址值)会被保存到一个新的未知空间，所以不能作为左值使用。我们也发现”指针 +/- 整数”,只能作为右值，实质就是对里面保存的地址值的运算 #define、typedef和指针C语言里，typedef是一个很不错的机制，他可以给数据类型定义新的名字，和使用#define重定义常量的用法很像，但要注意的是，#define没办法很好的处理指针类型，例如12#define char_pointer char*char_point a,b; 那么其中的b就不能被正确的声明为一个指向字符的指针类型，而用typedef就不一样了，例如：123char *char_pointer; //声明一个指向字符的指针类型typedef char *char_pointer; //把char_pointer作为指向字符的指针的新名字char_pointer a; //声明a是一个指向字符的指针 就可以很好的用来处理指针类型。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看得见的与看不见的]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E4%B8%8E%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论摄影与摄像]]></title>
    <url>%2F2018%2F05%2F29%2F%E8%AE%BA%E6%91%84%E5%BD%B1%E4%B8%8E%E6%91%84%E5%83%8F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2F2018%2F05%2F19%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ls命令用来显示目标列表或者目录内容，常用的可选参数有： -a 显示所有子目录和文件，包括隐藏文件 -l 显示文件的详细信息，可以把ls -l简写为ll cp/mv命令用来把一个文件或者多个文件复制/移动到目标目录 rm命令刪除一个目录中的一个或多个文件或目录，其中需要注意的参数有： -f 不需要确认删除多个文件，强制删除 -r 将文件的全部目录和子目录都删除 cat命令可以显示文件内容，也可以连接两个或者多个文件 which命令显示文件的所在路径 man命令用于查看Linux中的命令帮助信息，遇到不会的命令就man一下，它也有一些参数需要注意： -a 在所有的man帮助手册中搜索； -f 等价于whatis指令，显示给定关键字的简短描述信息； ps命令ps命令列出执行这个命令时刻时的那些进程，类似一个当前进程的快照，是最基本也是最强大的进程查看命令，需要注意的参数有： a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 -au 显示较为详细的信息 tar命令很常用的压缩&amp;&amp;解压命令了，但tar这个命令….参数是真的多，看到一种不错的记忆方法，只要记得参数是【必选+自选+f】即可，首先是必选参数，五选一： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 然后是自选参数，必选的话只能选一个，而可以根据需要挑着选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 最后一个参数一定要是f，后面再跟上你要压缩或者解压的文件包名。 一般我们常用的解压方式就是： *.tar -&gt; tar -xf *.tar.gz -&gt; tar -xzf *.tar.bz2 -&gt; tar -xjf *.tar.Z -&gt; tar -xZf *.gz -&gt; gzip -d *.rar -&gt; `unrar e *.zip -&gt; unzip kill命令用于终止指定进程的运行，对于后台进程我们可以先通过ps/pidof/pstree/top等命令获取进程PID，然后用kill结束该进程。不过也可以使用killall命令，直接使用进程的名称结束进程，使用它可以结束一组同名进程，而不用先获取进程PID，killall相当于把这两个过程合二为一，是一个很好用的命令 head命令可以用来查看一个文件的前几行，可以配合其他命令使用，例如配合管道做grep tail命令tail命令和head相反，查看文件的最后几行。不过最常用的还是加上 “-f” 参数后和grep一起使用 grep命令一个极其强大的命令，常用来在很多数据中找到匹配某一模式的字段，可以是正则表达式，常用的几个参数有： -a 以文本文件方式搜索 -c 计算找到的符合行的次数 -i 忽略大小写 -n 顺便输出行号 -v 反向选择，查找没有搜索字符串的行 du命令du命令是对文件和目录磁盘使用空间的查看 top命令用于动态的显示进程的信息，不过也有可以自定义的形式，例如:top -u root可以用来查看某用户进程 find命令查找所需文件的命令，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，常用的参数有： -type 只寻找符合指定的文件类型的文件,其后跟随指定文件类型参数，类型参数有 f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p FIFO -name 根据文件名查找 -size 根据文件的权限或者大小名字类型进行查找 -mtime 查找在指定时间曾被更改过的文件或目录，单位以24小时计算； -print 假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出 -exec 假设find指令的回传值为True，就执行其后跟着的指令 cmp命令用来比较两个文件的差异。如果两个文件完全一样，就不会显示任何信息。如果发现有差异，会标示出第一个不同之处的字符和列数编号。 touch命令修改文件的创建日期，或者以当前的系统日期创建一个空文件 date命令显示当前日期和时间的，可以通过一些参数进行日期的格式化： %Y year %m month (01~12) %d day of month %H hour (00~23) %I hour (01~12) %M minute (00~59) %S second (00~60)例如：1234date + &quot;%Y%m%d %H%M%S&quot;20180519 223856date + &quot;%Y-%m-%d %H:%M:%S&quot;2018-05-19 22:39:07 wc命令统计指定文件中的字节数、字数、行数，并将统计结果输出，需要了解的参数有： -c 统计字节数 -l 统计行数 -m 统计字符数，不能与-c参数一起使用 -w 统计字数 env/export命令env: 查看当前环境变量 类似于配置Python环境，在一台不熟悉的机器上，如果出现了配置问题，可以通过env命令查看shell下的所有环境配置，看一下路径是否正确。 export: 设置或显示环境变量 useradd命令useradd命令用于创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。其中有几个需要注意的参数： -e 指定帐号的有效期限 -g 指定用户所属的群组 -G 指定用户所属的附加群组 -r 建立系统帐号 -u 指定用户id，设定ID值时尽量要大于500，以免冲突 groupadd命令用于创建一个新的工作组，也可以用groupdel命令删除工作组，常用的参数有： -g 指定新建工作组的id -r 创建系统工作组，系统工作组的组ID小于500 curl/wget命令curl命令是一个利用URL规则在命令行下工作的文件传输工具,而wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。 netstat命令用来显示网络系统的状态信息，可让你了解整个系统的网络情况，需要注意的参数有： -a 显示所有连线中的Socket -n 直接使用ip地址，而不通过域名服务器 -t 显示TCP传输协议的连线状况 -u 显示UDP传输协议的连线状况 -l 显示监控中的服务器的Socket -s 显示网络工作信息统计表 -n 直接使用ip地址，而不通过域名服务器 可以通过参数的组合实现不同的功能，例如1234567netstat -at #列出所有tcp端口netstat -au #列出所有udp端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -st #显示TCP端口的统计信息netstat -su #显示UDP端口的统计信息netstat -an | grep &apos;:80&apos; #找出运行在指定端口的进程]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匠人的情怀]]></title>
    <url>%2F2018%2F05%2F11%2F%E5%8C%A0%E4%BA%BA%E7%9A%84%E6%83%85%E6%80%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google实用搜索技巧]]></title>
    <url>%2F2018%2F04%2F20%2FGoogle%E5%AE%9E%E7%94%A8%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[善用搜索引擎的都是信息时代的富翁，不懂搜索引擎的都是信息时代的负翁。 完整匹配在Google的搜索框里，所有的空格都会被视为”+”号，可能对于用惯了百度的人很好理解，因为我们要搜啥时，肯定是搜索关键词，加了空格就相当于多个并列的关键词，那搜索结果就会把所有包含相关关键词的内容都全部罗列出来。 对于搜索一个具体的问题，例如一句描述问题的话，在中文里基本是没空格的，但我们使用Google时更多是用的英文，当我们搜索英文关键词是没问题的，但当你使用英文描述一个具体问题时，就需要在搜索字段的前后加上引号，无论是全角字符（ “ 或者 ” ）还是半角字符（ “ ），Google都能正确处理，这就是完整匹配。 筛选过滤为了进一步筛选搜索结果，我们可以使用” - “操作符，如&quot;mysql connect error&quot; - &quot;nodejs&quot;就要求Google返回含有mysql connect error但不包括nodejs的文章。当然，中文搜索也是适用的。 也可以使用”+”操作符，因为Google会忽略和过滤一些常用的英文词汇，例如and，how之类的，使用”+”操作符可以让搜索引擎强制包括它们，也可以强制过滤掉关键词的一些特定时态形式。 通配符其实就是我们熟知的符号”“，举个例子，当我们搜索`”mysql connect error “`Google就会返回所有已知的关于MySQL连接错误的文章。 其他操作符我们熟知常用的一些操作符，可以在Google里使用，辅助完成一些特定搜索，例如： ~ 关键词前加上它，可以显示同义词 | 作用和OR一样 .. 用来限定数值的范围，例如2015..2018 站内搜索可以根据特定的网站，搜索对应网站内所有相关内容，例如：&quot;mysql connect error&quot; site:stackoverflow.com就会返回Stackoverflow内所有关于MySQL连接错误的文章。 搜索指定文件格式我们可以搜索特定的文件格式，不过一些文件类型是不支持的，但日常用来搜索一些PDF资源或者搜索特定图片格式是很方便的，只需要加上filetype: + 特定格式，就可以了。不过对于图片搜索，我们还可以限定搜索的图片尺寸，加上imagesize:，例如：imagesize:500x500 搜索相似网页通过related:这个关键字搜索到相关相仿的网页或相关页面，例如：related:www.taobao.com 关闭安全搜索最直接简便的方法就是在搜索网址时附加一个参数：&amp;safe=off]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪辑的艺术]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%89%AA%E8%BE%91%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于碎片化阅读的思考]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%85%B3%E4%BA%8E%E7%A2%8E%E7%89%87%E5%8C%96%E9%98%85%E8%AF%BB%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小记]]></title>
    <url>%2F2018%2F03%2F16%2FGit%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常用命令设置和配置 git config12345678git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on git 创建和获取项目 git init初始化本地git仓库（创建新仓库） git cloneclone远程仓库 快照 git add应该理解为“添加内容到下一次提交中更合适” 12git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至index git commit 123git commit -m &apos;xxx&apos; # 提交并键入提交信息git commit --amend -m &apos;xxx&apos; # 重新尝试提交，合并上一次的提交，用于反复修改git commit -am &apos;xxx&apos; # 将add和commit合为一步 git diffgit diff本身并不会显示出自上一次提交以来所有的变更，而只会显示出还没有进入暂存区的那些变更，如果所有变更已经进入暂存区，git diff不会有任何输出。 1234567git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff --staged # 将暂存的变更与上一次提交相比较git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git rm 12git rm xxx # 删除index中的文件git rm -r * # 递归删除 git mv 1git mv README README2 # 重命名文件README为README2 git status用来查看当前文件状态，查看是否进行了修改 1git status -s # 更为紧凑的形式查看变更 分支与合并 git log 123456git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log --stat # 查看每个提交的简要统计信息git log -p -2 # 显示出最近两次提交所引入的差异git log v1.0 # 显示v1.0的日志git log --pretty=format:&apos;%h %s&apos; --graph # 更改日志输出默认格式，其结果不会随着Git软件版本更新而改变 git tag 12git tag # 显示已存在的taggit tag -a v1.0 -m &apos;xxx&apos; # 增加v1.0的tag git branch列出你所拥有的分支、创建的新分支、删除分支以及重命名分支 123456789git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git checkout切换分支并将内容检出到工作目录 1234567git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v1.0 # 检出版本v1.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退） git merge用于将一个或多个分支合并，然后将合并的分支作为当前分支 1git merge origin/master # 合并远程master分支至当前分支 git stash 123git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存 项目共享和更新 git remote用来查看已经设置了哪些远程仓库，然后列出每个远程仓库的简短名称，也可以用来管理远程仓库记录，将一段很冗杂的URL地址保存成一个简单的字符串句柄，比如origin，方便操作 1git remote add &lt;name&gt; &lt;url&gt; # 增加远程定义（用于push/pull/fetch） git push与其他仓库通信，确定本地内容和远程仓库异同，然后将差异推送到其他仓库 123git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有服务器上还没有的标记都推送过去 git fetch 123git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git fetch origin # 与服务器同步 git pull可以理解为git fetch和git merge的组合，先从远程仓库获取内容，再尝试合并进你所在分支 1git pull origin master # 获取远程分支master并merge到当前分支 git reset 1git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） 检视和比较 git show能够以简单易读的形式显示Git对象，通常用来显示标签或提交的相关信息 12345678git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git show v1.0 # 显示v1.0的日志及详细内容git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git show HEAD~3git show -s --pretty=raw 2be7fcb476 git ls-files 1git ls-files # 列出git index包含的文件 git show-branch 12git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史 调试 git grep可以帮助你在源代码的所有文件中找到任意字符串12git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e &apos;#define&apos; --and -e SORT_DIRENT 打补丁 git cherry-pick 1git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git rebase基本上就是一个自动化的git cherry-pick命令，它确定一系列提交，然后在别处以相同的顺序逐个对其挑拣。不要对已经存在于本地仓库之外的提交执行rebase操作。 git revert与git cherry-pick命令的效果恰好相反，将变更撤销或还原 1git revert dfb02e6e4f2f7b # 撤销提交dfb02e6e4f2f7b 管理 git reflog显示所有提交，包括孤立节点 git gc执行”垃圾回收“，删除无用文件，将余下的文件打包成一种更有效的形式 git fsck用于检查内部数据库存在的问题或不一致性 Git使用规范流程 在团队开发中，遵循一个合理、清晰的规范是很重要的，例如Git,如果每个人都很随意的提交一堆commit，项目很快就会变得难以维护和管理了，所以需要规范化这个流程。 一、新建分支每次开发一个新的功能，我们都应该新建一个单独的分支123456# 获取最新代码git checkout mastergit pull# 新建一个开发分支git checkout mybranch 二、提交分支分支修改后，就可以提交了123git add .git statusgit commit 三、撰写提交信息提交commit时，必须要简洁明了的叙述提交的信息，可以参考这个例子：123456简要的变更汇总，然后空一行（不超过50个字符），如果有必要，就要附加更详细的说明，每行长度限制在72个字符左右。- 通常使用连字符或者星号作为条目符号- 改动原因- 主要变动- 需要注意的问题 四、与主分支同步开发的过程中要时常与主分支保持同步12git fetch origingit rebase origin/master 五、合并开发完成后，我们需要把一堆commit合并到主分支关于合并多个commit,可以看这篇文章：「Git」合并多个 Commit不过也有一种简洁的合并方式,就是先撤销过去5个commit，然后再建一个新的：1234git reset HEAD~5git add .git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;git push --force 六、推送远程仓库1git push --force origin myfeature 之所以要加上 force 参数，是因为 rebase 后，分支历史改变引起的远程分支不兼容问题 七、发出Pull Request提交完毕后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review ，确认是否可以合并到 master 分支。 Git工作流主流工作流 Git Flow GitHub Flow GitLab Flow Git FlowGit Flow 是最早诞生、并得到广泛采用的一种工作流程。 Git Flow 存在两个长期分支，分别是主分支 master 和开发分支 develop ，前者是对外发布的稳定版本，后者相当于测试开发版，用于日常开发使用。 Git Flow还有三个协助分支，分别是功能分支（分模块功能开发）、补丁分支（线上的紧急 bug 修复）、和预发分支（版本发布的预发布），分别对应不同的业务需求，一旦开发完成，它们会先合并进开发分支，再合并进主分支，或者直接并入主分支。 Git Flow的优点在于直观明了，易于控制，但需要维护两个长期分支，需要频繁切换，而且这个模式更多基于“版本发布”的，对于一些“持续发布”的项目，两个长期分支的区别就不大，没必要都维护。 GitHub FlowGitHub Flow 作为 Github 所使用的工作流，其目的也是专门为了配合“持续发布”的。它只有一个长期分支，就是我们所熟知的 master 分支，团队成员们的分支代码通过 Pull Request 来合并到 master 上。 我们通过从 mater 上拉出新的分支，当开发完成时，就发起一个Pull Request，然后会审核你的代码，如果被接受就可以合并进 master 分支。 不过由于它只有一个主分支，所以如果你的开发时间很长，主分支就会与你得分支版本不一致，而你不得不专门建一个分支跟踪线上的新版本。 GitLab FlowGitlab flow 吸取了 Git flow 与 Github flow 的优点。既有适应不同开发环境的弹性，又有单一主分支的简单和便利。 对于”持续发布”的项目，建议在 master 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 master ，”预发环境”的分支是 pre-production ，”生产环境”的分支是 production 。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。只有上游没有问题，才能发布到下游，除非是紧急情况，才能直接合并到下游分支。 对于”版本发布”的项目，都要从 master 分支拉出一个分支，比如1-3-stable、1-4-stable等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。 Git代码规范具体可以看一下这篇文章：Git Style Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非“你”不可]]></title>
    <url>%2F2018%2F02%2F16%2F%E9%9D%9E%E2%80%9C%E4%BD%A0%E2%80%9D%E4%B8%8D%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的字符串拼接技巧汇总]]></title>
    <url>%2F2018%2F01%2F24%2FPython%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Python里的字符串拼接方式有好几种，我们最熟知的可能是利用加号连接或是通过join函数连接，其实在Python里还存在了一些字符串拼接的方法，使用得当，可以有效提高我们的效率，这里作一个小的总结。 利用加号拼接入门模式，利用+字符连接字符串，实现字符串的拼接，实则是操作符的重载。如果是数据量不大的字符串拼接，推荐使用它。1234&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; a + b'hello, world!' 利用join()拼接字符串的内置方法里有一个join()，通过这个方法也可以实现字符串的拼接。但join的参数是数组或者元组之类的序列类型。如果要拼接大量字符串推荐使用它，而不是+。1234&gt;&gt;&gt; a = "*"&gt;&gt;&gt; b = ['a','b','c']&gt;&gt;&gt; a.join(b)'a*b*c' 直接拼接在Python中，连续的字符串会拼接为一个字符串12&gt;&gt;&gt; print("hello, " "world!")hello, world! 利用逗号拼接1234567&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; c = 4&gt;&gt;&gt; print(a,b)hello, world!&gt;&gt;&gt; print(a,c)hello, 4 逗号操作符可以把两个变量的值进行拼接，不过只能用于print打印里。 格式化字符串可以通过格式化字符串的方式，进行字符串的拼接，而格式化字符串可以通过%操作符，也可以通过format()函数。12&gt;&gt;&gt; print('%s %s' % ('hello, ', 'world!'))hello, world! format()方法可以非常方便地连接不同类型的变量或内容12&gt;&gt;&gt; "&#123;&#125; &#123;&#125;".format("hello, ", "world!")'hello, world!' Python3.6中引入了字面量格式化字符串，简称f-string，用法和%、format()类似,但它的可读性比使用+号更好，当我们要拼接大量数据内容，例如像key:value类型的字段时，推荐使用f-string,它的性能也更好。1234&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; f"&#123;a&#125; &#123;b&#125;"'hello, world!']]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“视界”]]></title>
    <url>%2F2018%2F01%2F12%2F%E2%80%9C%E8%A7%86%E7%95%8C%E2%80%9D%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F01%2F05%2FMarkdown%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[标题 如果你需要插入标题，可以在行首插入1到6个#，对应标题的1到6级,最高可以到六级标题，最好在#后加一个空格，例如:# 这是一级标题## 这是二级标题####### 这是六级标题 也可以使用=====表示高级标题，使用------表示次级标题，大于两个=,-都可以用来表示标题 引用如果你需要一个引用，那么你可以使用&gt;符号放在文字开头，例如:&gt;这是一个引用引用是可以嵌套的，同时引用的区块内部也可以使用其他的Markdown语法，例如 这是一个引用 这是一个嵌套引用 这是二级标题 列表项 列表项 列表如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种形式，列表本身也是可以嵌套，例如 列表项 列表项 列表项 嵌套列表 嵌套列表 无序列表可以使用*、+、-这三个符号中的任意一种作为列表标记，也可以和引用标记进行嵌套 列表项 列表项 列表项 这是一个嵌套的引用 可以进一步嵌套 字体 粗体: 通常用**或者__表示粗体 斜体: 通常用*或者_表示斜体 斜粗体：通常用***或者___表示斜粗体 链接如果你需要链接文字，可以使用[](link)表示一个链接，其中[]内是需要添加链接的文字，()内是链接的地址 代码 使用一对```表示代码块，可以根据你所使用的Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如： 123public static void main(String[] args) &#123; System.out.println("Hello"); &#125; 使用一对 可以表示一个行内代码，例如： 这是一个Java`代码 图片如果你需要插入一张图片，可以使用![Text](path)，其中Text表示图片无法加载时显示的文字，path为图片所在的路径，也可以是网上的图片链接地址 分割线如果你需要一条分割线，可以使用--- 或者***表示水平分割线，只要-,*大于三个就可以表示水平分割线，使用---作分割线时需要前后都空一行，防止被当成标题的标记方式 删除线如果你需要一条删除线,可以使用一对~~表示删除线，但切记和文字之间不能有空格 表格可以使用以下的格式添加表格,注意表格和文字间空一行：12345| name | age | gender | money ||-------|:---:|-----------|-------:|| rhio | 384 | robot | $3,000 || haroo | .3 | bird | $430 || jedi | ? | undefined | $0 | name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $0 其他如果 Markdwon 的语法达不到预期效果，或者一些地方的处理用 Markdwon 的格式无法实现，可以考虑用 HTML 和 CSS 引用 123&lt;blockquote&gt;***&lt;/blockquote&gt;/* 如果上下间距小，可以这样写 */&lt;p&gt;&lt;blockquote&gt;***&lt;/blockquote&gt;&lt;/p&gt; 居中和右对齐 123456/* 居中 */&lt;center&gt;**&lt;/center&gt;/* 右对齐 */&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;/* 右对齐 */&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt; 字体大小和颜色 1&lt;font color="#xxxxxx" size="number"&gt;**&lt;/font&gt; 分割线和空行 12&lt;hr /&gt;&lt;br /&gt; 关于Markdown的更多细节，可以参看：Markdown 语法说明 (简体中文版)，对于Markdown的规范，可以看一下 ：Google Markdown Style Guide 或者 Markdown Style Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python中__str__和__repr__的区别]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%85%B3%E4%BA%8EPython%E4%B8%AD-str-%E5%92%8C-repr-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[__repr__和__str__这两个方法都是用于显示的，但实际却存在一些细微的差异，具体我们可以通过一个简单例子来比较一下它们之间有何不同。 123456789101112class Hello(object): pass&gt;&gt;&gt; a = Hello()&gt;&gt;&gt; a&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(a)&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(str(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(repr(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt; 这里我们想要打印类对象，但显示的确是对象的内存地址，而且无论通过__repr__或是__str__,结果都一样，下面我们重写一下这个类的__repr__方法： 12345678910111213class Hello(object): def __repr__(object): return 'hello'&gt;&gt;&gt; b = Hello()&gt;&gt;&gt; bhello&gt;&gt;&gt; print(b)hello&gt;&gt;&gt; print(str(b))hello&gt;&gt;&gt; print(repr(b))hello 然后我们就会发现无论输出对象，还是调用__repr__和__str__方法，甚至通过print()方法，打印的信息都是按我们__repr__方法中定义的格式进行显示的。现在我们重写一下__str__： 12345678910111213class Hello(object): def __str__(object): return 'hello'&gt;&gt;&gt; c = Hello()&gt;&gt;&gt; c&lt;__main__.Hello object at 0x000001DE00450CC0&gt;&gt;&gt;&gt; print(c)hello&gt;&gt;&gt; print(str(c))hello&gt;&gt;&gt; print(repr(c))&lt;__main__.Hello object at 0x000001DE00450CC0&gt; 现在就很直观了，直接输出对象c时，显示出来的依旧是它的内存地址，而当我们调用print方法时，就会按我们定义的格式输出信息。因为我们覆盖了先前的__repr__方法，即使没有提前覆盖__repr__方法，我们得出的结果依然也是一样的。 总结一下，__repr__和__str__这两个方法都是用于显示的，但__str__更适用于用户，而__repr__更适用于开发人员 打印操作会首先尝试__str__和str内置函数（print运行的内部等价形式），它通常应该返回一个友好的显示 __repr__用于所有其他的环境中，例如交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str，它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使自己看起来更Pythonic]]></title>
    <url>%2F2017%2F12%2F21%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E8%87%AA%E5%B7%B1%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4Pythonic%2F</url>
    <content type="text"><![CDATA[Python这门语言语法很简洁，如果具备其他语言的基础，学习它会很快，但我们可能写出的代码不那么Pythonic，尽管它也能运行，但我们没办法充分发挥这门语言的特性，简化很多不必要的操作，以提高自己的效率。 关于for循环我们使用for循环其实出发点可能是为了遍历一个序列然后提取有用的信息，又或者单纯为了循环一个操作，在其他语言里，我们达到类似的目的确实只能通过循环完成，例如 Java：12345for(int i=0; i&lt;10; i++) &#123; if(i%2==0)&#123; System.out.println(i); &#125;&#125; 在Python里自然也可以写出类似的代码: 123for i in range(10): if i % 2 == 0: print(i) 如果代码逻辑更为复杂些，里面可能就要嵌套一堆if/else的判断，如果再加上try/catch代码块，那代码会变得很长，而且阅读性很差，那么Pythonic的写法是什么呢：1print([i for i in range(10) if i%2==0]) 通过列表推导式，一行代码就解决了，而且逻辑很清晰。 变量交换在其他语言实现变量交换很麻烦，往往要通过引入第三方变量作为桥梁进行变量交换，像这样123tmp = a;a = b;b = tmp; 虽然Python也可以用这样的方式，但这很不Pythonic，我们可以这样，一行代码即可，很方便。1a, b = b, a 字符串拼接关于Python里的字符串拼接，可以看一下这篇总结： Python中的字符串拼接技巧汇总 ，很多都是Python里才有的方式，可以让你的代码看起来更加Pythonic。 文件资源管理关于文件资源的打开和关闭传统的方式是这样的：12345f = open('*.txt')try: data = f.read()finally: f.close() Python提供了更为简便的操作，通过with关键字动态的打开关闭资源：12with open('*.txt') as f: data = f.read() 赋值Python自带了许多很方便的容器类型，例如：元组，列表和字典，当我们要把容器中的值取出来赋值给变量，可能我们会想到通过遍历这些容器类型，调用相关的方法取出值，然后赋值给变量，但那很不Pythonic，就拿元组来说，我们可以通过元组拆包的形式，使用很简短的代码，来为变量赋值。123456789101112&gt;&gt;&gt; result = (1, 3, 5, 7, 9)&gt;&gt;&gt; a,b,c,d,e = result&gt;&gt;&gt; a1&gt;&gt;&gt; b3&gt;&gt;&gt; c5&gt;&gt;&gt; d7&gt;&gt;&gt; e9 Python之禅如果你看过Python之禅，就会理解这门语言的设计哲学，而Python的代码风格也应该向这个目标靠近。 1234567891011121314151617181920212223242526272829303132333435363738394041&gt;&gt;&gt; import thisThe Zen of Python, by Tim Peters#优美胜过丑陋。Beautiful is better than ugly.#显示胜过隐式。Explicit is better than implicit.#简单胜过复杂。Simple is better than complex.#复杂胜过繁复。Complex is better than complicated.#串行胜过嵌套。Flat is better than nested.#稀疏胜过稠密。Sparse is better than dense.#可读性很重要。Readability counts.#虽然理想很丰满，现实很骨感，但是所谓特例并不足以打破上面的这些规则。Special cases aren&apos;t special enough to break the rules. Although practicality beats purity.#所有错误都不应该被直接忽略，除非能够被精确的捕获之后。Errors should never pass silently. Unless explicitly silenced.#当面对不明确的情况时，要拒绝去猜测的诱惑。应该有一种，最好是唯一一种，显而易见的解决方案。尽管起初，那种解决方案可能并不是那么显而易见，因为你不是Python之父——DutchIn the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch.#现在行动胜过永不开始。尽管，永不开始经常好过冲动的开始。Now is better than never. Although never is often better than right now.#如果你的实现难于向别人解释，这往往不是个好主意。如果你的实现很容易向别人解释，这可能是个好主意。If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea.#命名空间是一个令人激动的伟大想法，让我们将它发扬光大。Namespaces are one honking great idea -- let&apos;s do more of those! 这里推荐两本书，如果你Python已经入门，希望进阶，并想写出更为Pythonic的代码，提高开发效率，可以看下《流畅的Python》 、 《Python Cookbook》 关于Python的代码风格可以看一下： Python 风格指南]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表解析的效率问题]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在列表，字典，集合中根据条件筛选数据 列表 filter 1filter(lambda x:x &gt; 20,data) 列表解析 字典 字典解析1&#123;for k,v in d.interitems() if v &gt;= 20&#125; 集合 集合解析1&#123;x for x in s if x % 2 == 0&#125; 注意：列表解析也可能会被滥用，例如使用列表解析重复获取一个函数等。所以并非一味地使用列表解析式就是好的。 原则：尽量保持其简洁，列表解析的代码不要超过两行以上，只用它来创建新的列表，否则的话还是考虑使用for循环来重写。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>

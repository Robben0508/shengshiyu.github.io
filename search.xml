<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文化与媒介]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%96%87%E5%8C%96%E4%B8%8E%E5%AA%92%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[我们不光要学习国外先进企业的研发能力，更要学习他们的职业文化。 为什么文化显得重要，或许文化是一种非物质化的媒介，它本身就能很好的传递一些东西，达成企业到员工之间的一种沟通桥梁。 若有更好的方式能实现“文化”所具有的作用，那么文化的作用便会被弱化，但文化本身证明是一个比文字效率更好的媒介]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Spring Bean的生命周期和作用域]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP浅析]]></title>
    <url>%2F2018%2F12%2F26%2FTCP%E5%92%8CUDP%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[关于UDP你需要知道UDP继承了IP包的特性，不保证不丢失，不保证顺序到达，它只管发出去，打个比方，它就像懵懂无知的小孩，它认为只要是发出去的东西，很容易就能送达，不会丢包。而且它不会建立连接，它也不会进行拥塞控制，只管往外发就行，一根筋。 虽然UDP报文没有可靠性保证、顺序保证和拥塞控制，可靠性较差。但也正因为如此，UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，需要处理速度快，时延低，可以容忍少数丢包，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。 在网络质量很差的环境下，UDP协议数据包丢失会比较严重。但是由于它传输过程中资源消耗小，处理速度快，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包到达的消息及时反馈回来，那么网络就是通的。在默认状态下，一次“ping”操作发送4个数据包，对方主机发回的确认收到的数据包也是4包，这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。 UDP协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据包在传输过程中被篡改或者损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测出是否出错。 关于TCP你需要知道TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来，也因为多了这样一个过程，TCP要比UDP复杂很多，可以看一下TCP头的格式。 TCP的包是没有IP地址的，那是IP层上的事。可以对比看出，相对于UDP来说，TCP多了一个序号，这个序号的作用是为了给发送的包标号，防止乱序，这样我们好知道哪一个应该先来，哪一个后来，做到有理有序。 其次，它还具有一个滑动窗口，我们可以理解为这就是一个管道的大小，越大自然水的流速流量可以更大，越小自然流速就会变小，流量变少，TCP也一样，窗口的大小就是为了能够控制流量的，通过标识窗口大小，就可以知道对方的处理能力，而不会发送过快了，造成拥塞问题，用于解决流控的。 TCP 三次握手TCP连接的建立，我们通常称为“三次握手”，打个比方，大概就是这样：A：你好，我是A，想和你连接B：你好A，我是B，我收到你提出的连接请求了A：好的B，收到了 为啥一定要是三次呢？不是两次或者四次，当A发起一个连接是，如果B没有回复，它又如何知道B收到了呢，它会以为包丢了，或者超时未达，又或者B压根不想和它连接，它会很懵逼，以至于可能再发。 当B收到了请求包，就知道了A的存在，也知道A想和它连接，而且它要是不回复，A会继续重试“骚扰”它一阵子，直到A自己放弃，建立连接失败。如果B愿意连接，OK，立马发个应答包过去，告诉A，我同意和你连接了。 但是，这个过程一样会遇到种种未知错误，比如这个应答包丢了。。。那A不知道啊，继续“骚扰”。。。所以B为了不受其烦，肯定要为了确保应答到达，不断尝试重发，只要一次到达，它就解脱了。至于怎么确认到达，当然是等A收到了应答包，然后欢呼雀跃的再发送一个应答包，表示”收到了，我们连接吧！“不过你可能会觉得，那我们也要确定A这个应答包到达B啊，不然B咋知道A收到他第二次握手发的包，难道不应该四次握手吗？其实四次握手也是可以的，几十上百次都OK，但那也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了。 A当然可以建立连接后空闲着，就是不“搭理”B，对于B来说，对于A这种“占着茅坑不拉屎”的行为，自然可以选择主动关闭，从而把空出的资源给其他客户端使用。 TCP里的序号在“三次握手”中，可以很有效的解决丢包问题，当它俩连接后，A发送了很多个有序排列的包，但中途可能由于种种未知原因，丢了一个，A不知道，但B知道A发的包的总数，它一数，好像差了一个，然后再告诉A。而且这个序号的起始序号是随时间变化的，不会重复，为了防止某些包绕路，等到了其实已经无用了，所以IP包头里有个TTL，也就是生存时间。 这里有个时序图，可以看一下，而且TCP头里还有一些状态位，其中SYN表示发起一个连接，ACK表示回复，RST表示重新连接，FIN表示结束连接，这样这个时序图就好理解了。 TCP 四次挥手嗯，说散就散，说完了连接，该说下“四次挥手”了，它大概是这样的：A：我们分手吧B: 哦，你想分了啊，那好吧，知道了。。。 这个时候，只是A想分手离开了，也就是A不再发送数据，那B能不能在ACK的时候直接选择关闭呢，反正A都要分了，自然是不行的，因为A可能是发完了最后的数据就准备分手了，但是B还没做完它的事情，还是可以发送数据的，处在一种半关闭状态，这个时候A可以选择不再接受数据，也可以选择最后再接受一段数据，等待B也主动关闭。于是就有了：B： OK，那我不陪你了，再见A： 嗯，再见 然后整个连接就关闭了，但是上面是一种理想情况下的分手，可能会遇到很多异常情况，例如，A说完分手后，直接走了，B不知道，B发的回复A就收不到了，B会陷入不知所措。也有可能是B说完分手后，他倒是处于半关闭的还在着，B直接生气走了，A也会陷入两难抉择，究竟B是还有事没处理完，还是一会就关闭了，针对这一系列问题，我们来看断开连接时候的时序图。 从图中我们可以看到，当A说分手了，就进入FIN_WAIT_1的状态，可以理解为等待结束第一阶段，而B回复完A后也相应进入CLOSE_WAIT状态，理解为等待关闭。A收到B的回复，就进入了FIN_WAIT_2状态，如果此时B直接离开了，那A就一直保持在这个状态。如果B没有离开，主动地又说“再见”，然后它就进入了LSAT_ASK状态，然后A收到了B说得“再见”他也发送响应，“嗯，再见”然后进入了TIME_WAIT状态，当B收到A的ASK就会关闭了。而假如这个ASK没有到达，因为只有到达B才会进入关闭，但A已经进入关闭倒计时了，它会保持在这个状态一段时间，然后自动的关闭了，所以这段时间里，B会不断地发送“再见”，直到收到一条A的ASK为止。 假如B在A的最后这段“停留期”，还是没有等来一个回复，虽然它还是会发，当A收到这个后，就会直接回复一个RST，B就知道A跑了，就不再发“再见”了。 TCP 状态机其实就是将TCP连接和分手的两个时序图结合起来，就是表面看起来高大上的TCP状态机了。网络上的传输是没有连接的，包括TCP也是一样的，所谓的连接不过是通讯的双方维护的一个“连接状态”]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈大众传媒]]></title>
    <url>%2F2018%2F12%2F13%2F%E8%B0%88%E8%B0%88%E5%A4%A7%E4%BC%97%E4%BC%A0%E5%AA%92%2F</url>
    <content type="text"><![CDATA[互联网时代，与其说是流量的争夺战，不如说是注意力的争夺战。传统的纸媒时代早期，纽约《太阳报》的创立开启了广告赚钱吸引眼球的新模式。在那之前，广告仅仅作为新闻的一种信息补充，《太阳报》专门把传统公告栏的那些小的信息变成了高大上的广告，因为之前是没有真正意义上的广告业的。商家并不知道这样的模式，当这样的新模式诞生后，商家因此尝到了甜头，很乐意出钱给传统纸媒作宣传，而这也成为了那个时期纸媒的一个重要的收入来源。 同时《太阳报》里也更注重受众的需求，它们刊登的新闻讯息都是平民百姓很感兴趣的内容，例如自杀新闻和家庭风波，成功吸引了它们的注意力，然后也间接促成了广告事业的成功。这一点和如今的一些新媒体行业有很多相似之处，用内容去吸引用户，用流量的增长推动广告的成功，不仅仅是免费，甚至还会返利，只要你使用这个产品的时间越多，滞留的时间越长，就可以获得收益，可以在积累到了一定的限额提现。 “科学”的推荐算法，使得推送的内容满足了绝大部分用户“个性化”的需求，但也因此使你所收到的信息更多在你了解和感兴趣的范畴内。就像在搜索引擎中搜索一样，你不会知道那些你不知道的东西，所以你最终所了解的东西更多还是停留在了那个层面。 这是一个碎片化阅读盛行的时代，如何有效的吸引用户的注意力成为了重中之重，而一些深度阅读，思想深刻的长篇大论，反倒不那么受人待见，除非它是一个“爆款”文章，潜意识的让人觉得读完后会受益匪浅，那么对于广大的普通受众来说，他才会考虑耐心去细细品读，当然这也和本身文章内容质量很高有关，它确实吸引人，观点新颖，但很多类似的好文章可能只有石沉大海的宿命。就像微信公众号里的文章，判断文章质量的评判标准更多会从是否是“十万+”出发，似乎这已经成为了“优秀”的一种标志。而一些观点深邃，逻辑更为严谨复杂的好文章，它对受众形成了一定的阅读门槛，可能它就失去了成为“十万+”的可能。 曾几何时《太阳报》的成功，推动了其他竞争对手的进步，但随着竞争的愈演愈烈，各家报纸都开始提供更low的新闻以博取大众眼球，艳俗新闻以及暴力死亡事件中对血腥场景的过度描述。再到后面一些纸媒开始报道假新闻，最终引起了绝大部分人的反感。甚至为了获取利益刊登一些虚假广告，对广告主的背景不作具体的了解，刊登广告的门槛越来越低，引起了诸多社会问题。最终没过几年，这样的乱象就消亡了。 这种形式和如今的一些互联网传媒行业是如此相似，只不过是从线下搬到了线上，而且由于技术不断的发展，基于新技术的新形式和新体验也成为了吸引用户注意力的重要手段之一。如今，每天都在产生着巨量的信息，过去所要担心的取材难题在当今时代基本不会成为重要的制约障碍。因为我们可取的素材遍地都是，更需要关注的是搜集后的整理和结合。因为如今每一个人都可以算是一个自媒体平台，能人辈出，即使单纯的模仿，对于一些人来说也会由于先入为主认为这是原创，从而有了成为“爆款”的可能，从而获得成为网红的机会。 其实在模式上，相比于曾经传统的纸媒行业，如今，媒体本身是可以不生产内容的，它们更多提供的是一个平台，每一个使用这个平台的自媒体人都够为它们创造流量。对于这些人来说，他们吸引了一大波粉丝的同时，也能从中为自己获取收益。因为某些时候，商家费劲花重金做的一个广告，产生的效益甚至不如请一个流量大V来做一次短视频宣传的价值。 网红就如同时代的浪潮，随着时间，一浪高过一浪，不断有新的原创模式竞相出现。就个人而言，受制于自身知识的和技能水平，也难免会有创造力枯竭的时候，因为用户的注意力来的快去的快。而对于企业而言，关注的更多可能就是哪些新的技术手段，运营模式能便于用户生产出质量更高的内容，能最大化的吸引用户的注意力。 由于平台本身对于内容质量把控是有限度的，如果把控质量要求过高势必会造成内容量大幅度减少，难以吸引更多用户，太低又会产生诸如假新闻等的一系列问题。用户本身就偏向追逐一些“快餐式”阅读体验，简单轻松，不会需要很高的阅读门槛，也喜欢“鸡汤”，产生心理上的及时反馈，毕竟看似无害的东西谁又知道它真的就有用呢？类似《太阳报》时代不同纸媒曾经用过的手段，如今依然能看到它们的影子，成为了吸引用户注意力，保持较高平台流量的重要手段。大众传媒从来就不是高雅的产物，某种意义上而言，它也可以是低俗的。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新思想和旧思想]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%96%B0%E6%80%9D%E6%83%B3%E5%92%8C%E6%97%A7%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[新的“新思想”和旧的“新思想”，“新”不一定就代表了一种进步和对旧有事物的否定，旧的思想中可能蕴含着一些我们未充分认识的创新点，一旦机会成熟，旧有的思想就会成为一种潮流，至少在我看来，设计就是一个这样的过程，旧有的设计理念和一些“新思想”结合，却能成为一种潮流。 我们的认知观念里总认为旧有的东西就是落后的，就应该被淘汰的，因为有了继承于它的更好的方式，但那或许仅仅是继承原有的一个点，新旧本身并不应该作为衡量价值的标准。就像销量高的产品并不一定就代表质量好一样，人类总是倾向于接受和他们内心认知看法接近的事物，因为它们不必为此否定自身，就像我们的新闻一样，我们很难看到相悖的两种形式的新闻。 “主流”的思想将一些“异端”思想给排斥在外，但更多时候我们会发现，两种相悖的观点事实上它们都是正确的，不同的环境，不同的时代背景，不同的利用和转化方式，都可以作为我们评判一种思想是否具有价值的参考条件。 成长的过程，就是我们不断地发现过去家长、老师们教的某些东西开始具有了“片面性”，随着我们对其更深入全面的了解，随着我们阅历的加深，我们会衍生出自己的一套价值判断标准，但我们也会无意识地将与自身观点相悖的思想排斥在外，以维护我们自身观点的“正确性”，尤其是随着我们年龄的增长，我们更原意接受符合我们价值判断标准的事。 当我们摒弃了新旧思想之争，从全新的角度出发，去发现不同观点背后存在的可能性，勇于接受它们，判断哪一种更符合时代的发展的某种需要，哪一种更适合自身，去理解“变化”，避免使自己陷入思维的死角，找到在不同情境下最适宜的技巧。那么旧思想也可以成为”新的旧思想“，它也会有机会在如今的时代里绽放不一样的光芒。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PO、VO、BO、DTO、POJO、DAO之间的关系]]></title>
    <url>%2F2018%2F11%2F22%2FPO%E3%80%81VO%E3%80%81BO%E3%80%81DTO%E3%80%81POJO%E3%80%81DAO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[PO（persistant object持久对象）PO就是数据库中的一条记录，只是把一条记录作为一个对象处理，可以方便的转化为其他对象。有时也被称为Data对象，对应数据库中的entity。PO中不应该包含任何对数据库的操作。PO是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。PO有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。PO的属性是跟数据库表的字段一一对应的 VO（value object值对象/view object表现层对象)主要对应界面显示的数据对象,可以和表对应，也可以不，这根据业务的需要。VO是用new关键字创建，由GC回收。存活在业务层，是业务逻辑使用的，他存活的的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！不过，另外一点，如果我们没有使用数据持久层，那么PO和VO也可以是同一个东西，但这并不好。 BO(business object业务对象)主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。它只包含业务对象的属性或是方法，或者二者都包含。 DTO（Data Transfer Object数据传输对象）主要用于远程调用等需要大量传输对象的地方 POJO（plain ordinary java object 简单Java对象）一个最常见的的对象了，只有属性字段及setter和getter方法,属于一个中间对象，可以转化为PO、DTO、VO，一个POJO持久化之后就是PO；POJO在传输过程中，就会转化为DTP，这个传输过程就是DTO；POJO用作表示层就是VO DAO（data access object数据访问对象）学习数据库时遇到最多的对象了，它负责持久层的操作,主要用来封装对数据库的访问，提供数据库的CRUD操作.通过他可以把POJO持久化为PO，]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈产品需求分析]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%B0%88%E8%B0%88%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[创新扩散理论里提到的认知特征，相对优越性，它相对于其他产品是否更优越，体现在什么方面，本质上是不是加快了信息传播的速度；兼容性，它和生活的融合度如何，是否能够在生活中有应用的可能；复杂性，它是否操作简单，利于人们上手直接操作；可实验性，它是否具有试用的机会，而且实验过后能把握用户的痛点，让用户能喜欢上；可观察性，新技术的显示度如何，是否能引起广泛的社会讨论，这个可能需要运营来促进这一过程的推进，提高技术曝光度。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java线程池]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP指北]]></title>
    <url>%2F2018%2F10%2F24%2FHTTP%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[HTTP概述HTTP是应用层的协议，当我们打开一个网页时，例如：http://www.baidu.com,浏览器会将这个域名地址发送给DNS服务器，然后解析为具体的IP地址。 建立好连接后，浏览器就可以发送HTTP的请求了，而一个完整的HTTP请求报文由三部分组成：请求行、请求头（首部）、请求体（实体）。每一行的末尾都有回车和换行，在请求体和请求头之间另起一行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是以key:value这样的键值对的形式存在的，请求体就是要传输的数据。 HTTP里有很多请求方法，其中最常用的就那么几个，对于访问网页来说，使用的最多的就是GET方法，用来向服务器端获取一些资源，具体返回什么，由服务端来决定。 另一个常用的请求方法类型是POST，它需要你主动告诉服务端一些信息，一般这些信息放在请求体里，与GET不同，POST更多是用来更新资源信息，GET提交请求的数据实体是放在URL后面，用?来分割，参数用&amp;连接，而且数据长度是有限制的，视具体的客户端而定，而POST没有限制，而且GET提交的数据是不安全的，因为相关参数会暴露在URL上。 还有一种类型，叫做PUT，它的作用是向指定资源位置上传最新内容，类似于FTP协议，文件内容包含在请求体里，不过HTTP服务器一般是不允许上传文件的，所以PUT和POST就都变成了要传给服务器内容的方法。 最后一种比较常见的方法就是DELETE，主要就是用来删除文件，是与PUT相反的方法，DELETE是要求返回URL指定的资源。 请求行的下面就是请求头了，保存了一些很重要的字段，例如, Content-Type 是指正文格式，如果是JSON格式的，就要把值设为JSON，而类似 Accept-Charset 则表示客户端可以接受的字符集，避免不必要的乱码。首部字段有很多，其实通过名字我们就能大概它的用法的，用到的时候可以想了解细节再去查。 当我们使用HTTP发送请求时，由于它是基于TCP协议，所以它使用面向连接的方式发送请求，在发送每段报文时，都需要对方回应一个ACK，确认已经到达，如果没有收到对方的回复，TCP就会重新进行传输，直到到达为止，而这个过程是TCP负责的，也就是说无论重新传输了几次，对于HTTP来说它只进行了一次传输，由TCP来完成这个送达的过程。 TCP每发送一个报文都会加上自己本身所在的地址以及它想要到达的另一端的位置，将它们放在IP头里，然后交给IP层进行传输。IP层会查看目标地址和自己所在的地址是否同在一个局域网里，如果在的话就发送ARP协议，获取目标地址的MAC地址，然后把自己的MAC地址和目标MAC地址放到MAC头发送出去，由另一端来进行层层对比确认，然后发送一个ACK，确认到达。如果不在一个局域网里，就要经过网关，而MAC头里放的就是网关的地址，因为我们不知道目标的MAC地址，网关再根据路由协议来获取下一跳的路由器MAC地址，然后加入到目标MAC地址那，由于还不是真正的目标MAC地址，会不断重复这个“寻找”的过程，直到下一跳是目标所在，然后获取到目标的MAC地址。 在TCP头里还有端口号，通过确认MAC地址，IP地址后，通过端口号，目标机器就会知道哪一个进程需要这个包，然后发送给那个进程，例如HTTP服务器，然后HTTP服务器就知道请求的资源是什么，然后把相关资源发送给客户端。 HTTP的返回报文和响应报文类似，简单来说响应报文由状态行、响应头（首部）、响应体（实体）组成，其中第一行是状态行，包含HTTP版本，状态码和状态短语，在一个回车换行之后是响应头，也是以键值对的形式，之后是响应体，也就是要传输的数据。 HTTP协议的特点 HTTP协议是无状态的什么是无状态，就是协议对于事务处理没有记忆能力，对于同一个URL请求没有上下文的联系，每一次的请求都是独立的，不会受前后结果的差异影响响应，但为了使它具有状态的特点，于是引入了 cookis 和 session 机制。 基于TCP协议HTTP协议属于应用层，它的目的是规定客户端和服务端数据传输的格式和数据交互行为，而数据传输的实现，它是基于传输层TCP协议实现的，它本身并不能进行数据传输。 HTTP的响应状态码状态码是用来告知客户端服务器端处理请求的结果。凭借状态码用户可以知道服务器是请求处理成功、失败或者是被转发；这样出现了错误也好定位。状态码是由3位数字加原因短语组成。3位数字中的第一位是用来指定状态的类别。共有五个类别。不过常用的也就16种，下面来详细介绍下： 1. 200：OK代表请求被正常的处理成功 2. 204：No Content请求处理成功，但是没有数据实体返回，也不允许有实体返回。比如说HEAD请求，可能就会返回204 No Content，因为HEAD就是只获取头信息。 3. 206：Partial Content这是客户端使用Content-Range指定了需要的实体数据的范围，然后服务端处理请求成功之后返回用户需要的这一部分数据而不是全部，执行的请求就是GET。返回码就是206：Partial Content。 4. 301： Moved Permanently代表永久性定向。该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL。也就是说如果已经把资源对应的URL保存为书签了，这是应该按照Location首部字段提示的URL重新保存。 5. 302：Found代表临时重定向。该状态码表示请求的资源已经被分配了新的URL，但是和301的区别是302代表的不是永久性的移动，只是临时的。就是说这个URL还可能会发生改变。如果保存成书签了也不会更新。 6. 303：See Other和302的区别是303明确规定客户端应当使用GET方法。 7. 304：Not Modified该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但是没有满足条件。304状态码返回时不包含任何数据实体。304虽然被划分在3XX中但是和重定向没有关系。 8. 307：Temporary Redirect临时重定向，与302 Found相同，但是302会把POST改成GET，而307就不会。 9. 400：Bad Request表示请求报文中存在语法错误。需要修改后再次发送。 10. 401：Unauthorized表示发送的请求需要有通过HTTP认证的认证信息。 11. 403：Forbidden表明请求访问的资源被拒绝了。没有获得服务器的访问权限，IP被禁止等。 12. 404：Not Found表明请求的资源在服务器上找不到。当然也可以在服务器拒绝请求且不想说明理由时使用。 13. 408：Request Timeout表示客户端请求超时，就是在客户端和服务器建立连接后服务器在一定时间内没有收到客户端的请求。 14. 500：Internal Server Error表明服务器端在执行请求时发生了错误，很有可能是服务端程序的Bug或者临时故障。 15. 503：Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After字段再返回给客户端。 16. 504：Getaway Timeout网关超时，是代理服务器等待应用服务器响应时的超时，和408 Request Timeout的却别就是504是服务器的原因而不是客户端的原因。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC与需求变化]]></title>
    <url>%2F2018%2F10%2F21%2FIOC%E4%B8%8E%E9%9C%80%E6%B1%82%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[需求变化是程序员需要面对的一个难题，尤其在需求频繁变更的情况下，这意味着我们可能又要加班加点忙活一阵了，不断地完成旧需求，又不断地解决新需求，凭借我们的直觉，实现需求即可，只要把要求的需求一个个按时完成上线就万事大吉，没有更多考虑到未来可能产生的需求变化。“僵硬”的构建过程所带来的就是日后依然需要投入很多时间处理需求变化，而非一个灵活的设计，可以不被需求牵着鼻子走，直接自己掌握多样化的需求。可以有效减少本没有必要出现的加班乱象。 控制反转（IOC）作为面向对象编程的一种设计思想，意味着在Java中，我们将设计好的对象交给容器来控制，而不是传统的操控对象本身，由对象内部再来作控制。具体来说，传统的程序设计是主动地创建一个具体对象，再将它们组合起来，其中一个类可能依赖于另一个类，所以我们需要由我们创建的对象去主动地获取依赖的对象。 控制反转思想则由容器来为我们完成查找相关依赖对象，再将它们注入进来的工作，然后我们就能获得我们需要的具体对象，因为我们只能被动接受依赖对象的注入，不再像传统过程一样，由我们自己创建自己去获取，这个过程被反转了，由容器来控制。通过依赖注入可以有效实现解耦，但IOC并不仅仅作用于此。 控制反转，是一种重要的设计思想，其实也比较好理解，我们买电脑时，可能对于外行人来说，什么处理器型号，显卡型号，内存大小啥的，他们可能听过，但对具体区别不是特别了解，如果再具体细分处理器是标压还是低压，超频多少，风扇转速之类的，他们会晕了的。他们只知道他们想要的是一台可以玩大型游戏，剪辑视频的电脑，又或者是一台轻薄便携续航长可以流畅办工上网的电脑。 我们不用专门给他们介绍具体硬件上参数型号的差异，因为他们认知里，电脑就是电脑，能实现这个需求的就可以称为“电脑”，就像能打电话聊天的便携设备就可以叫“手机”，我们不用去知道实现的具体标准是啥，它需要哪些硬件，啥处理器、显卡、内存之类的，这个标准早就由产业本身制定规划好了，用户的需求要在这个标准下才能满足，而非漫无目的根据用户的需求，实现了一堆充斥不知名硬件设备形似电脑的东西，虽然它也实现了我们对电脑的定义需要的种种需求，但这样也使得我们要疲于应对各式需求，想办法做出符合需求的东西。 有了一个标准，一个有效的设计模式，可以大大节省我们不必要的人力投入，用户需求将成为设计的约束条件和验证手段，而不是出发点和目标。这样可以避免需求的变化让我们疲于奔命的工作状态。毕竟，谁又喜欢经常性不必要的加班呢？]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声望的陷阱]]></title>
    <url>%2F2018%2F10%2F11%2F%E5%A3%B0%E6%9C%9B%E7%9A%84%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[命运是解不开的谜团，声望是没有实际意义的云烟。 什么是声望？一个官方的解释是：声望是众所仰望的名声。人生在世，我们总有为声望所累的时候，但我的阅历尚浅，对于“声望”不好妄作评判，仅仅只能按我的理解，谈谈在当前时代下的“声望”的影响。 个人具有声望，组织和团体也具有声望，声望是一种看不见的影响力，它不好量化，但它却能无形中影响很多东西，就像我们玩的游戏，会有所谓的声望值，当你具备不同声望值时，就有权限获得一些稀有物品一样。 但游戏终究和现实不同，现实世界充满着许许多多的不确定性。可能具有很高声望的人或事物，会对人们的判断施加一定的影响，因为我们辨别和判断一件事物的好坏需要经过深思熟虑，这个过程对很多人而言并不那么“友好”，而具有了高声望，就能在判断上给予一定的肯定，简化了“深思熟虑”这项工作的任务量，因为声望的积累是基于大量的评价和时间的考量的，更能使人确信“它”对自身是有益的，由于思维的“惯性”我们就会自然而然选择了相信。 如同品牌效应，大厂出品一定会因为它完善的工艺和流程，质量上一定比同类产品更好。但销量高并不一定代表质量好，它们之间并不存在绝对意义上的正相关。对外部具有很高声望事物的盲目肯定，终会使我们的判断受制于对方。 假如没有了声望对判断施加的影响，那么真正吸引我们的，又是对方的什么呢？就拿衣食住行来说，我们选购一件衣物的判断，究竟是基于对品牌所积累的声望的信任，认为它一定用了优质的物料，一流的设计，还是商品本身质量就很不错呢？毕竟我们的世界是变化的，同样的产品或是服务，终究会随着时间的流逝产生差异的变动，很难“始终如一”。 如果商品和服务是我们还能切身在短时间内能感受到变化的，比较容易减小声望对人判断的影响。那么人呢？评判和了解一个人或许是一件复杂度极高的任务，我们难以短时间真正了解一个人，我们所基于的判断，来源于那个人的过去经历，例如他的受教育水平，是否具有本科学历，进而又要细分是否是名牌一流大学，因为那些大学本身所具有的声望能证明很多东西。如果是在校时就看在校的比赛获奖情况，进而又要区别看比赛的规模和大小，因为一些比赛具备参考价值，它确实选拔出了许多出色的人才，随着时间的积累，这个比赛所积累的声望就成为了一种“隐性标志”，暗示只要我获奖了，那么代表了我和曾经获奖的那些名人也具备同样的素质和潜力，而名人的成功也间接为类似比赛的声望添砖加瓦。但事物是变化的，我们只能保证在那样一个时间段里，它确实具有参考价值，含金量十足，但随着时代的发展，事物的更迭，能时刻保持领先，并始终拥有与之匹配的声望的事物是何其稀少。 当前的时代是网络时代，处于这个时代背景下的我们无法避免声望对我们判断施加的影响，而且网络的虚拟化，谁又知道一切是真的，而非虚张声势搭建起来的声望呢？网上购物商城的一些评价可以通过刷单刷好评取得消费者的信任，而最近大火的抖音，我们可以搬运别人的创意，成为自己涨粉的途径，哪怕只是从一些科普常识上搬运一些看起来有价值的东西，加上一个相关行业的背景，却能带来巨大的流量，点赞量和粉丝量无形为其树立起了某种声望，因为这类开放平台的用户量太多了，聚集了不同层次的人，但点赞量和粉丝量却是“一视同仁”的。 在这样的时代里，最能直接影响声望变化的，或许就是建立于社交媒体之上的舆论导向的，通过巧妙刻意的包装，引起舆论的关注，随即带来巨大的流量，无论是提高声望还是影响竞争对手的声望，都是无形的，如果对方的公关不能应对得当，那么就会陷入舆论的漩涡，或许可以通过一些形式“洗白”，但也依然会产生一些无形的影响，而往往这些“看不见”的东西更具风险性。 不要因为“声望”影响了我们对真实世界的认知，它可以作为评判的依据和参考，但不能作为先入为主的第一选择，无论是对任何事物，亦或是任何人，我们要关注于那些真正决定其本身的东西，避免陷入声望的陷阱。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector、ArrayList、LinkedList的区别]]></title>
    <url>%2F2018%2F10%2F02%2FVector%E3%80%81ArrayList%E3%80%81LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为何会选择技术之路]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%88%91%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[回顾往昔，当初我为何会选择技术这一条路，与接触新媒体息息相关，理解了媒介变化的本质，就理解了技术在其中所产生的作用。在这个时代，能推动信息流动的加快，那么这样的技术是富有潜力的，而信息流动的加快在人类的发展中始终都是至关重要的。同样的信息，过去使用书信往来，现在使用微信互动，传播的速度也是大相径庭的。也因为信息流动的加快，使得人与人之间，组织与组织之间因为地理位置差异所造成的隔阂不断缩小，我们能更频繁的进行贸易的往来，文化的交流等等，媒介就像是催化剂，它不能对事物的变化起决定作用，但它可以推动这个变化的速度，加快频率，那我们就能在同样的时间单位里完成更多的事。 媒介的发展，亦即传播速度的加快，在我看来，不仅仅是数据传输速度的加快，还包括处理的速度，也就是信息背后所包含的思想是否更容易被吸收和理解。不同媒介的传播速度是不一样的，文字作为人类文明承载信息的重要媒介之一，其本身却不是一个出色的媒介，通过文字所记录的信息，难免会在传递的过程中，由于个体的背景差异产生一些信息的失真。尤其我们在阅读一本晦涩难懂的书时，很难将作者所要表达的原意通过文字完完整整的解析出来，如果这本书还是翻译的版本，又会在翻译的过程中不可避免的损失一部分信息，全靠译者来把关，如果译者水平有限。。。那就只能听天由命或者直接选择阅读原著了。 相对于文字来说，人们更容易接受从图像中获取信息，而文字最初的产生。如中国古代的象形文字，或是苏美尔人所创的楔形文字，它们雏形的诞生，都多为图像。这也说明我们了解世界最开始某种程度上来说是从图像开始的。如今我们获取信息的渠道更多了，承载信息的主要方式不再以文字记录为主，图片、视频、音频、VR技术等新的形式，它们更多都从视觉的接受度上出发，在传播的过程中更利于被人们接受。 通过某种方式对信息进行加工，实现信息在传输和理解的“便利”化，一定程度上是可以推动信息的流动，但取决于“加工”的形式。例如我们可以精炼出一本书的核心要义，将一本书最核心的观点进行总结和转述，用便于人们理解的简洁明了的方式进行传播，那么其他人就可以在很短的时间里完成了“阅读”一本书的任务。但这个方式更多依赖于那个所谓的“领读者”，他不一定能完整的按原作者的思路和逻辑进行转述，而原作者本身是希望你通过阅读他的那本书的过程来完成你和他之间的信息传递。 当然我们也可以通过更好的表述，将原作者希望表达真实意思再现，原本他需要用很多的文字和语言来作为表述他那个想法的载体，现在你可以用更少的文字和语言实现同样的想法，或是通过其他方式，例如音视频、图片等等，说不定比文字更好实现你想要表达的东西。但这样的方式要更困难。这也是为啥除了文字，还有绘画、音乐等形式也在历史的长河中熠熠生辉。它们本身也承载着各自不同的文化底蕴，也因为如此，容纳了很多信息在形式之中，需要我们以恰当的方式“解读”出来。 对原有信息的“精炼”，将信息量缩减这样的方式，一旦逐渐发展成为了主流，大众便逐渐失去了接受信息后对信息的“再处理”的能力，简化信息量，使得用户不用思考便能吸收理解，真的好吗？抖音，今日头条，微信公众号，微博，它们通过不同的交互手段和信息呈现形式，不断地冲刷和改变着人们的意识流。我们的世界观似乎不再是由我们自己来主导，而是由这些新媒介，它们逐渐把控着我们对世界，对人和事物的认知。新媒介的发展不应如此，它的本质应该是使用户接受原有信息的效率更高，通过技术手段实现多样化的表现形式，发掘触觉，听觉，视觉等等方面，因为媒介是“人的延伸”，根本上的重构信息的展现形式，毕竟文字并不是一个很好的用来表现思想的媒介，重新唤醒人们接受信息，处理信息的深度思考的能力。 在我看来，“每天听本书”这样类似的形式，将原有体系精炼肢解后，以人们最便于直接理解，最易获得及时反馈的形式并不应该成为主流，即使因为工作生活原因，挤不出更多时间阅读思考，也不应该将这个过程“外包”出去。过程本身对自身思维的训练比直接获得结果更为重要。 纠结于文字本身，何不将重心往其他媒介上靠拢试试呢？一旦有了一个更为恰当的方式，不以牺牲个人主动思考的能力为主，那么它确实具备了促进人类的进步的意义和价值，它的出现令人们主动地去判断信息的价值。而技术本身对于实现这样的“新媒介”是有重要意义的，因为不同技术本身也有各自的特性，适用于解决的问题也有所不同，没有最好的，只有最适合的。只要通过技术能实现和解决这些旧有痛点，就是颠覆的可能，创建新的行业形式。 反之，技术仅仅被用于去提高原有“错误形式”的影响力，那么技术始终只是技术。比起实现需求，分析需求背后所带来的价值比单纯的需求更为重要。我为何会选技术之路，因为我希望看到不同技术背后对社会和人的影响，如果它并不能带来积极的影响，促使人和社会的进步，我希望我能发现更好的形式。这一切的基石是技术，需要靠它来实现，也只有自身更懂技术才能更好的实现这一过程。只有这样，技术在我手中才具有了意义，不再限定于程序员本身。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat学习总结]]></title>
    <url>%2F2018%2F09%2F23%2FTomcat%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于TomcatTomcat的目录结构]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Java泛型]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%B5%85%E6%9E%90Java%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本技术类书籍]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%B1%BB%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[前不久重读了《如何阅读一本书》，这本书成书时并没有计算机相关的读物，在介绍阅读不同读物的方法时，我认为技术类的书籍可能更接近于它里面所提到的科学与数学，而且更多偏实用型而非理论型，并且计算机一类的阐述特定技术的书时新性很强，随着技术的更新换代，很多都会过时，这一点在其他一类的书上没那么明显，一旦过时，其实用性就会大大下降，这里结合我的认知，谈一下关于技术类书籍应该如何阅读。 这里指的阅读，并非粗读或是泛读，虽然很多技术类的书也可以作为手册，需要的时候再进行查阅即可，但也不乏很多经典，它们需要我们细细品读，结合实践会不断提高我们的技术水平。这里总结了一些值得参考的书：每一个程序员都值得读的经典 首先我们明确它是否属于论说类的书籍，其次我们要分析这本书是否属于理论性的，类似《算法导论》一类的书，还是属于实用性的，类似《effective java》这样的书。 然后我们可以用几句话简单的叙述一下这本书主要讲了啥，将书里面重要的章节列举出来，说明它是如何根据某种逻辑来组成一个相应体系的，进而能够用来解决实际问题。关注作者希望通过这本书来为我们解决一个什么样的具体问题，这个问题属于哪一类别。因为计算机体系的模块化，抽象化和层次化，所以不同的书针对的方向和层次也是不一样的。 然后我们要关注一些重要的名词，看是否在翻译的版本中所要表达的东西是你印象里熟悉的那一个概念，然后我们要关注一些核心重要的部分，因为技术类的书具有很完整的逻辑，我们要对这些重要且难以理解的部分去理顺逻辑，看作者是如何逐步叙述他所要表达的内容的。如果是因为欠缺了某一部分的内容，造成了阅读过程中理解的困难，如果你觉得跳过，并不影响后续阅读，而且它并不属于这本书的核心内容，或是所描述的技术类别已经过时了，那么你可以先跳过。反之，我们可能需要花一些时间去了解一下那些与此相关的我们所不懂的概念，然后再尝试回过头阅读，看逻辑是否通畅，是否能继续读下去。当然这个过程最好的方式就是多实践，将其中的一些能够实现的东西，自己尝试做一下，可能很多不理解的东西就理解了。 在你对作者的一些实践方法作出评价之前，你最好已经明白了它的所有细节，你知道作者想要以此解决的问题，并且你也亲自实现过，然后你才可以对所谓的“最佳实践”作出判断；因为有的“最佳实践”所针对的只是那个特定的历史时期。然后你就可以通过类比得出适合自己的技术实践方式，不断地去更新这些“最佳实践”，可以使你的开发效率和代码质量不断提高。 尊重书中作者和你个人观点的不同，通过实践来证明，是否作者是针对某一特定的环境，而不是普遍的情况，寻找各自的理论基础作为支撑，另外技术类的书更新换代很快，我们在看一些经典“老书”时，要学会判断哪些观点和看法是过时了的，哪些是真知灼见，去吸收那些依然有用的思想洞见。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类的理解]]></title>
    <url>%2F2018%2F09%2F12%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别浅析]]></title>
    <url>%2F2018%2F08%2F26%2FString%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何高效提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[如何提问是一门学问，不会提问的人很难通过问问题解决问题，最终可能变成别人替你“代劳”解决了问题。不懂得如何正确提问，无论是对于你还是对于被问的人都是十分痛苦的，久而久之，别人也失去了帮你解决问题的耐心。所以，如何正确高效的提出一个问题，甚至使得被问的人也能有所收获，是一个很有必要学习的方法。 首先我们要明确我们要问的问题，它属于哪一个范畴，如果是技术类的问题，它又会具体的归为某一个模块，我们可以将问题的范畴逐步确定和缩小。当然，每一个人的能力和水平是不一样的，可能有的人看问题很有针对性，一针见血，他根据他的经验和判断能把问题立马缩减到一个具体的范畴里，而有的人可能只能有个大致的模糊认知。 然后我们要明确我们发问的“对象”，我们最终想要的不过是解决问题的办法，那么除了向其他人提问，是否有更好的方式和其他途径解决问题。例如，善用搜索引擎，我们基本上能解决我们所遇到的大部分问题，尤其是对于技术类的问题，像 stackoverflow 这样的社区，你基本能找到你想要答案，或是阅读相关的文档或是手册，都是不错的办法。而且这样一个搜索的过程，本身也是在不断试错中学习，能使我们对于整个问题的把握更为清晰，下一次遇到同类问题，将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人，举一反三。 不过，不是每次我们都能顺利的找到解决问题的答案，就拿技术类的问题来说，可能由于不同的系统环境，过去能解决的问题的步骤，可能现在不适用了，我们只能不断寻找。这个过程可能会很枯燥漫长，浪费很多时间，虽然我觉得最后发现“蓦然回首，那人却在灯火阑珊处”很舒畅，但这意味着可能这段时间里我们都无法继续推进我们的项目进度，倘若时间又很紧，那么此时可能找正确的人或是正确的论坛发问会是一个不错的办法。 向陌生人发问是充满不确定性的，因为对方并不一定能根据我们对于问题的描述完美的解决我们的问题。如果我们问的问题还不够明确，简洁易懂，可能对方就懵了，所以我们需要： 简单描述你需要完成什么样的需求，最终的目标是什么 简洁明了的叙述你的想法或思路 描述你具体的实现过程，其实就是你做了哪些尝试，最小化的重现问题的步骤 描述遇到的问题，例如报错信息，务必要让问题简单易读 如果是技术类问题，根据情况，再看是否需要给出具体某段实现代码 切记不要问与主题无关的问题，如果是那种通过自己搜索就能很容易找到解决办法的问题，最好不要去问，这类问题在别人看来肤浅甚至觉得你是个不愿独立思考的“lazy boy”，只想依靠别人，浪费别人时间。也不要低声下气，觉得有求于人，要知道一个好的问题，可能会促进双方的共同进步，别人也会因为能帮人解决了一个“难题”而高兴，礼貌客气不代表卑微，反而会增加你得到有用回答的机会，当然前提你事先经过做足了功课，别人也会认为你很有经验，问的问题可能是独到巧妙的。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript中的继承机制]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[原型链传统的面向对象语言里，基本都支持继承的两种方式：接口继承和实现继承。接口继承继承方法签名，而实现继承则继承实际的方法。至于JavaScript里的继承，由于函数没有签名，只能支持实现继承，而且主要通过原型链来实现的。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例又都包含一个指向原型对象的内部指针，通过使用原型，将方法添加在”父类“的原型里，然后”子类“的原型就是父类的一个实例化对象。1SubClass.prototype = new SuperClass() ; 如此层层递进，就构成了实例与原型的链条，这就是原型链。但原型链也有问题，原先实例的属性会在这个继承的过程中顺理成章的成为其“子类”的原型属性。而且创建的”子类“的实例，无法在不影响所有对象实例的情况下，像”超类“的构造函数传递参数，于是有了构造函数继承。 构造函数继承构造函数继承的核心思想就是SuperClass.call(this),通过call()和apply()方法，在新创建的对象上执行构造函数，然后改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题。123456function SuperClass()&#123; this.colors = ["read","blue","yellow"];&#125;function SubClsss()&#123; SuperClass.call(this);&#125; 组合式继承组合式继承，也叫作伪经典继承，结合了前两者的特点，既不会使每个实例化的“子类”互相影响，也避免了内存的浪费。它使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。既可以在原型上定义方法实现实现函数复用，又能保证每个实例都有它自己单独的属性。123456789101112131415161718192021function SuperClass()&#123; this.name = name; this.colors = ["read","blue","yellow"];&#125;SuperClass.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubClass(name, age)&#123; //继承属性 SuperClass.call(this, name); this.age = age&#125;//继承方法SubClass.prototype = new SuperClassSubClass.prototype.constructor = SubClass;SubClass.prototype.sayAge = function() &#123; console.log(this.age);&#125; 寄生式继承寄生式继承的思路是创建一个仅用于封装继承过程的函数，该函数的内部以某种方式来增强对象，然后返回对象，就像所有都是它做的一样，很像工厂模式。12345678function MyClass(original)&#123; //通过调用函数创建一个新对象 var clone = object(original); clone.sayHello = function() &#123; console.log("Hello"); &#125;; return clone;&#125; 不过使用这种模式来为对象添加函数，会因为不能做到函数复用而降低效率，所以出现了寄生组合式继承。 寄生组合式继承组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。集寄生式继承和组合继承的优点于一身，本质上就是使用寄生式继承来继承“超类”的原型，然后再将结果指定给“子类”的原型。123456789101112131415161718192021222324function inheritObject(subClass,superClass) &#123; //复制一份父类的原型保存在变量中 var p = inheritObject(superClass.prototype); //修正因为重写子类原型导致子类constructor属性被修改 p.constructor = subClass; //设置子类的原型 subClass.prototype = p; &#125; //定义父类var SuperClass = function (name) &#123; this.name = name; this.books = ['javascript','html','css'] &#125;;//定义父类原型方法SuperClass.prototype.getBooks = function () &#123; console.log(this.books)&#125;;//定义子类var SubClass = function (name) &#123; SuperClass.call(this,name)&#125;inheritObject(SubClass,SuperClass);var subclass1 = new SubClass('Java')]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、finally、finalize的区别]]></title>
    <url>%2F2018%2F08%2F17%2Ffinal%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this原理]]></title>
    <url>%2F2018%2F08%2F17%2FJavaScript%E4%B8%AD%E7%9A%84this%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于this为啥要有这个关键字呢？如果不使用this，我们在写代码时就需要显示的传入上下文对象。会很麻烦，随着代码量的增多，会使代码变得混乱，而this可以隐式“传递”一个对象的引用，利于代码复用，因为它会动态的判断上下文环境，然后引用合适的上下文对象。 我们可能会在学习时产生片面的误解，一种是我们认为this指向函数自身，另一种是我们认为this指向函数的作用域。因为在一些情况下，它们是对的，但有时却是错误的，举例来说：12345678function foo() &#123;var a = 2;this.bar();&#125;function bar() &#123;console.log( this.a );&#125;foo(); // ReferenceError: a is not defined 如果按之间的观点，那这段代码应该能正确调用，但实则不能，可见this关键字不是我们之前想的那样。 this是什么 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。 理解this的前提，我们需要知道什么叫做调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置，通过调用位置我们才好判断this究竟引用的是什么。 this的指向this永远指向最后调用它的那个对象，通过这句话就能很容易判断this的指向，因为调用位置就在当前正在执行的函数的前一个调用中。 默认绑定12345function foo() &#123;console.log( this.a );&#125;var a = 1;foo(); // 1 我们可以看到，最后调用foo()的地方，它的前面没有明显的调用对象，所以就是全局对象window，相当于window.foo()那么this的指向就是就是window这个全局对象，所以window.a的值就是1。这是默认的绑定情况。 隐式绑定我们有时候还要考虑调用位置是否具有上下文对象，可以看一个例子：12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;obj.foo(); // 1 这就简单了，因为this永远指向最后调用它的那个对象，最后调用它的是obj，所以就相当于obj.a，所以值为1，下面是另一种情况，可能我们调用时是在一个属性引用链上：123456789101112function foo() &#123;console.log( this.a );&#125;var obj2 = &#123;a: 2,foo: foo&#125;;var obj1 = &#123;a: 1,obj2: obj2&#125;;obj1.obj2.foo(); // 2 不用在意obj1，这里我们要强调“最后调用”，所以最后调用的是obj2，obj1先调用obj2，obj2再调用foo(),所以结果就是obj2.a，所以值为2。 但假如我们给函数起了别名，可以通过一个例子看一下：12345678910function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;var bar = obj.foo; // 函数别名！var a = "hello"; // a 是全局对象的属性bar(); // "hello" 虽然我们将 obj 对象的 foo 方法赋值给变量 bar 了，但是没有调用，所以bar()最后还是被全局对象window调用了，this的指向就是window，就相当于window.a，所以值为hello。 不过我们需要尤为注意回调函数里的this的指向问题，因为回调函数里我们传入的函数，实际上它相当于给里面的形参取了一个别名。当我们分析this的指向时，它实际的指向会被误导，但实质上它还是指向最后调用它的那个对象。 显式绑定如果我们想在某个对象上强制调用函数，可以直接指定this指向的对象，什么意思呢，我们先看一个例子：12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:1&#125;;var a = 2;foo.call( obj ); // 1 我们通过call()函数，将obj的作用域传递进了foo中，因为JavaScript存在一个作用域链，相当于我们window.obj.foo(),所以最后调用的是obj对象，所以值为1。我们把foo的this绑定到了obj上。也可以通过apply()和bind()方法。 new绑定12345function foo(a) &#123;this.a = a;&#125;var bar = new foo(1);console.log( bar.a ); // 1 使用new来调用foo()时，我们会构造一个新对象，这个新对象会绑定到foo()调用中的this上，所以bar.a的值就是1，和隐式绑定里的取别名是不一样的，它依然指向最后调用它的那个对象。 箭头函数ES6里，我们可以使用箭头函数始终指向函数定义时的this，不用担心执行时改变，在箭头函数里也没有this绑定了，上面四条绑定原则也不存在了，要根据作用域链来决定它的值，箭头函数会继承外层函数调用的 this 绑定。12345678910111213var a = "hello";var ogj = &#123; b : "hi" func1: function () &#123; console.log(this.b); &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;obj.func2() // hi 总结总之，我们要记住”this永远指向最后调用它的那个对象“，具体绑定的方式，如果是由new调用，那它就绑定到了新创建的对象上，如果由call()、apply()、bind()调用，那么就是在绑定的那个对象上，如果包含上下文调用的隐式绑定，要注意上下文对象，如果包含回调函数，要格外小心。如果使用了箭头函数，注意根据作用域链来决定“this”的指向。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析Java的static关键字]]></title>
    <url>%2F2018%2F08%2F13%2F%E8%A7%A3%E6%9E%90Java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口和抽象类的区别]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript的闭包]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[JavaScript里的闭包是它的一个特色，这也是静态语言所不具备的一个特性，很多高级功能都依靠闭包来实现，理解闭包其实一点都不困难。 变量作用域理解闭包的前提是理解JavaScript的变量作用域，变量的作用域分为全局变量和局部变量， JavaScript具有基于函数的作用域，每声明一个函数都会为其自身创建一个自己的执行环境，而且在函数内部就可以直接访问全局变量。12345var a = 1function func1()&#123; console.log(a);&#125;func1(); // 1 但是在函数外是无法访问函数内的局部变量的。不过如果不使用var关键字，就会在内部作用域声明一个全局变量。1234function func1()&#123; var a = 1&#125;console.log(a); // error 这里就涉及到一个问题，假如我们需要读取函数内部的变量怎么办？于是我们只能在函数的内部再定义一个函数。123456789function func1()&#123; var a = 1 function func2()&#123; console.log(a); &#125; return func2;&#125;var n = func1();n(); // 1 此时，func1内的所有局部变量对于func2来说都是可见的，func1的返回值，也就是func2（），赋值给变量n，然后调用n(),实际只是通过不同的标识符来引用调用了内部的函数func2(). 闭包说了半天，那么闭包到底是啥，我的理解是：闭包就是函数的局部变量的集合，能够读取其他函数的局部变量，只有定义在函数内部的子函数才可以获取局部变量，当一个函数定义在另一个函数内，并且试图通过子函数获得局部变量，它就是闭包。 闭包使得函数内部作用域和函数外部作用域的连接成为了可能，局部变量可以在函数返回后被访问，而且闭包里变量的值可以始终保持在内存中，我们可以通过一个例子来看：123456789101112131415function func1()&#123; var n=1; Add = function()&#123; n += 1 &#125; function func2()&#123; console.log(n); &#125; return func2;&#125;var result = func1();result(); // 1Add();result(); // 2 可以看到局部变量n一直保存在内存中，不会随着函数调用的结束而被垃圾回收，func2是func1的子函数，但作为func1的返回值，却被赋值给了一个全局变量result，这就使得func2始终在内存中，因为func2的存在依赖于func1，所以func1也就跟着保存在了内存中。 前面提到，如果不使用var关键字，会在内部声明一个全局变量，所以Add就是一个全局变量，但它可以在函数外部对内部的局部变量进行操作，实则它也是一个闭包。 过渡的使用闭包，内存消耗会很大，但闭包的用处也很多，在定时器、事件监听器、Ajax 请求、跨窗口通信或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上就是在使用闭包。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中医与程序员]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%B8%AD%E5%8C%BB%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[在我看来，计算机产业还是一个很“年轻”的行业，相比于其他传统的行业起步要晚，但它发展迅猛，短短几十年便跻身影响当今世界发展的重要产业之一。而且从事计算机这个行业可以说“门槛”很低，这个门槛并不是入行的门槛，而是能让你不断提高有机会成为这个领域大牛的门槛，相对于其他复杂度接近的行业来说。因为技术是相对开放和自由的，只要你愿意，你能获得很多的资源，像 Github这样的开源社区，亦或是 stackoverflow 这样的技术问答网站，你都能从中了解和学习到很多流行的技术。 计算机科学里很多概念可以让我们从一种新的角度来理解事物，若利用得当，可以避免陷入解决不同问题时，总用使用“一把锤子”的思维局限，不同的问题若用同样的方式来处理，真的能把问题处理好吗？ 例如中医和西医，如果从计算机专业的角度，中医更像是“应用型程序员”，他们通过现有的框架和API的调用，建立在抽象的角度来解决不同的问题，为此他们需要熟知各类方法，API接口的作用和组合后产生的影响，很像中医里对草药作用的了解和应用。 《thinking Java》里说“万物皆为对象”，其实创造这些草药的“库程序员”正是大自然本身，它所采用的构建方式极其复杂，抽象层次很高，它把这一系列的细节都已经封装好了，使得传统中医并不需要知道这些草药中究竟是哪一具体的物质是对特定病症有效的，因为“草药对象”本身封装了“数据”和“方法”，传统中医只需知道它们的作用以及用法对症下药即可。 西医与中医不同，对于医药研究来说，它们更像是“库程序员”，需要对自然界不同的物质进行分析、提取和研究，以便真正弄清是哪一具体物质对人体的哪一具体细胞组织产生作用，因而也要研究人体的生理层次的构造。或是进行组合，看这种变化是否符合预期，而对于产生作用了的新物质，会用一个特定的标识符来为其命名。 但有一个问题，它们所研究的这些“对象”本身就是由自然界这个最伟大的“库程序员”经历漫长的演化而来的，所以生命是伟大的，看似简单，但那是因为它们“构建”于不同的抽象层次并封装了一系列的实现细节，我们研究“抽象”，而“抽象”也形塑我们。 西医的一些研究过程，就如同抽丝剥茧般的去“解封装”，通过不同的工具去试图解构更底层的实现，通过了解物质之间的相互作用，就能获取特定的物质，再以此为基础研究新型的药物，这些新药是“自然界”之前所没有的，被人为创造出来，如同通过一个旧有的框架和库，依托于它产生了一个新的框架和库。 有趣的是，中医更多依赖于于大自然这个“标准库”，依靠大自然这位最伟大的“库程序员”来提供解决问题的方法，而西医更多通过“解封装”，再进行抽象的形式自建“第三方库”，来解决问题，谈不上哪个更为高明，本质上就是不同的。西医也无法保证，已经“解封装”到了最底层，弄清了各个原子对象及其所有实现细节，需要不断地去推进对于“对象构建”本身的研究。而中医也不可能完全驾驭“自然界”这个庞大的库，因为宇宙是无垠而未知的，我们对它的探索也远未到极限。 只要存在了可能性，中医也好西医也罢都会在各自的道路上不断前进。那个推动我们朝一个领域前进的动力又是什么呢？]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript的“面向对象”编程]]></title>
    <url>%2F2018%2F07%2F17%2F%E8%B0%88%E8%B0%88JavaScript%E7%9A%84%E2%80%9C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[初识JavaScript面向对象相对于Java里的面向对象来说，JavaScript里的面向对象机制绝对可以称之为“另类”了，因为如果我们具有Java/C++这类传统面向对象语言的使用经验，以那样的思维来学习JavaScript的面向对象令你产生很多疑惑。 定义一个JavaScript对象很简单，我们可以：1var a = &#123;&#125;; 也可以用其他的方式：12function f() &#123;&#125; 可能你会产生疑惑，这不应该是一个函数吗？咋就变成对象了，因为在JavaScript里函数也是对象，而且还是一等公民。而在很多传统语言中，例如Java、C/C++等，函数都是二等公民的身份。什么叫二等公民呢？你只能用语言的关键字声明一个函数然后调用它，如果需要把函数作为参数传给另一个函数，或者赋值给一个本地变量，又或是作为返回值，就需要通过函数指针、代理等特殊的方式周折一番。 而在JavaScript里的函数，它不仅拥有一切传统函数的使用方式，而且可以做到像简单值一样赋值、传参、返回，而且JavaScript中的函数还可以充当“类”的构造函数，同时又是一个Function类的实例，这样的多重身份让JavaScript里的函数变得极其重要，使得 JavaScript 更像是 Scheme （一种函数式语言）。 JavaScript提供了一个构造函数模式来在创建对象时初始化对象，而构造函数也只是一个普通的函数，只不过它内部使用this，使用new生成实例，在这一点上很像传统的面向对象语言。而this总是指向当前对象，无论是添加属性还是方法，都只在当前对象添加，实例化一个新对象时，就会在内存里复制一份，但过多的新对象不可避免会造成大量的内存浪费。 为了解决这一问题，于是有了原型prototype的形式，在JavaScript里，每一个构造函数都有一个prototype属性，指向另一个对象，这个对象的所有实例和方法都会被构造函数的实例继承，对于不变的属性和方法，可以直接添加在类的prototype对象上。功能上来看，很像Java里接口的概念，尤其是Java 8引入了接口的默认方法，二者在功能上看上去更为接近。123456function Dog(name,color)&#123; this.name = name; this.color = color; &#125; Dog.prototype.type = "宠物"; Dog.prototype.eat = function()&#123;alert("吃狗粮")&#125;; 当我们生成实例时，实例里的属性和方法其实都在同一个内存地址，指向prototype对象，避免了不必要的内存浪费。但也会因为改动一个对象的属性而可能影响到其他相关的对象，而利用构造函数的形式则没有这样的弊端。 传统的面向对象语言里，例如Java，会有相应的访问控制功能，借助于public、protected、private这三个关键字，而JavaScript里则没有类似的关键字，但为了实现类似的功能，例如属性和方法的私有，就可以借助于函数作用域的特性，因为函数内的局部变量如果不通过闭包等方式是无法直接访问的，对外层作用域而言就是“私有”的。 Javascript里的“类”在ES6之前，JavaScript只有一些近似类的语法元素。JavaScript里没有“子类”和“父类”的区分，也没有“类”和”实例“的区别，我们可以模拟出传统面向对象语言里类的特点，但它的机制和我们理解的类的概念是完全不同的，只是通过”语法糖“的包装和”类“库的存在让我们误以为JavaScript的类存在而已。 那么”类“中的继承又是如何做到的呢？JavaScript主要依靠继承链来解决继承的问题。传统情况下，我们在JavaScript生成一个实例的方法都是通过构造函数，类似于这样：12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 而在其他传统面向对象语言里，一般情况下，都是生成一个class，然后再通过类的构造器来生成相应的实例对象，所以JavaScript显得很特别。在ES6里引入了“class”的概念和关键字，通过这个关键字，可以定义一个“类”。像这样：12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 这样的形式就不容易使人困惑了，它就更接近我们认知里的类的概念了。ES5里的Point构造方法就是ES6里Point“类”里的构造方法,而且toString方法也定义在了“类”里，而在“类”里的方法是不需要function关键字的。 某种意义上ES6里的“类”就是一个语法糖而已。。。实际上基本可以看作传统构造函数的一种简便写法。因为类里的所有方法实际上还是定义在prototype属性上面。12345678910111213class Point &#123; constructor() &#123; &#125; toString() &#123; &#125;&#125;//等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;,&#125;; 而在“类”的实例上调用方法，其实就是在调用原型上的方法。不过也有一些差别，在“类”的内部所有定义的方法都是不可枚举的。 在JavaScript里，定义函数的方式有两种，一种是函数声明，一种是函数表达式：1234567//函数声明function functionName(arg)&#123;&#125;//等同于函数表达式var functionName = function(arg)&#123;&#125;; 对于类来说一样也可以通过表达式定义12345const MyClass = class Point &#123; getClassName() &#123; return Point.name; &#125;&#125;; 只不过这个类的名字不再是Point，而是MyClass，Point只在class的内部使用，指代当前类。 JavaScript里的函数声明具有函数声明提升的特征，即使放在相关调用语句之后，也会在执行代码之前先读取函数声明，而类不存在这样的提升特性。因为ES6里的“类”，依然只是之前的构造函数的一层包装罢了。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式小记]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于正则表达式正则表达式是为了从大量数据中检索匹配出所需数据的一种强有力的工具，它赋予使用者描述和分析文本的能力，如果没有正则表达式，我们也可以实现同样的功能，只是需要通过循环遍历，通过大量的条件判断才能得到想要的结果。而正则表达式只需要简单的而命令，就能够检索所有文件。 常用元字符“ . “: 使用.字符匹配任意单个字符、字母、数字或者.字符本身，不过要在.的前面加上 \ ，对它进行转义，匹配其他元字符也一样。“^”: 使用^会匹配行或者字符串的起始位置“$”: 使用$会匹配行或者字符串的末位“\d”: 匹配数字，如果是匹配非数字字符，只用把d大写就行\D“\w”: 匹配字母数字和下划线，等价于[a-zA-Z0-9_],如果是匹配非字母数字或下划线字符，只用把w大写就行\W“\s”: 匹配空白字符，如果是匹配非空白字符，只用把s大写就行\S“\b”: 匹配一个单词的开始或是结尾，这个“单词”在正则表达式看来就是一个与\w相匹配的字符和一个与\W相匹配的字符之间的位置，它只匹配一个位置，不匹配任何字符，\B表示不匹配一个单词的边界“ [ ] “: 只匹配括号内定义的字符集合，字符集合可以按字符区间来表示区间内所有字符，以下是一些合法的字符区间例子: A-Z 匹配A到Z的所有大写字母 a-z 匹配A到Z的所有小写字母 A-z 匹配ASCII字符A到ASCALL字符z的所有字符，其中也包含[或是^等类似字符，可能匹配到多余结果。 POSIX字符类POSIX字符类是一种正则表达式的简写形式，可以通过元字符和POSIX字符类的组合来简化正则表达式。 重复匹配正则表达式可以进行重复匹配，匹配多个连续出现的字符或者字符集。 “ * “：匹配零次或多次例如：a*会匹配到所有的字符或字符集为”a”的情况 “ + “：匹配一次或多次，至少一次例如：a+会匹配到字符或字符集中为”a”的情况，a+与a*不同在于”+”至少是一次而”*” 可以是0次 “ ? “：匹配零次或一次例如：a?只会匹配一次，也就是结果可能只有单个字符a “{n}”：重复n次匹配例如：a{3}结果就是匹配到满足3个a字符的情况 “aaa” “{n,m}”：重复n到m次匹配例如：a{2,3} 将a重复匹配2次或者3次 所以匹配到的字符可以是两个”aa”也可以是三个”aaa” “{n,}”：重复n次或更多次匹配，至少匹配n次 子表达式子表达式是为了解决一些特殊匹配情况下使用的，使用一对圆括号把正则表达式括起来，按我的理解，其实它就是解决一个优先级和整体匹配的问题，类似于C语言里的双括号，为了显式增强操作符优先级顺序，避免混乱。 举个例子：&amp;nbsp;{2,4} 这个正则表达式的原意是为了匹配&amp;nbsp两次到四次，但实际{2,4}只作用于它的前一个字符，相当于它只会匹配到&amp;nbsp;; 、 &amp;nbsp;;; 、 &amp;nbsp;;;;。 所以引入了子表达式，(&amp;nbsp;){2,4}这样就能按我们预期的结果进行匹配了，它会把&amp;nbsp;看成一个整体进行匹配。 子表达式也是可以进行嵌套使用的，但我们要尽量避免嵌套次数过多引起的逻辑混乱，阅读困难。 常见问题的正则表达式这里是一些网上搜集的常见的正则表达式匹配的例子，学习正则表达式最好的方式就是多练习多思考，通过这些简单的例子作为参考来学习，由浅入深，而不是直接复制拿来用，真正掌握了正则表达式才能灵活应对各种情况。它仅仅是一个方法的参考，而非方法本身。 检验数字 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m - n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1 - 2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1 - 3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 非零的负整数： ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 非负浮点数：^\d+(\.\d+)?$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 浮点数：^(-?\d+)(\.\d+)?$ 校验字符 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 可以输入含有\^\%\&amp;\’\,\;\=\?\$\“等字符：[^%&amp;&#39;,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 其他需求 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? URL地址：^https?://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^([1][3,4,5,6,7,8,9])\d{9}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[\da-zA-Z]{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代，如果你觉得空字符串也可以接受的话，最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 双字节字符 (包括汉字在内，可以用来计算字符串的长度，一个双字节字符长度计2，ASCII字符计1)：[^\x00-\xff] 空白行的正则表达式 (可以用来删除空白行，windows的换行是\n\r，而linux和unix中换行是\n，这点需要注意)：\n\s*\r HTML标记 (仅仅能部分匹配，对于复杂的嵌套标记依旧无能为力)：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; 首尾空白字符(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等，非常实用)：^\s*|\s*$或(^\s*)|(\s*$) 腾讯QQ号(腾讯QQ号从10000开始) ：[1-9][0-9]{4,} 中国邮政编码 (中国邮政编码为6位数字)：[1-9]\d{5}(?!\d) IP地址 (提取IP地址时有用)：(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5])) 或 ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 参考文章： http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些值得参考的摄影名言]]></title>
    <url>%2F2018%2F07%2F01%2F%E9%82%A3%E4%BA%9B%E5%80%BC%E5%BE%97%E5%8F%82%E8%80%83%E7%9A%84%E6%91%84%E5%BD%B1%E5%90%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[“Your first 10000 photographs are your worst.“你拍的前一万张照片都是拙劣的。 “Think about the photo before and after, never during. The secret is to take your time. You mustn’t go too fast. The subject must forget about you. Then, how ever, you must be very quick.”在摄影之前和之后思考，而不是在摄影的过程中。街头摄影的奥秘在于放慢步调，仔细斟酌。拍摄的主题必须要看不到你的存在，而此时你的速度必须要很快。 “The most difficult thing for me is a portrait. You have to try and put your camera between the skin of a person and his shirt”对我来说最难的是肖像摄影。你必须要将摄影机放置在一个人的皮肤与他的衣服之间适当的位置。 “The single most important component of a camera is the twelve inches behind it.”摄影机最重要的元件是它后方十二寸的那玩意儿。 “A good photograph is knowing where to stand”一张好的照片是知道该在哪驻足。 “A true photograph need not be explained nor can it be contained in words”真正的摄影作品不需要言语去描述它，因为它也无法用言语来表达。 “If I saw something in my viewfinder that looked familiar to me, I would do something to shake it up.”如果我透过取景器看到某个我觉得熟悉的东西，我会试着去从不同的视角出发重新看一遍。 “The best camera is the one that is with you”最好的相机就是你需要时恰好在你身边的那一个。 “The best camera is the one that you left at home.”优秀的相机是你忘在家里的那台。（如果“home”是手机，那或许就是某一个下载的优秀的摄影软件了，哈哈） “Everyone will take one great picture, I’ve done better because I’ve taken two.”每个人都有机会拍出一张很棒的照片，我比较厉害是因为我拍出两张。 “You cannot depend on your eyes if your imagination is out of focus”当你的想像力无法集中时不能依赖你的眼睛。 “If you can smell the street by looking at the photo, it’s a street photograph”如果你在看照片的时候能嗅到大街的气息，那就是街头摄影。 “All photography is propaganda”所有的照片都是一种宣传。 “I have discovered photography. Now I can kill myself. I have nothing else to learn.”我终于了解了摄影，现在我可以自杀了，因为我已经没什么好学的了。 “If you keep your cool, you’ll get everything”如果你能保持冷静，那你将能得到一切。 “Great photograph is about depth of feeling, not depth of field”好的照片在于情感的深度，而非景深。 “Sometimes the simplest picture are the hardest to get”很多时候最简单的照片反而是最难拍的。 “Which of my photographs is my favorite? The one I’m going to take tomorrow.”你问我最喜欢自己拍的哪张照片？那就是我明天要拍的那一张。 “It’s not what you look at that matters, it’s what you see.”摄影跟你看到什么事物没有太大的联系，而是取决于你是如何看的。 “My life is shaped by the urgent need to wander and observe, and my camera is my passport.”我的生命是以不断想到处寻觅的急迫感所形成，而相机就是我的护照。 “I am forever chasing light. Light turns the ordinary into the magical”我不断追逐着光，光能化腐朽为神奇。 “I only use a camera like I use a toothbrush. It does the job.”我的相机就跟我的牙刷一样，它做着它本职的工作，就是拍照。 “Don’t pack up your camera until You’ve left the location”别把相机收起来，除非你要离开拍摄现场。 “I’m a Tourist”我是个观光客。 风光摄影并不意味着风景一定是作品中最重要的元素，摄影师心中的风光才是作品的灵魂所在。光线，构图和影调都能被用于情绪的表达和传递。 在时间的概念中！没有任何两者是绝对相同的，因为任何事物都会随着时间消逝，因此，每一时刻都为摄影提供了无限可能！ 打破创意的界限：如果某一瞬间是值得被拍下来的，那么，就算成功的概率不高，也同样值得一试。毕竟，胶片相对来说还是比较便宜的，而数据储存卡也可以反复使用。勇于挑战摄影的极限会获得超乎想象的意外收获。 对影像倾注感情，并不代表要将影像修饰得浓、重或阴沉。但作为一张可塑性较强的，底片或数字文件，它们必须具备完整的影调范围，为后期调整和印制提供最大的自由度。 使用做工精细的木制相机和品质优异的顶级镜头是一件多么令人愉悦的事啊，但如果摄影师过分依赖器材，他将不会拥有别具一格的视角，以及对光线的解读能力。 风光摄影的挑战在于个性化的方式表达。众所周知，那些为人所熟悉的场景更需要新鲜的视角。 再三研读杂志里提供的所谓“黄金法则＂是徒劳无功的，因为影像的表达是源自内心的感动，而非别人为你制定的一张富有表现力的照片也许是精巧的，也许是浓重的， 摄影是一种让人去感受的途径，令人感动和感到爱。被摄在照片上的会直到永远，而它能够在你忘记所有后，仍然令你想起那些小事情。 摄影是一项观察的艺术。摄影就是在平凡的地方寻找不平凡之处，而这与你所见到的东西无太大关系，真正重要的是你怎样去看事物的方式。 摄影是捕捉一个转眼即逝但却真实的瞬间。 照片是秘密中的秘密。它说得越多，你知道的就越少。 摄影是虚拟现实，它的作用就是帮助你产生一种置身在另一世界的幻觉。 摄影是从时间中抽出一个瞬间，通过它来改变生活。 摄影是塑造人类感知的要素。 摄影既是世上最简单的事，也是最复杂的事，因为难以使它发挥真正作用。 摄影是一个瞬间，让人在半秒钟内获得照片，去记录当刻的他们。 摄影是一种即时反应，而绘画是一种沉思。 摄影是在认知到当下是重要时刻的同时，以准确的画面铺排去表现所发生的事。 摄影不仅是思想交流的媒介，也是创作的艺术。 摄影是找出相框内发生什么事。当人把事实加上四个边框，事实就被改变。 摄影是真理，而电影是每秒 24 次的真理。 摄影是简单的事，你只是对你看到的反应，并拍很多很多的照片。 摄影在社会上是微小的声音，但一张或一组照片可以引起人的意识。 摄影是现实，奇妙的是它变得比现实更真实。 摄影是区别自己及工作的行为，也帮我看得更清楚我这是在做什么。 摄影是向人类解释人类。 摄影是最简单的媒介，几乎任何人都可以胜任。摄影也是最难的媒介，因为要有独特的个人触觉和风格。]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于指针和数组]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组和指针之间的关系很微妙，我们有时会遇到这样的例子，对于a[2]这样的数组，其实就相当于*(a + 2)，然后我们就自然而然地认为数组和指针是一样的了，可以互换，除非是在我们实际应用过程中出现了问题，我们才会在不断修正中明白，其实数组和指针并不同，只有在满足一些条件的情况下，数组和指针才可以进行互换。 指针和数组的不同指针是用来保存数据的地址的变量，而数组则是用来保存数据；我们可以通过指针进行间接访问，取得里面的地址值，再通过那个地址值提取数据，如果p是一个指针，它有一个下标，例如p[2],它就把指针里储存的地址值与2相加，再从这个新地址求值，而数组则是直接访问数据，a[2]只是简单的以a + 2的偏移量取得数据。指针通常指向匿名数据，而数组自身就是数据名，所以指针依赖于malloc(),free()这类函数来解决内存问题，而数组的话则是隐式的分配和删除。 什么情况下指针可以和数组互换首先表达式里的数组名被编译器当做一个指向该数组第一个元素的指针时，例如1int a[5],*b,i = 2; 那么我们访问a[i]时，可以通过以下方式12b = a;b[i]; 12b = a;*(b+i); 12b = a + i;*b; C语言把数组下标改写为指针偏移量的根本原因是因为指针和偏移量是底层硬件使用的基本模型。当下标总是与指针的偏移量相同时，就可以互换。例如：12for(i = 0; i&lt;=10; i ++) a[i] = 0; 相当于123b = a;for (i = 0; i&lt;=10; i++) b[i] = 0; 其中的b[i] = 0又可以写成*(b + i) = 0 如果声明是int *a[]呢，由于下标的优先级更高所以它表示一个数组，它里面的元素类型是指向整型的指针，所以它相当于一个指针数组。指针数组最频繁的用处在于储存长度不同的字符串，因为你不用固定分配大小去浪费储存空间，指针数组更具动态扩展性。 我们可以使用括号，使得int (*a)[]，那么它就表示一个指向整型数组的指针。 还有一种情况数组名等于指针，那就是当一个数组作为函数参数时，因为编译器会把数组的形式改写为指向数组的第一个元素的指针的形式，它只向函数传递一个地址值，而不是整个数组的拷贝，这更多是出于效率考虑。例如int (*abc())[10],abc是一个函数，它返回一个指向包含10个int元素的数组的指针。 在C语言中，严格来说，函数是不能直接返回函数和数组的，但可以让函数返回一个指向任何数据类型的指针，例如int *a(),它的返回值是一个指向整型的指针，而int (*a)()，左边的一对对括号迫使间接访问在函数调用之前进行，使a成为一个函数指针,它所指向的函数返回一个整型值。 我们再来看下int *(*a)(),它所指向的函数的返回值是一个指向整型的指针。如果声明是int (*a[])()，可能有点复杂，但实质上它表示一个数组，数组的类型是指向函数的指针，它所指向的函数的返回值是一个整数，如果声明是int *(*a[])()，我们就知道，它表示一个数组，数组的类型是指向函数的指针，而它所指向的函数的返回值是一个指向整型的指针。 关于指针和多维数组对于C语言而言，定义和引用一个多维数组的办法就是使用数组的数组，也就是数组的嵌套，例如a[3][5]，那么a是啥呢，我们可以把它看作是一个一维数组，它包含三个元素，每个元素包含五个整型值，所以a所指向的就是一个包含五个元素的数组而a+1就相当于指向a的另一行数组，如果是*(a+1)则表示它指向那一行的第一个元素而*（a+1)+1，其实就相当于比原来的表达式向后移动了一个元素，如果对整个表达式进一步处理一下，*(*（a+1)+1),那么它作为右值就相当于对那个位置的值间接引用，而作为左值，这个位置就代表那块空间，它可以被赋予新值。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和操作符]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%8C%87%E9%92%88%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[关于操作符你需要知道在谈论指针之前，我们很有必要说一下C语言里的操作符，C语言里有着种类繁多的各式操作符，大致可以分为算术操作符（+ - / %）、移位操作符（&lt;&lt; &gt;&gt;）、位操作符（&amp; | ^）、赋值符（=）、复合赋值符（+= -= = %= /= &lt;&lt;= &gt;&gt;= &amp;= |= ^=）、单目操作符（! ++ – - &amp; sizeof ~ + ）关系操作符（&gt; &lt; == &gt;= &lt;= !=）逻辑操作符（&amp;&amp; ||）条件操作符（expression1 ? expression2 : expression3）、*逗号操作符（,）。 操作符的复杂主要体现在它的优先级和结合性，两个相邻的操作符哪一个先执行取决于它的优先级，在它们优先级相同的情况下又要考虑它们的结合性，是左结合还是右结合，尤其是和指针联系在一起时更容易产生错误的执行结果，因为相对于其他语言，诸如Java、Python来说，指针是C语言的一个特色，也是一个难点。 对于操作符的优先级问题，可能一个最直接有效的办法就是添加括号，但是当表达式有太多的括号时反而不容易理解，所以适当的记住一些常见易混的操作符优先级，并适当的使用括号来辅助理解是一种很不错的方法。为此我们需要记住任何一个逻辑运算符的优先级都要低于任何一个关系运算符，而移位操作符的优先级比算术操作符要低，但要比关系操作符高。 关于指针你需要知道指针实质是表示内存地址的变量，指针主要做两件事：避免副本和共享数据。由于C语言中的一切函数调用，值传递都是“按值传递”的，它会创建一个拷贝的副本来进行操作，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成，也就是“按址传递”，而这个过程数据是共享的。所有赋值都会复制数据，如果你想复制数据的引用，就应该赋指针。 对指针进行间接访问之前，要确认它们已经被初始化，否则仅仅声明了一个指针却没有对他进行初始化，例如：12int *a;*a = 12; 是无法得知它的正确地址的，因为声明一个指针变量并不会分配任何内存。 指针和操作符的问题举个例子，就拿以下代码来说12int ab = 4;int *cp = &amp;ab; 当不同的表达式作为左值和右值时，它们表达的东西是不同的，对于左值来说，他表示的是一块明确的地址空间，而右值是一块地址空间里的值。 当我们的表达式是&amp;ab时，作为右值他表示变量ab的储存空间地址值，他也有一个地方来储存这个值，但我们没办法知道那块空间的具体位置，没有标识是一个明确的特定位置，所以作为左值，使用取址操作符的变量都是非法的。 当我们的表达式是cp时，作为左值他就表示的是cp本身的地址空间，作为右值就是表示变量ab的地址值。 当我们的表达式是&amp;cp时，我们知道它不能作为左值，对于右值来说，他是一个空间地址的值，也就是指针变量所在的那块空间的地址值，而指针变量中又保存着他指向那个对象的地址值，也就是指针的指针。对于指针的指针，类似于int **a,只有当确实需要时，才应该使用多层间接访问，不然程序会变得难以维护和理解。 当我们的表达式是*cp时，它相当于一个间接访问(解引用)，作为左值就表示ab所在那块空间，我们可以将新的值作为右值替换掉里面的原内容，作为右值就表示那块空间里原本存放的内容。 当我们的表达式是*cp + 1时，由于*操作符的优先级高于+，所以首先执行*cp,作为右值，也就是ab里保存的内容4,所以作为右值的结果就是5，但作为左值，我们知道这个结果需要一个位置保存，但那个位置没有明确定义，所以作为左值是不合法的。 当我们的表达式是*(cp + 1)时,作为右值，我们知道cp它表示ab的地址值，由于有括号，所以优先级更高，地址值+1后对那块地址值空间进行间接引用，获得那块空间里保存的对象。 涉及到前置和后置递增递减运算符时，可能是最容易产生错误的了，无论是遇到前置递增（递减）操作符还是后置递增（递减）操作符时，它都会产生一个原指针的拷贝，也就是里面所保存的指向某一内容的地址值，然后拷贝的这个地址值会放到一个新的空间里，如果是前置递增（递减）操作符会先进行原地址值的自增（自减）操作，所以他复制的拷贝会是自增（自减）后的新地址值，然后新的指针和原指针都将指向一个新的位置，并可以在拷贝上执行间接访问操作，访问那个未知的值；如果是后置，不会先进行自增操作求值，所以拷贝的值会是原指针的地址值，它和原指针指向相同的位置，而之前保存地址的那个位置将进行自增/自减操作，地址值更新并指向一个新的位置，由于我们是在拷贝的指针上执行间接访问操作，所以依然指向原地址值。C语言中所有对象，包括指针本身都是 “复制传值” 传递。例如： ++cp,在进行运算前它会先获取一个自增后的拷贝，我们知道作为右值时，cp代表的就是ab那个位置的地址值，由于自增，所以指向它的下一个地址值，但作为左值，因为自增后的拷贝结果是位于一个无法清晰定义的位置，所以不能作为左值。 cp++,由于是后置自增运算，所以不会先进行自增操作，所以拷贝的值的位置依然指向原地址，而原cp会在运算结束后求值，所以它会指向ab位置的下一块内存空间。 *++cp，通过++cp我们知道它指向的是ab的下一块内存空间，由于*的操作符优先级要比自增（自减）操作符低，所以它相当于(*(++cp))，对那块空间执行间接引用，作为左值时表示那块空间的地址，作为右值则表示那块空间里存储的未知值。 *cp++,通过运算符优先级我们知道，它相当于(*(cp++)),由于cp++的结果是指向ab，所以作为左值*cp++就表示ab所在的那个地址空间，而作为右值，它就是ab保存的值：4。 ++*cp,根据运算符优先级，它相当于(++(*cp))，我们确实先进行自增操作，但由于*cp是一个整体，所以先对其本身求值，也就是4，然后我们复制一份拷贝，将运算结束后的新值5保存进去。所以对于字符串的操作，如果使用*++string,会漏掉首字符，所以用*string++可以方便对字符串进行遍历。 (*cp)++，如果不通过括号，我们要表达的就是*cp++，也就是*(cp++)，在这里我们就是先对cp进行间接引用取得ab保存的值，然后进行后置自增运算。 ++*++cp，根据操作符优先级，它的意思就是(++(*(++cp))),由于(*++cp)，我们知道作为右值是对ab的下一块空间的位置的间接引用，再对那个保存的未知值进行前置自增运算，但作为左值它是不合法的，因为自增后新值保存的那块空间位置不明确。 ++*cp++,根据前面的经验，我们可以知道它相当于((++(*(cp++)))),而*cp++作为右值相当于指向ab，进行间接访问的值为4,对其进行前置递增运算，并将拷贝计算的新值保存到一个新的位置，因为那个位置不明确，所以不能作为一个合法的左值。 通过上面的分析，我们发现，优先级上最后进行自增(自减)运算的不能作为一个左值使用，而取址操作符&amp;也一样，因为它们产生的新的值(不是地址值)会被保存到一个新的未知空间，所以不能作为左值使用。我们也发现”指针 +/- 整数”,只能作为右值，实质就是对里面保存的地址值的运算 #define、typedef和指针C语言里，typedef是一个很不错的机制，他可以给数据类型定义新的名字，和使用#define重定义常量的用法很像，但要注意的是，#define没办法很好的处理指针类型，例如12#define char_pointer char*char_point a,b; 那么其中的b就不能被正确的声明为一个指向字符的指针类型，而用typedef就不一样了，例如：123char *char_pointer; //声明一个指向字符的指针类型typedef char *char_pointer; //把char_pointer作为指向字符的指针的新名字char_pointer a; //声明a是一个指向字符的指针 就可以很好的用来处理指针类型。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看得见的与看不见的]]></title>
    <url>%2F2018%2F06%2F06%2F%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E4%B8%8E%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论摄影与摄像]]></title>
    <url>%2F2018%2F05%2F29%2F%E8%AE%BA%E6%91%84%E5%BD%B1%E4%B8%8E%E6%91%84%E5%83%8F%2F</url>
    <content type="text"><![CDATA[摄影和摄像这样的方式是一种很不错的媒介，可以表达简单的内容，也可以表达丰富的内涵，使它包含的信息量进一步增加，但也增加了理解的门槛，而不同的摄像摄像手法，我认为本质上是你是否将他们作为你表达信息的一种手段，可能有些更有利于表达你的想法，所以你会选取这样的手法，或者进行组合，当然你也可以选择创新新的形势，使得你要表达的想法（信息）更有效率的传播出去，而你的作品的主要受众是哪些，决定了你需要取舍不同的“方式“，使得他们能理解你的“信息”，从而达到情绪上的共鸣。]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2F2018%2F05%2F19%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ls命令用来显示目标列表或者目录内容，常用的可选参数有： -a 显示所有子目录和文件，包括隐藏文件 -l 显示文件的详细信息，可以把ls -l简写为ll cp/mv命令用来把一个文件或者多个文件复制/移动到目标目录 rm命令刪除一个目录中的一个或多个文件或目录，其中需要注意的参数有： -f 不需要确认删除多个文件，强制删除 -r 将文件的全部目录和子目录都删除 cat命令可以显示文件内容，也可以连接两个或者多个文件 which命令显示文件的所在路径 man命令用于查看Linux中的命令帮助信息，遇到不会的命令就man一下，它也有一些参数需要注意： -a 在所有的man帮助手册中搜索； -f 等价于whatis指令，显示给定关键字的简短描述信息； ps命令ps命令列出执行这个命令时刻时的那些进程，类似一个当前进程的快照，是最基本也是最强大的进程查看命令，需要注意的参数有： a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 -au 显示较为详细的信息 tar命令很常用的压缩&amp;&amp;解压命令了，但tar这个命令….参数是真的多，看到一种不错的记忆方法，只要记得参数是【必选+自选+f】即可，首先是必选参数，五选一： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 然后是自选参数，必选的话只能选一个，而可以根据需要挑着选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 最后一个参数一定要是f，后面再跟上你要压缩或者解压的文件包名。 一般我们常用的解压方式就是： *.tar -&gt; tar -xf *.tar.gz -&gt; tar -xzf *.tar.bz2 -&gt; tar -xjf *.tar.Z -&gt; tar -xZf *.gz -&gt; gzip -d *.rar -&gt; `unrar e *.zip -&gt; unzip kill命令用于终止指定进程的运行，对于后台进程我们可以先通过ps/pidof/pstree/top等命令获取进程PID，然后用kill结束该进程。不过也可以使用killall命令，直接使用进程的名称结束进程，使用它可以结束一组同名进程，而不用先获取进程PID，killall相当于把这两个过程合二为一，是一个很好用的命令 head命令可以用来查看一个文件的前几行，可以配合其他命令使用，例如配合管道做grep tail命令tail命令和head相反，查看文件的最后几行。不过最常用的还是加上 “-f” 参数后和grep一起使用 grep命令一个极其强大的命令，常用来在很多数据中找到匹配某一模式的字段，可以是正则表达式，常用的几个参数有： -a 以文本文件方式搜索 -c 计算找到的符合行的次数 -i 忽略大小写 -n 顺便输出行号 -v 反向选择，查找没有搜索字符串的行 du命令du命令是对文件和目录磁盘使用空间的查看 top命令用于动态的显示进程的信息，不过也有可以自定义的形式，例如:top -u root可以用来查看某用户进程 find命令查找所需文件的命令，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，常用的参数有： -type 只寻找符合指定的文件类型的文件,其后跟随指定文件类型参数，类型参数有 f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p FIFO -name 根据文件名查找 -size 根据文件的权限或者大小名字类型进行查找 -mtime 查找在指定时间曾被更改过的文件或目录，单位以24小时计算； -print 假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出 -exec 假设find指令的回传值为True，就执行其后跟着的指令 cmp命令用来比较两个文件的差异。如果两个文件完全一样，就不会显示任何信息。如果发现有差异，会标示出第一个不同之处的字符和列数编号。 touch命令修改文件的创建日期，或者以当前的系统日期创建一个空文件 date命令显示当前日期和时间的，可以通过一些参数进行日期的格式化： %Y year %m month (01~12) %d day of month %H hour (00~23) %I hour (01~12) %M minute (00~59) %S second (00~60)例如：1234date + &quot;%Y%m%d %H%M%S&quot;20180519 223856date + &quot;%Y-%m-%d %H:%M:%S&quot;2018-05-19 22:39:07 wc命令统计指定文件中的字节数、字数、行数，并将统计结果输出，需要了解的参数有： -c 统计字节数 -l 统计行数 -m 统计字符数，不能与-c参数一起使用 -w 统计字数 env/export命令env: 查看当前环境变量 类似于配置Python环境，在一台不熟悉的机器上，如果出现了配置问题，可以通过env命令查看shell下的所有环境配置，看一下路径是否正确。 export: 设置或显示环境变量 useradd命令useradd命令用于创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。其中有几个需要注意的参数： -e 指定帐号的有效期限 -g 指定用户所属的群组 -G 指定用户所属的附加群组 -r 建立系统帐号 -u 指定用户id，设定ID值时尽量要大于500，以免冲突 groupadd命令用于创建一个新的工作组，也可以用groupdel命令删除工作组，常用的参数有： -g 指定新建工作组的id -r 创建系统工作组，系统工作组的组ID小于500 curl/wget命令curl命令是一个利用URL规则在命令行下工作的文件传输工具,而wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。 netstat命令用来显示网络系统的状态信息，可让你了解整个系统的网络情况，需要注意的参数有： -a 显示所有连线中的Socket -n 直接使用ip地址，而不通过域名服务器 -t 显示TCP传输协议的连线状况 -u 显示UDP传输协议的连线状况 -l 显示监控中的服务器的Socket -s 显示网络工作信息统计表 -n 直接使用ip地址，而不通过域名服务器 可以通过参数的组合实现不同的功能，例如1234567netstat -at #列出所有tcp端口netstat -au #列出所有udp端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -st #显示TCP端口的统计信息netstat -su #显示UDP端口的统计信息netstat -an | grep &apos;:80&apos; #找出运行在指定端口的进程]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匠人的情怀]]></title>
    <url>%2F2018%2F05%2F11%2F%E5%8C%A0%E4%BA%BA%E7%9A%84%E6%83%85%E6%80%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google实用搜索技巧]]></title>
    <url>%2F2018%2F04%2F20%2FGoogle%E5%AE%9E%E7%94%A8%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[善用搜索引擎的都是信息时代的富翁，不懂搜索引擎的都是信息时代的负翁。 完整匹配在Google的搜索框里，所有的空格都会被视为”+”号，可能对于用惯了百度的人很好理解，因为我们要搜啥时，肯定是搜索关键词，加了空格就相当于多个并列的关键词，那搜索结果就会把所有包含相关关键词的内容都全部罗列出来。 对于搜索一个具体的问题，例如一句描述问题的话，在中文里基本是没空格的，但我们使用Google时更多是用的英文，当我们搜索英文关键词是没问题的，但当你使用英文描述一个具体问题时，就需要在搜索字段的前后加上引号，无论是全角字符（ “ 或者 ” ）还是半角字符（ “ ），Google都能正确处理，这就是完整匹配。 筛选过滤为了进一步筛选搜索结果，我们可以使用” - “操作符，如&quot;mysql connect error&quot; - &quot;nodejs&quot;就要求Google返回含有mysql connect error但不包括nodejs的文章。当然，中文搜索也是适用的。 也可以使用”+”操作符，因为Google会忽略和过滤一些常用的英文词汇，例如and，how之类的，使用”+”操作符可以让搜索引擎强制包括它们，也可以强制过滤掉关键词的一些特定时态形式。 通配符其实就是我们熟知的符号“*”，举个例子，当我们搜索 “mysql connect error *” Google就会返回所有已知的关于MySQL连接错误的文章。 其他操作符我们熟知常用的一些操作符，可以在Google里使用，辅助完成一些特定搜索，例如： ~ 关键词前加上它，可以显示同义词 | 作用和OR一样 .. 用来限定数值的范围，例如2015..2018 站内搜索可以根据特定的网站，搜索对应网站内所有相关内容，例如：&quot;mysql connect error&quot; site:stackoverflow.com就会返回Stackoverflow内所有关于MySQL连接错误的文章。 搜索指定文件格式我们可以搜索特定的文件格式，不过一些文件类型是不支持的，但日常用来搜索一些PDF资源或者搜索特定图片格式是很方便的，只需要加上filetype: + 特定格式，就可以了。不过对于图片搜索，我们还可以限定搜索的图片尺寸，加上imagesize:，例如：imagesize:500x500 搜索相似网页通过related:这个关键字搜索到相关相仿的网页或相关页面，例如：related:www.taobao.com 关闭安全搜索最直接简便的方法就是在搜索网址时附加一个参数：&amp;safe=off]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪辑的艺术]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%89%AA%E8%BE%91%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于碎片化阅读的思考]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%85%B3%E4%BA%8E%E7%A2%8E%E7%89%87%E5%8C%96%E9%98%85%E8%AF%BB%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[碎片化阅读需要我们学会汲取，汲取内容中能够启发我们个人知识体系里的那部分内容，它是对个人知识体系里经验的辅助理解和加深感悟，同时也是对其的修正。这些零散的观点犹如树叶，需要我们来筛选补全以致形成一颗郁郁葱葱的参天之木。但我们本身需要”树干“，若没有树干的依托，也就是个人基本的知识体系作为基点，这些碎片的观点和讯息只会成为一种负担，因为我们无法作出取舍，但营造这棵树本身也存在一定问题，就是我们是否会由于个人的某种价值取向而自动过滤掉那些违背我们价值观，世界观的讯息，因为他们的存在是对树的一部分的否定，这样容易使我们一条道走到黑，也让我们以后更难以听取那些反对的声音。如何能够客观的来权衡汲取碎片化的内容是一个值得权衡深思的问题。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小记]]></title>
    <url>%2F2018%2F03%2F16%2FGit%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常用命令设置和配置 git config12345678git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on git 创建和获取项目 git init初始化本地git仓库（创建新仓库） git cloneclone远程仓库 快照 git add应该理解为“添加内容到下一次提交中更合适” 12git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至index git commit 123git commit -m &apos;xxx&apos; # 提交并键入提交信息git commit --amend -m &apos;xxx&apos; # 重新尝试提交，合并上一次的提交，用于反复修改git commit -am &apos;xxx&apos; # 将add和commit合为一步 git diffgit diff本身并不会显示出自上一次提交以来所有的变更，而只会显示出还没有进入暂存区的那些变更，如果所有变更已经进入暂存区，git diff不会有任何输出。 1234567git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff --staged # 将暂存的变更与上一次提交相比较git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git rm 12git rm xxx # 删除index中的文件git rm -r * # 递归删除 git mv 1git mv README README2 # 重命名文件README为README2 git status用来查看当前文件状态，查看是否进行了修改 1git status -s # 更为紧凑的形式查看变更 分支与合并 git log 123456git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log --stat # 查看每个提交的简要统计信息git log -p -2 # 显示出最近两次提交所引入的差异git log v1.0 # 显示v1.0的日志git log --pretty=format:&apos;%h %s&apos; --graph # 更改日志输出默认格式，其结果不会随着Git软件版本更新而改变 git tag 12git tag # 显示已存在的taggit tag -a v1.0 -m &apos;xxx&apos; # 增加v1.0的tag git branch列出你所拥有的分支、创建的新分支、删除分支以及重命名分支 123456789git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git checkout切换分支并将内容检出到工作目录 1234567git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v1.0 # 检出版本v1.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退） git merge用于将一个或多个分支合并，然后将合并的分支作为当前分支 1git merge origin/master # 合并远程master分支至当前分支 git stash 123git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存 项目共享和更新 git remote用来查看已经设置了哪些远程仓库，然后列出每个远程仓库的简短名称，也可以用来管理远程仓库记录，将一段很冗杂的URL地址保存成一个简单的字符串句柄，比如origin，方便操作 1git remote add &lt;name&gt; &lt;url&gt; # 增加远程定义（用于push/pull/fetch） git push与其他仓库通信，确定本地内容和远程仓库异同，然后将差异推送到其他仓库 123git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有服务器上还没有的标记都推送过去 git fetch 123git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git fetch origin # 与服务器同步 git pull可以理解为git fetch和git merge的组合，先从远程仓库获取内容，再尝试合并进你所在分支 1git pull origin master # 获取远程分支master并merge到当前分支 git reset 1git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） 检视和比较 git show能够以简单易读的形式显示Git对象，通常用来显示标签或提交的相关信息 12345678git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git show v1.0 # 显示v1.0的日志及详细内容git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git show HEAD~3git show -s --pretty=raw 2be7fcb476 git ls-files 1git ls-files # 列出git index包含的文件 git show-branch 12git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史 调试 git grep可以帮助你在源代码的所有文件中找到任意字符串12git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e &apos;#define&apos; --and -e SORT_DIRENT 打补丁 git cherry-pick 1git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git rebase基本上就是一个自动化的git cherry-pick命令，它确定一系列提交，然后在别处以相同的顺序逐个对其挑拣。不要对已经存在于本地仓库之外的提交执行rebase操作。 git revert与git cherry-pick命令的效果恰好相反，将变更撤销或还原 1git revert dfb02e6e4f2f7b # 撤销提交dfb02e6e4f2f7b 管理 git reflog显示所有提交，包括孤立节点 git gc执行”垃圾回收“，删除无用文件，将余下的文件打包成一种更有效的形式 git fsck用于检查内部数据库存在的问题或不一致性 Git使用规范流程 在团队开发中，遵循一个合理、清晰的规范是很重要的，例如Git,如果每个人都很随意的提交一堆commit，项目很快就会变得难以维护和管理了，所以需要规范化这个流程。 一、新建分支每次开发一个新的功能，我们都应该新建一个单独的分支123456# 获取最新代码git checkout mastergit pull# 新建一个开发分支git checkout mybranch 二、提交分支分支修改后，就可以提交了123git add .git statusgit commit 三、撰写提交信息提交commit时，必须要简洁明了的叙述提交的信息，可以参考这个例子：123456简要的变更汇总，然后空一行（不超过50个字符），如果有必要，就要附加更详细的说明，每行长度限制在72个字符左右。- 通常使用连字符或者星号作为条目符号- 改动原因- 主要变动- 需要注意的问题 四、与主分支同步开发的过程中要时常与主分支保持同步12git fetch origingit rebase origin/master 五、合并开发完成后，我们需要把一堆commit合并到主分支关于合并多个commit,可以看这篇文章：「Git」合并多个 Commit不过也有一种简洁的合并方式,就是先撤销过去5个commit，然后再建一个新的：1234git reset HEAD~5git add .git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;git push --force 六、推送远程仓库1git push --force origin myfeature 之所以要加上 force 参数，是因为 rebase 后，分支历史改变引起的远程分支不兼容问题 七、发出Pull Request提交完毕后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review ，确认是否可以合并到 master 分支。 Git工作流主流工作流 Git Flow GitHub Flow GitLab Flow Git FlowGit Flow 是最早诞生、并得到广泛采用的一种工作流程。 Git Flow 存在两个长期分支，分别是主分支 master 和开发分支 develop ，前者是对外发布的稳定版本，后者相当于测试开发版，用于日常开发使用。 Git Flow还有三个协助分支，分别是功能分支（分模块功能开发）、补丁分支（线上的紧急 bug 修复）、和预发分支（版本发布的预发布），分别对应不同的业务需求，一旦开发完成，它们会先合并进开发分支，再合并进主分支，或者直接并入主分支。 Git Flow的优点在于直观明了，易于控制，但需要维护两个长期分支，需要频繁切换，而且这个模式更多基于“版本发布”的，对于一些“持续发布”的项目，两个长期分支的区别就不大，没必要都维护。 GitHub FlowGitHub Flow 作为 Github 所使用的工作流，其目的也是专门为了配合“持续发布”的。它只有一个长期分支，就是我们所熟知的 master 分支，团队成员们的分支代码通过 Pull Request 来合并到 master 上。 我们通过从 mater 上拉出新的分支，当开发完成时，就发起一个Pull Request，然后会审核你的代码，如果被接受就可以合并进 master 分支。 不过由于它只有一个主分支，所以如果你的开发时间很长，主分支就会与你得分支版本不一致，而你不得不专门建一个分支跟踪线上的新版本。 GitLab FlowGitlab flow 吸取了 Git flow 与 Github flow 的优点。既有适应不同开发环境的弹性，又有单一主分支的简单和便利。 对于”持续发布”的项目，建议在 master 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 master ，”预发环境”的分支是 pre-production ，”生产环境”的分支是 production 。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。只有上游没有问题，才能发布到下游，除非是紧急情况，才能直接合并到下游分支。 对于”版本发布”的项目，都要从 master 分支拉出一个分支，比如1-3-stable、1-4-stable等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。 Git代码规范具体可以看一下这篇文章：Git Style Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非“你”不可]]></title>
    <url>%2F2018%2F02%2F16%2F%E9%9D%9E%E2%80%9C%E4%BD%A0%E2%80%9D%E4%B8%8D%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的字符串拼接技巧汇总]]></title>
    <url>%2F2018%2F01%2F24%2FPython%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Python里的字符串拼接方式有好几种，我们最熟知的可能是利用加号连接或是通过join函数连接，其实在Python里还存在了一些字符串拼接的方法，使用得当，可以有效提高我们的效率，这里作一个小的总结。 利用加号拼接入门模式，利用+字符连接字符串，实现字符串的拼接，实则是操作符的重载。如果是数据量不大的字符串拼接，推荐使用它。1234&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; a + b'hello, world!' 利用join()拼接字符串的内置方法里有一个join()，通过这个方法也可以实现字符串的拼接。但join的参数是数组或者元组之类的序列类型。如果要拼接大量字符串推荐使用它，而不是+。1234&gt;&gt;&gt; a = "*"&gt;&gt;&gt; b = ['a','b','c']&gt;&gt;&gt; a.join(b)'a*b*c' 直接拼接在Python中，连续的字符串会拼接为一个字符串12&gt;&gt;&gt; print("hello, " "world!")hello, world! 利用逗号拼接1234567&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; c = 4&gt;&gt;&gt; print(a,b)hello, world!&gt;&gt;&gt; print(a,c)hello, 4 逗号操作符可以把两个变量的值进行拼接，不过只能用于print打印里。 格式化字符串可以通过格式化字符串的方式，进行字符串的拼接，而格式化字符串可以通过%操作符，也可以通过format()函数。12&gt;&gt;&gt; print('%s %s' % ('hello, ', 'world!'))hello, world! format()方法可以非常方便地连接不同类型的变量或内容12&gt;&gt;&gt; "&#123;&#125; &#123;&#125;".format("hello, ", "world!")'hello, world!' Python3.6中引入了字面量格式化字符串，简称f-string，用法和%、format()类似,但它的可读性比使用+号更好，当我们要拼接大量数据内容，例如像key:value类型的字段时，推荐使用f-string,它的性能也更好。1234&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; f"&#123;a&#125; &#123;b&#125;"'hello, world!']]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“视界”]]></title>
    <url>%2F2018%2F01%2F12%2F%E2%80%9C%E8%A7%86%E7%95%8C%E2%80%9D%2F</url>
    <content type="text"><![CDATA[未理解一件事物之前，不要轻信他人的判断和所谓的“权威”，没有一种思想是完美的，不同的文明，诞生了不同的思想，东方的思想不能因为它历史悠久而认为更好，西方思想也不一定代表着先进，不同的情境适用于不同的“智慧”，尤其是全球化的今天，文化的边界在逐步融合，人与人之间日趋包容，新事物新潮流在当前的社会接受度不断加快，即使是老一辈人也在不断地一点点接受新的变化，例如移动支付，其间借助于这些新的形式，也诞生了许许多多的问题，借助这类门槛去做一些游走于法律灰色地带的事谋取暴利也不很多，但我们也知道，每一个时代的背景下都会有所谓的“新事物”，新的形式也不断地在它的推进中逐步获得人们的认可。 凡所已有之事，必有其存在的价值，我们可以学不断地修正我们对事物的判断，去吸取一些有益的东西，不同的文化，不同的思想，不同人对事物的看法。 于一个地域一个地域的不断“争渡”，去体会不懂地缘文化的差异，对人的影响，感受不同的风土，去吸收而非同化那些有益的东西，南方与北方，沿海与内陆，国内与国外，去体验人世种种，不断地学习，修自身之道，如合气道一般，不同人最终所修的合气道都是不同的，和个体之间的差异和经历都有关，此为变化之道，也代表了无限的可能，是一种预兆，更是天命所在。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python中__str__和__repr__的区别]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%85%B3%E4%BA%8EPython%E4%B8%AD-str-%E5%92%8C-repr-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[__repr__和__str__这两个方法都是用于显示的，但实际却存在一些细微的差异，具体我们可以通过一个简单例子来比较一下它们之间有何不同。 123456789101112class Hello(object): pass&gt;&gt;&gt; a = Hello()&gt;&gt;&gt; a&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(a)&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(str(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(repr(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt; 这里我们想要打印类对象，但显示的确是对象的内存地址，而且无论通过__repr__或是__str__,结果都一样，下面我们重写一下这个类的__repr__方法： 12345678910111213class Hello(object): def __repr__(object): return 'hello'&gt;&gt;&gt; b = Hello()&gt;&gt;&gt; bhello&gt;&gt;&gt; print(b)hello&gt;&gt;&gt; print(str(b))hello&gt;&gt;&gt; print(repr(b))hello 然后我们就会发现无论输出对象，还是调用__repr__和__str__方法，甚至通过print()方法，打印的信息都是按我们__repr__方法中定义的格式进行显示的。现在我们重写一下__str__： 12345678910111213class Hello(object): def __str__(object): return 'hello'&gt;&gt;&gt; c = Hello()&gt;&gt;&gt; c&lt;__main__.Hello object at 0x000001DE00450CC0&gt;&gt;&gt;&gt; print(c)hello&gt;&gt;&gt; print(str(c))hello&gt;&gt;&gt; print(repr(c))&lt;__main__.Hello object at 0x000001DE00450CC0&gt; 现在就很直观了，直接输出对象c时，显示出来的依旧是它的内存地址，而当我们调用print方法时，就会按我们定义的格式输出信息。因为我们覆盖了先前的__repr__方法，即使没有提前覆盖__repr__方法，我们得出的结果依然也是一样的。 总结一下，__repr__和__str__这两个方法都是用于显示的，但__str__更适用于用户，而__repr__更适用于开发人员 打印操作会首先尝试__str__和str内置函数（print运行的内部等价形式），它通常应该返回一个友好的显示 __repr__用于所有其他的环境中，例如交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str，它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F01%2F05%2FMarkdown%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[标题 如果你需要插入标题，可以在行首插入1到6个#，对应标题的1到6级,最高可以到六级标题，最好在#后加一个空格，例如:# 这是一级标题## 这是二级标题####### 这是六级标题 也可以使用=====表示高级标题，使用------表示次级标题，大于两个=,-都可以用来表示标题 引用如果你需要一个引用，那么你可以使用&gt;符号放在文字开头，例如:&gt;这是一个引用引用是可以嵌套的，同时引用的区块内部也可以使用其他的Markdown语法，例如 这是一个引用 这是一个嵌套引用 这是二级标题 列表项 列表项 列表如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种形式，列表本身也是可以嵌套，例如 列表项 列表项 列表项 嵌套列表 嵌套列表 无序列表可以使用*、+、-这三个符号中的任意一种作为列表标记，也可以和引用标记进行嵌套 列表项 列表项 列表项 这是一个嵌套的引用 可以进一步嵌套 字体 粗体: 通常用**或者__表示粗体 斜体: 通常用*或者_表示斜体 斜粗体：通常用***或者___表示斜粗体 链接如果你需要链接文字，可以使用[](link)表示一个链接，其中[]内是需要添加链接的文字，()内是链接的地址 代码 使用一对```表示代码块，可以根据你所使用的Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如： 123public static void main(String[] args) &#123; System.out.println("Hello"); &#125; 使用一对 可以表示一个行内代码，例如： 这是一个Java`代码 图片如果你需要插入一张图片，可以使用![Text](path)，其中Text表示图片无法加载时显示的文字，path为图片所在的路径，也可以是网上的图片链接地址 分割线如果你需要一条分割线，可以使用--- 或者***表示水平分割线，只要-,*大于三个就可以表示水平分割线，使用---作分割线时需要前后都空一行，防止被当成标题的标记方式 删除线如果你需要一条删除线,可以使用一对~~表示删除线，但切记和文字之间不能有空格 表格可以使用以下的格式添加表格,注意表格和文字间空一行：12345| name | age | gender | money ||-------|:---:|-----------|-------:|| rhio | 384 | robot | $3,000 || haroo | .3 | bird | $430 || jedi | ? | undefined | $0 | name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $0 其他如果 Markdwon 的语法达不到预期效果，或者一些地方的处理用 Markdwon 的格式无法实现，可以考虑用 HTML 和 CSS 引用 123&lt;blockquote&gt;***&lt;/blockquote&gt;/* 如果上下间距小，可以这样写 */&lt;p&gt;&lt;blockquote&gt;***&lt;/blockquote&gt;&lt;/p&gt; 居中和右对齐 123456/* 居中 */&lt;center&gt;**&lt;/center&gt;/* 右对齐 */&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;/* 右对齐 */&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt; 字体大小和颜色 1&lt;font color="#xxxxxx" size="number"&gt;**&lt;/font&gt; 分割线和空行 12&lt;hr /&gt;&lt;br /&gt; 关于Markdown的更多细节，可以参看：Markdown 语法说明 (简体中文版)，对于Markdown的规范，可以看一下 ：Google Markdown Style Guide 或者 Markdown Style Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使自己看起来更Pythonic]]></title>
    <url>%2F2017%2F12%2F21%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E8%87%AA%E5%B7%B1%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4Pythonic%2F</url>
    <content type="text"><![CDATA[Python这门语言语法很简洁，如果具备其他语言的基础，学习它会很快，但我们可能写出的代码不那么Pythonic，尽管它也能运行，但我们没办法充分发挥这门语言的特性，简化很多不必要的操作，以提高自己的效率。 关于for循环我们使用for循环其实出发点可能是为了遍历一个序列然后提取有用的信息，又或者单纯为了循环一个操作，在其他语言里，我们达到类似的目的确实只能通过循环完成，例如 Java：12345for(int i=0; i&lt;10; i++) &#123; if(i%2==0)&#123; System.out.println(i); &#125;&#125; 在Python里自然也可以写出类似的代码: 123for i in range(10): if i % 2 == 0: print(i) 如果代码逻辑更为复杂些，里面可能就要嵌套一堆if/else的判断，如果再加上try/catch代码块，那代码会变得很长，而且阅读性很差，那么Pythonic的写法是什么呢：1print([i for i in range(10) if i%2==0]) 通过列表推导式，一行代码就解决了，而且逻辑很清晰。 变量交换在其他语言实现变量交换很麻烦，往往要通过引入第三方变量作为桥梁进行变量交换，像这样123tmp = a;a = b;b = tmp; 虽然Python也可以用这样的方式，但这很不Pythonic，我们可以这样，一行代码即可，很方便。1a, b = b, a 字符串拼接关于Python里的字符串拼接，可以看一下这篇总结： Python中的字符串拼接技巧汇总 ，很多都是Python里才有的方式，可以让你的代码看起来更加Pythonic。 文件资源管理关于文件资源的打开和关闭传统的方式是这样的：12345f = open('*.txt')try: data = f.read()finally: f.close() Python提供了更为简便的操作，通过with关键字动态的打开关闭资源：12with open('*.txt') as f: data = f.read() 赋值Python自带了许多很方便的容器类型，例如：元组，列表和字典，当我们要把容器中的值取出来赋值给变量，可能我们会想到通过遍历这些容器类型，调用相关的方法取出值，然后赋值给变量，但那很不Pythonic，就拿元组来说，我们可以通过元组拆包的形式，使用很简短的代码，来为变量赋值。123456789101112&gt;&gt;&gt; result = (1, 3, 5, 7, 9)&gt;&gt;&gt; a,b,c,d,e = result&gt;&gt;&gt; a1&gt;&gt;&gt; b3&gt;&gt;&gt; c5&gt;&gt;&gt; d7&gt;&gt;&gt; e9 Python之禅如果你看过Python之禅，就会理解这门语言的设计哲学，而Python的代码风格也应该向这个目标靠近。 1234567891011121314151617181920212223242526272829303132333435363738394041&gt;&gt;&gt; import thisThe Zen of Python, by Tim Peters#优美胜过丑陋。Beautiful is better than ugly.#显示胜过隐式。Explicit is better than implicit.#简单胜过复杂。Simple is better than complex.#复杂胜过繁复。Complex is better than complicated.#串行胜过嵌套。Flat is better than nested.#稀疏胜过稠密。Sparse is better than dense.#可读性很重要。Readability counts.#虽然理想很丰满，现实很骨感，但是所谓特例并不足以打破上面的这些规则。Special cases aren&apos;t special enough to break the rules. Although practicality beats purity.#所有错误都不应该被直接忽略，除非能够被精确的捕获之后。Errors should never pass silently. Unless explicitly silenced.#当面对不明确的情况时，要拒绝去猜测的诱惑。应该有一种，最好是唯一一种，显而易见的解决方案。尽管起初，那种解决方案可能并不是那么显而易见，因为你不是Python之父——DutchIn the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch.#现在行动胜过永不开始。尽管，永不开始经常好过冲动的开始。Now is better than never. Although never is often better than right now.#如果你的实现难于向别人解释，这往往不是个好主意。如果你的实现很容易向别人解释，这可能是个好主意。If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea.#命名空间是一个令人激动的伟大想法，让我们将它发扬光大。Namespaces are one honking great idea -- let&apos;s do more of those! 这里推荐两本书，如果你Python已经入门，希望进阶，并想写出更为Pythonic的代码，提高开发效率，可以看下《流畅的Python》 、 《Python Cookbook》 关于Python的代码风格可以看一下： Python 风格指南]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表解析的效率问题]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在列表，字典，集合中根据条件筛选数据 列表 filter 1filter(lambda x:x &gt; 20,data) 列表解析 字典 字典解析1&#123;for k,v in d.interitems() if v &gt;= 20&#125; 集合 集合解析1&#123;x for x in s if x % 2 == 0&#125; 注意：列表解析也可能会被滥用，例如使用列表解析重复获取一个函数等。所以并非一味地使用列表解析式就是好的。 原则：尽量保持其简洁，列表解析的代码不要超过两行以上，只用它来创建新的列表，否则的话还是考虑使用for循环来重写。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>

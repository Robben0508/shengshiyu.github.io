<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Electron+Vue的使用]]></title>
    <url>%2Fposts%2F602f3ad5%2F</url>
    <content type="text"><![CDATA[关于Electron使用Electron可以很方便的创建跨平台桌面端的Web程序，而提到Electron就不得不提到Node.js,因为Electron用Node做后台，只要你需要通过Electron来访问网络或是硬盘，就得依靠Node，而Electron也使用Node来管理依赖项，你只需要使用npm install命令便可很方便的为你的Electron添加不同的依赖库。 所以创建一个Electron项目的第一步便是安装Node的环境，无论你是macOS还是Windows，比较简单的方式便是使用Node官网提供的安装包，你只需要去下载相应版本的安装包即可，建议安装LTS版本，下载好后根据安装向导完成安装便完成安装了。 如果你需要下载特定版本的Node.js，可以在官网下方找到Node的所有历史版本，根据需要下载即可。 创建第一个Electron程序在Electron官网上我们可以通过其electron-quick-start项目来作为基础进行构建，通过： 12345678# 克隆示例项目的仓库$ git clone https://github.com/electron/electron-quick-start# 进入这个仓库$ cd electron-quick-start# 安装依赖并运行$ npm install &amp;&amp; npm star 然后我们就可以通过npm start来启动我们的electron项目了！ 上手Vue,搭建Vue环境搭建Vue的开发环境我们需要用到Vue的脚手架工具vue-cli，由于vue-cli2.X版本要淘汰了，所以我们需要使用vue-cli3.0及其以上的版本进行项目的创建，2.X的vue-cli你只需要通过npm install -g vue-cli命令即可安装，但3.0及其以上版本的vue-cli你只能通过npm install -g @vue/cli，注意，它的库的名字改为了@vue/cli，然后我们就可以开始使用vue-cli创建一个Vue项目了，运行如下命令 1vue create my-first-demo 根据需要选择相应配置，完成如图： 然后进入项目目录，通过 12cd my-first-demonpm run serve // 如果是yarn的话，就是yarn serve 启动后如图： 可以通过执行命令 1npm run build 来对项目进行构建生成，完成后项目目录下会生成一个dist文件夹。 项目文件结构如图： 引入Electron在Vue项目中引入Electron的方式有很多，我们可以直接执行命令npm install electron来安装Electron，然后通过在dist文件夹内创建主程序的入口文件main.js和相关配置文件package.json的方式来引入electron。 可以参考：手把手教Electron+vue的使用 当然也可以通过脚手架工具，例如electron-vue，或者通过Vue插件Vue CLI Plugin Electron Builder 来实现，考虑到electron-vue这个脚手架工具很久没更新了，其中的electron版本还是2.X的，还得手动替换很多东西，不是很方便，但感兴趣的同学可以参考他的官方文档，这里我们使用Vue CLI Plugin Electron Builder。 注意，如果你的vue-cli还是2.X版本的话，你需要卸载它，然后安装3.X以上的版本进行创建，否则你是使用不了Vue CLI Plugin Electron Builder的。 首先，我们先进入之前建立好的Vue项目，然后按以下命令安装并调用vue-cli-plugin-electron-builder的生成器： 12cd my-first-demovue add electron-builder 注意，期间根据你的情况选择相应electron版本，这里我选择的是electron5.0的版本，根据你本地的Node.js版本你可以选择更高版本。 安装好后可以打开package.js文件可以发现electron已经成功引入 接下来我们通过运行命令，来让我们的项目跑起来 1npm run electron:serve 如图所示，一个简单的Electron程序就成功运行起来了 打开之前的项目目录，可以看到项目目录下多了一个dis_electron文件夹，其中也有一个package.json文件，指定在src目录下background.js为Electron入口文件，其作用和之前手动添加main.js和package.json的方式一样。 下面我们通过构建命令： 1npm run electron:build 完成后在dist_electron文件夹下就可以看到我们生成的Windows平台的安装程序 如果需要生成macOS或是Linux平台的安装包，可以阅读electron的官方文档，获取更进一步的详细配置。 注意，可能在过程中由于网络问题，我们可能会构建失败，所需要的依赖文件可以通过以下几个办法来解决。 1.设置淘宝镜像 1npm set ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/ 设置好后所需要的依赖文件就应该可以下载好了 2.手动添加 如果设置淘宝镜像还是不行的话可以在 https://npm.taobao.org/mirrors/electron 中找到提示中你所需的对应版本的文件，当然还有几个文件需要我们前往对应网站去下载对应版本的包才行 winCodeSign nsis nsis-resources 下载对应文件后，解压到C:\Users\你的用户名\AppData\Local\electron\Cache中，或是C:\Users\Administrator\AppData\Local\electron-builder\cache下的不同的依赖文件夹里，根据所需版本在里面创建新的文件夹,文件夹名字需要和npm run build里要求下载的文件名一致，例如 nsis-resources-3.3.0 后面的版本要对应上。 完成上述配置后，再次运行npm run electron:build便不会再报错。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新思想和旧思想]]></title>
    <url>%2Fposts%2F514198ec%2F</url>
    <content type="text"><![CDATA[知识的条条框框束缚住了你那想纷飞的思想翅膀，你的一切想法都将围绕着“我知道”“我很清楚”“社会原本就是这样的嘛！”打转。一旦这种“我什么都懂”的思想进驻到你的心里，那你就很有可能会失去了解事情真实面目的兴趣，而没有了这种兴趣，你就会丧失前进的动力，那么等待你的就只剩下百无聊赖的空虚日子了。 新的“新思想”和旧的“新思想”，“新”不一定就代表了一种进步和对旧有事物的否定，旧的思想中可能蕴含着一些我们未充分认识的创新点，一旦机会成熟，旧有的思想就会成为一种潮流，至少在我看来，设计就是一个这样的过程，旧有的设计理念和一些新的“新思想”结合，却能成为一种潮流。 我们的认知观念里总认为旧有的东西就是落后的，就应该被淘汰的，因为有了继承于它的更好的方式，但那或许仅仅是继承原有的一个点，新旧本身并不应该作为衡量价值的标准。就像销量高的产品并不一定就代表质量好一样，人类总是倾向于接受和他们内心认知看法接近的事物，因为它们不必为此否定自身，就像我们的新闻一样，我们很难看到相悖的两种形式的新闻。 “主流”的思想将一些“异端”思想给排斥在外，但更多时候我们会发现，两种相悖的观点事实上它们都是正确的，不同的环境，不同的时代背景，不同的利用和转化方式，都可以作为我们评判一种思想是否具有价值的参考条件。 成长的过程，就是我们不断地发现过去家长、老师们教的某些东西开始具有了“片面性”，随着我们对其更深入全面的了解，随着我们阅历的加深，我们会衍生出自己的一套价值判断标准，但我们也会无意识地将与自身观点相悖的思想排斥在外，以维护我们自身观点的“正确性”，尤其是随着我们年龄的增长，我们更原意接受符合我们价值判断标准的事。 当我们摒弃了新旧思想之争，从全新的角度出发，去发现不同观点背后存在的可能性，勇于接受它们，判断哪一种更符合时代的发展的某种需要，哪一种更适合自身，去理解“变化”本身，避免使自己陷入思维的死角，找到在不同情境下最适宜的技巧。那么旧思想也可以成为”新的旧思想“，它也会有机会在如今的时代里绽放不一样的光芒。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Spring Bean的生命周期和作用域]]></title>
    <url>%2Fposts%2Ffbb6f1be%2F</url>
    <content type="text"><![CDATA[在 Spring 中，Bean 就是由 IOC 容器初始化、装配并管理的对象，它的生命周期由 Spring 控制，这个过程称为 Spring 中 Bean 对象的生命周期管理。 Spring Bean 的作用域Singleton默认的作用域，单例模式，仅仅为每一个 Bean 对象创建一个实例，在 Spring IOC 容器中也只会存在一个共享的Bean实例。 在创建容器时就自动创建了一个 Bean 的对象，不管你是否使用，它都存在，在XML中配置 Bean 为 singleton ：1&lt;bean id="ServiceImpl" class="cn.shengshiyu.service.ServiceImpl" scope="singleton"&gt; prototype原型模式，可以根据需要为每个 Bean 对象创建多个实例，可以把它理解为一个“模板”，每次我们获取 prototype 定义的Bean都会生成一个新的Bean实例，每一个Bean都有自己的属性和状态。 prototype它在我们创建容器时没有实例化，只有在我们获取bwan时才去创建，在XML中配置和singleleton大同小异，更改一下scope参数即可。 web作用域Request一次HTTP请求，Spring 容器会返回 Bean 的同一实例，仅在当前的请求有效，对于新的 HTTP 请求又会产生新的 Bean，相对其他请求时独立的，当请求结束，这个 Bean 的实例也会被销毁。仅在 web 相关的 ApplicationContext 中生效。 Session一次HTTP会话中，容器会返回Bean的同一实例，不同的会话请求会创建不同的实例，仅在当前会话有效，随着会话结束，实例也会被销毁，和 request 一样，区别仅在于一个是针对一次 request ，而另一个是针对一次 session 。仅在web相关的ApplicationContext中生效。 Global session为每一个全局的HTTP会话创建一个实例，一般仅在porlet上下文中生效。一样仅在web相关的ApplicationContext中生效。 Bean的生命周期Spring容器可以管理singleton作用域下Bean的生命周期，在此作用域下，Spring能够精确地知道Bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的Bean的生命周期。 Bean创建的方式 调用构造器创建 调用静态工厂方法创建 调用实例工厂方法创建 ApplicationContext和BeanFactoryApplicationContext 和 BeanFactory 是 Spring 两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展。 ApplicationContext在ApplicationContext容器中，Bean的生命周期，大致是这样的：不过需要注意，需要根据是否实现了 BeanNameAware、BeanFactoryAware、ApplicationContextAware、BeanPostProcessor、InitializingBean 接口，才能调用它们相应的方法。如果 Bean 配置了 init-method 方法，则会执行 init-method 配置的方法。如果有 Bean 实现了 BeanPostProcessor 接口，则会回调该接口的 postProcessAfterInitialization() 方法。 容器关闭后，如果 Bean 实现了 DisposableBean 接口，则会回调该接口的 destroy() 方法，如果Bean配置了 destroy-method 方法，则会执行 destroy-method 配置的方法，至此，整个Bean的生命周期结束。 BeanFactory在 BeanFactory 容器中，Bean 的生命周期和 ApplicationContext 下的 Bean 周期差不多，只不过 BeanFactory 容器启动的时候，不会去实例化所有 Bean，而是在调用的时候去实例化，如图所示：]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP浅析]]></title>
    <url>%2Fposts%2F8cc832a6%2F</url>
    <content type="text"><![CDATA[关于UDP你需要知道UDP继承了IP包的特性，不保证不丢失，不保证顺序到达，它只管发出去，打个比方，它就像懵懂无知的小孩，它认为只要是发出去的东西，很容易就能送达，不会丢包。而且它不会建立连接，它也不会进行拥塞控制，只管往外发就行，一根筋。 虽然UDP报文没有可靠性保证、顺序保证和拥塞控制，可靠性较差。但也正因为如此，UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，需要处理速度快，时延低，可以容忍少数丢包，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。 在网络质量很差的环境下，UDP协议数据包丢失会比较严重。但是由于它传输过程中资源消耗小，处理速度快，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包到达的消息及时反馈回来，那么网络就是通的。在默认状态下，一次“ping”操作发送4个数据包，对方主机发回的确认收到的数据包也是4包，这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。 UDP协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据包在传输过程中被篡改或者损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测出是否出错。 关于TCP你需要知道TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来，也因为多了这样一个过程，TCP要比UDP复杂很多，可以看一下TCP头的格式。 TCP的包是没有IP地址的，那是IP层上的事。可以对比看出，相对于UDP来说，TCP多了一个序号，这个序号的作用是为了给发送的包标号，防止乱序，这样我们好知道哪一个应该先来，哪一个后来，做到有理有序。 其次，它还具有一个滑动窗口，我们可以理解为这就是一个管道的大小，越大自然水的流速流量可以更大，越小自然流速就会变小，流量变少，TCP也一样，窗口的大小就是为了能够控制流量的，通过标识窗口大小，就可以知道对方的处理能力，而不会发送过快了，造成拥塞问题，用于解决流控的。 TCP 三次握手TCP连接的建立，我们通常称为“三次握手”，打个比方，大概就是这样：A：你好，我是A，想和你连接B：你好A，我是B，我收到你提出的连接请求了A：好的B，收到了 为啥一定要是三次呢？不是两次或者四次，当A发起一个连接是，如果B没有回复，它又如何知道B收到了呢，它会以为包丢了，或者超时未达，又或者B压根不想和它连接，它会很懵逼，以至于可能再发。 当B收到了请求包，就知道了A的存在，也知道A想和它连接，而且它要是不回复，A会继续重试“骚扰”它一阵子，直到A自己放弃，建立连接失败。如果B愿意连接，OK，立马发个应答包过去，告诉A，我同意和你连接了。 但是，这个过程一样会遇到种种未知错误，比如这个应答包丢了。。。那A不知道啊，继续“骚扰”。。。所以B为了不受其烦，肯定要为了确保应答到达，不断尝试重发，只要一次到达，它就解脱了。至于怎么确认到达，当然是等A收到了应答包，然后欢呼雀跃的再发送一个应答包，表示”收到了，我们连接吧！“不过你可能会觉得，那我们也要确定A这个应答包到达B啊，不然B咋知道A收到他第二次握手发的包，难道不应该四次握手吗？其实四次握手也是可以的，几十上百次都OK，但那也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了。 A当然可以建立连接后空闲着，就是不“搭理”B，对于B来说，对于A这种“占着茅坑不拉屎”的行为，自然可以选择主动关闭，从而把空出的资源给其他客户端使用。 TCP里的序号在“三次握手”中，可以很有效的解决丢包问题，当它俩连接后，A发送了很多个有序排列的包，但中途可能由于种种未知原因，丢了一个，A不知道，但B知道A发的包的总数，它一数，好像差了一个，然后再告诉A。而且这个序号的起始序号是随时间变化的，不会重复，为了防止某些包绕路，等到了其实已经无用了，所以IP包头里有个TTL，也就是生存时间。 这里有个时序图，可以看一下，而且TCP头里还有一些状态位，其中SYN表示发起一个连接，ACK表示回复，RST表示重新连接，FIN表示结束连接，这样这个时序图就好理解了。 TCP 四次挥手嗯，说散就散，说完了连接，该说下“四次挥手”了，它大概是这样的：A：我们分手吧B: 哦，你想分了啊，那好吧，知道了。。。 这个时候，只是A想分手离开了，也就是A不再发送数据，那B能不能在ACK的时候直接选择关闭呢，反正A都要分了，自然是不行的，因为A可能是发完了最后的数据就准备分手了，但是B还没做完它的事情，还是可以发送数据的，处在一种半关闭状态，这个时候A可以选择不再接受数据，也可以选择最后再接受一段数据，等待B也主动关闭。于是就有了：B： OK，那我不陪你了，再见A： 嗯，再见 然后整个连接就关闭了，但是上面是一种理想情况下的分手，可能会遇到很多异常情况，例如，A说完分手后，直接走了，B不知道，B发的回复A就收不到了，B会陷入不知所措。也有可能是B说完分手后，他倒是处于半关闭的还在着，B直接生气走了，A也会陷入两难抉择，究竟B是还有事没处理完，还是一会就关闭了，针对这一系列问题，我们来看断开连接时候的时序图。 从图中我们可以看到，当A说分手了，就进入FIN_WAIT_1的状态，可以理解为等待结束第一阶段，而B回复完A后也相应进入CLOSE_WAIT状态，理解为等待关闭。A收到B的回复，就进入了FIN_WAIT_2状态，如果此时B直接离开了，那A就一直保持在这个状态。如果B没有离开，主动地又说“再见”，然后它就进入了LSAT_ASK状态，然后A收到了B说得“再见”他也发送响应，“嗯，再见”然后进入了TIME_WAIT状态，当B收到A的ASK就会关闭了。而假如这个ASK没有到达，因为只有到达B才会进入关闭，但A已经进入关闭倒计时了，它会保持在这个状态一段时间，然后自动的关闭了，所以这段时间里，B会不断地发送“再见”，直到收到一条A的ASK为止。 假如B在A的最后这段“停留期”，还是没有等来一个回复，虽然它还是会发，当A收到这个后，就会直接回复一个RST，B就知道A跑了，就不再发“再见”了。 TCP 状态机其实就是将TCP连接和分手的两个时序图结合起来，就是表面看起来高大上的TCP状态机了。网络上的传输是没有连接的，包括TCP也是一样的，所谓的连接不过是通讯的双方维护的一个“连接状态”]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2Fposts%2F1a4b62fe%2F</url>
    <content type="text"><![CDATA[关于单例模式单例模式作为对象的创建模式之一，它确保一个类只有一个实例，而且自行实例化并向系统提供这个实例，而这个类也称为单例类。 在《Java编程思想》一书中，作者在代码的例子中无形糅合了诸多设计模式，这也是它被誉为经典的原因之一。其中单例模式的出现频率很高，可见作者对单例模式的偏爱。 当一些对象我们可能只需要一个时，例如线程池、缓存、对话框等等，如果制造多个实例可能就会出问题。像 Spring bean 默认就是单例的，对于一些共享资源的管理就可以使用单例。 单例模式的特点： 单例类只有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有对象提供这一实例 单例类一个简单的单例类是这样的：1234567891011121314public class Singleton&#123; //利用静态变量保存Single类唯一实例 private static Singleton uniqueInstance; //声明构造器为私有，防止实例化 private Singleton() &#123;&#125; public static Singleton getInstance()&#123; if (uniqueInstance == null) &#123; uniqueInstance = new Single(); &#125; return uniqueInstance; &#125;&#125; 它通过静态方法调用私有构造器，而这个实例在调用时被创建出来，单例模式确保一个类只有一个实例，并提供一个全局访问点。但这样的方式会一直到你需要使用这个实例时才会创建，如果你需要在加载类的时候就创建对象实例，可能需要稍稍修改一下代码：1234567public class Singleton&#123; private static Singleton uniqueInstance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance()&#123; return uniqueInstance; &#125;&#125; 多线程问题对于多线程而言，我们需要在getInstance方法前加上 synchronized 关键字，实现同步。public static synchronized Singleton getInstance()但这样的暴力做法可能会影响性能，除非 getInstance 方法的性能对应用程序不是很关键，那么可以选择暂时无视。更好的方式是利用“双重检查加锁”，减少在 getInstance 方法中使用同步。 所谓“双重检查加锁”机制，指的是：并不是每次进入 getInstance 方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。 代码如下：1234567891011121314151617public class Singleton&#123; //被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量 private volatile static Singleton uniqueInstance; private Singleton() &#123;&#125; public static Singleton getInstance()&#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class)&#123; if (uniqueInstance == null) &#123; uniqueInstance = new Single(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 由于 volatile 关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，除非有必要，否则尽量不要大量使用这种方式。 关于枚举实现单例的一个更好的方式是利用枚举类，代码更加简洁，也是一种更加高效安全的实现单例的手段。123456789public enum Singleton &#123; //定义一个枚举的元素，它就代表了Singleton的一个实例。 uniqueInstance; //单例可以有自己的操作 public void singletonOperation()&#123; //功能处理 &#125;&#125;]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈大众传媒]]></title>
    <url>%2Fposts%2F62359f54%2F</url>
    <content type="text"><![CDATA[互联网时代，与其说是流量的争夺战，不如说是注意力的争夺战。传统的纸媒时代早期，纽约《太阳报》的创立开启了广告赚钱吸引眼球的新模式。在那之前，广告仅仅作为新闻的一种信息补充，《太阳报》专门把传统公告栏的那些小的信息变成了高大上的广告，因为之前是没有真正意义上的广告业的。商家并不知道这样的模式，当这样的新模式诞生后，商家因此尝到了甜头，很乐意出钱给传统纸媒作宣传，而这也成为了那个时期纸媒的一个重要的收入来源。 同时《太阳报》里也更注重受众的需求，它们刊登的新闻讯息都是平民百姓很感兴趣的内容，例如自杀新闻和家庭风波，成功吸引了它们的注意力，然后也间接促成了广告事业的成功。这一点和如今的一些新媒体行业有很多相似之处，用内容去吸引用户，用流量的增长推动广告的成功，不仅仅是免费，甚至还会返利，只要你使用这个产品的时间越多，滞留的时间越长，就可以获得收益，可以在积累到了一定的限额进行提现。 “科学”的推荐算法，使得推送的内容满足了绝大部分用户“个性化”的需求，但也因此使你所收到的信息更多在你了解和感兴趣的范畴内。就像在搜索引擎中搜索一样，你不会知道那些你不知道的东西，所以你最终所了解的东西更多还是停留在了那个层面。 这是一个碎片化阅读盛行的时代，如何有效的吸引用户的注意力成为了重中之重，而一些深度阅读，思想深刻的长篇大论，反倒不那么受人待见，除非它是一个“爆款”热文，潜意识的让人觉得读完后会受益匪浅，那么对于广大的普通受众来说，他才会考虑耐心去细细品读。当然这也和本身文章内容质量很高有关，它确实吸引人，观点新颖，但很多类似的好文章可能只有石沉大海的宿命。就像微信公众号里的文章，判断文章质量的评判标准更多会从是否是“十万+”出发，似乎这已经成为了“优秀”的一种标志。而一些观点深邃，逻辑更为严谨复杂的好文章，它对受众形成了一定的阅读门槛，可能它就失去了成为“十万+”的可能。 曾几何时《太阳报》的成功，推动了其他竞争对手的进步，但随着竞争的愈演愈烈，各家报纸都开始提供更 “low” 的新闻以博取大众眼球，艳俗新闻以及暴力死亡事件中对血腥场景的过度描述。再到后面一些纸媒开始报道假新闻，最终引起了绝大部分人的反感。甚至为了获取利益刊登一些虚假广告，对广告主的背景不作具体的了解，刊登广告的门槛越来越低，引起了诸多社会问题。最终没过几年，这样的乱象就消亡了。 这种形式和如今的一些互联网传媒行业是如此相似，只不过是从线下搬到了线上，而且由于技术不断的发展，基于新技术的新形式和新体验也成为了吸引用户注意力的重要手段之一。如今，每天都在产生着海量的信息，过去所要担心的取材难题在当今时代基本不会成为重要的制约障碍。因为我们可取的素材遍地都是，更需要关注的是搜集后的整理和结合。因为如今每一个人都可以算是一个自媒体平台，能人辈出，即使单纯的模仿，对于一些人来说也会由于先入为主认为这是原创，从而有了成为“爆款”的可能，从而获得成为网红的机会。 其实在模式上，相比于曾经传统的纸媒行业，如今，媒体本身是可以不生产内容的，它们更多提供的是一个平台，每一个使用这个平台的自媒体人都够为它们创造流量。对于这些人来说，他们吸引了一大波粉丝的同时，也能从中为自己获取收益。因为某些时候，商家费劲花重金做的一个广告，产生的效益甚至不如请一个流量大V来做一次短视频宣传的价值。 关于内容价值和流量价值，记得在我上学时，课上总在强调内容为王，但当今的事实却是，内容没有发展起来的时候，更多都是以流量为主。这二者可以说同样重要，在某些方面或许其中的某一者的占比会高一些，但在互联网的大背景下，尤其是移动终端——智能手机的普及，流量显得尤为重要。传统媒体强调的内容为王的产业形态，在这样的时代背景下，虽然也依然重要，但流量带来的红利和影响力会让内容的价值更大，反过来流量的重要性也不断的凸显。 网红就如同时代的浪潮，随着时间，一浪高过一浪，不断有新的原创模式竞相出现。就个人而言，受制于自身知识的和技能水平，也难免会有创造力枯竭的时候，因为用户的注意力来的快去的快。而对于企业而言，关注的更多可能就是哪些新的技术手段，运营模式能便于用户生产出质量更高的内容，能最大化的吸引用户的注意力。 由于平台本身对于内容质量把控是有限度的，如果把控质量要求过高势必会造成内容量大幅度减少，难以吸引更多用户，太低又会产生诸如假新闻等的一系列问题。用户本身就偏向追逐一些“快餐式”阅读体验，简单轻松，不会需要很高的阅读门槛，也喜欢“鸡汤”，产生心理上的及时反馈，毕竟看似无害的东西谁又知道它真的就有用呢？类似《太阳报》时代不同纸媒曾经用过的手段，如今依然能看到它们的影子，成为了吸引用户注意力，保持较高平台流量的重要手段。大众传媒从来就不是高雅的产物，某种意义上而言，它也可以是低俗的。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP指北]]></title>
    <url>%2Fposts%2F2111c3b6%2F</url>
    <content type="text"><![CDATA[HTTP概述HTTP是应用层的协议，当我们打开一个网页时，例如：http://www.baidu.com,浏览器会将这个域名地址发送给DNS服务器，然后解析为具体的IP地址。 建立好连接后，浏览器就可以发送HTTP的请求了，而一个完整的HTTP请求报文由三部分组成：请求行、请求头（首部）、请求体（实体）。每一行的末尾都有回车和换行，在请求体和请求头之间另起一行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是以key:value这样的键值对的形式存在的，请求体就是要传输的数据。 HTTP里有很多请求方法，其中最常用的就那么几个，对于访问网页来说，使用的最多的就是GET方法，用来向服务器端获取一些资源，具体返回什么，由服务端来决定。 另一个常用的请求方法类型是POST，它需要你主动告诉服务端一些信息，一般这些信息放在请求体里，与GET不同，POST更多是用来更新资源信息，GET提交请求的数据实体是放在URL后面，用?来分割，参数用&amp;连接，而且数据长度是有限制的，视具体的客户端而定，而POST没有限制，而且GET提交的数据是不安全的，因为相关参数会暴露在URL上。 还有一种类型，叫做PUT，它的作用是向指定资源位置上传最新内容，类似于FTP协议，文件内容包含在请求体里，不过HTTP服务器一般是不允许上传文件的，所以PUT和POST就都变成了要传给服务器内容的方法。 最后一种比较常见的方法就是DELETE，主要就是用来删除文件，是与PUT相反的方法，DELETE是要求返回URL指定的资源。 请求行的下面就是请求头了，保存了一些很重要的字段，例如, Content-Type 是指正文格式，如果是JSON格式的，就要把值设为JSON，而类似 Accept-Charset 则表示客户端可以接受的字符集，避免不必要的乱码。首部字段有很多，其实通过名字我们就能大概它的用法的，用到的时候可以想了解细节再去查。 当我们使用HTTP发送请求时，由于它是基于TCP协议，所以它使用面向连接的方式发送请求，在发送每段报文时，都需要对方回应一个ACK，确认已经到达，如果没有收到对方的回复，TCP就会重新进行传输，直到到达为止，而这个过程是TCP负责的，也就是说无论重新传输了几次，对于HTTP来说它只进行了一次传输，由TCP来完成这个送达的过程。 TCP每发送一个报文都会加上自己本身所在的地址以及它想要到达的另一端的位置，将它们放在IP头里，然后交给IP层进行传输。IP层会查看目标地址和自己所在的地址是否同在一个局域网里，如果在的话就发送ARP协议，获取目标地址的MAC地址，然后把自己的MAC地址和目标MAC地址放到MAC头发送出去，由另一端来进行层层对比确认，然后发送一个ACK，确认到达。如果不在一个局域网里，就要经过网关，而MAC头里放的就是网关的地址，因为我们不知道目标的MAC地址，网关再根据路由协议来获取下一跳的路由器MAC地址，然后加入到目标MAC地址那，由于还不是真正的目标MAC地址，会不断重复这个“寻找”的过程，直到下一跳是目标所在，然后获取到目标的MAC地址。 在TCP头里还有端口号，通过确认MAC地址，IP地址后，通过端口号，目标机器就会知道哪一个进程需要这个包，然后发送给那个进程，例如HTTP服务器，然后HTTP服务器就知道请求的资源是什么，然后把相关资源发送给客户端。 HTTP的返回报文和响应报文类似，简单来说响应报文由状态行、响应头（首部）、响应体（实体）组成，其中第一行是状态行，包含HTTP版本，状态码和状态短语，在一个回车换行之后是响应头，也是以键值对的形式，之后是响应体，也就是要传输的数据。 HTTP协议的特点 HTTP协议是无状态的什么是无状态，就是协议对于事务处理没有记忆能力，对于同一个URL请求没有上下文的联系，每一次的请求都是独立的，不会受前后结果的差异影响响应，但为了使它具有状态的特点，于是引入了 cookis 和 session 机制。 基于TCP协议HTTP协议属于应用层，它的目的是规定客户端和服务端数据传输的格式和数据交互行为，而数据传输的实现，它是基于传输层TCP协议实现的，它本身并不能进行数据传输。 HTTP的响应状态码状态码是用来告知客户端服务器端处理请求的结果。凭借状态码用户可以知道服务器是请求处理成功、失败或者是被转发；这样出现了错误也好定位。状态码是由3位数字加原因短语组成。3位数字中的第一位是用来指定状态的类别。共有五个类别。不过常用的也就16种，下面来详细介绍下： 1. 200：OK代表请求被正常的处理成功 2. 204：No Content请求处理成功，但是没有数据实体返回，也不允许有实体返回。比如说HEAD请求，可能就会返回204 No Content，因为HEAD就是只获取头信息。 3. 206：Partial Content这是客户端使用Content-Range指定了需要的实体数据的范围，然后服务端处理请求成功之后返回用户需要的这一部分数据而不是全部，执行的请求就是GET。返回码就是206：Partial Content。 4. 301： Moved Permanently代表永久性定向。该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL。也就是说如果已经把资源对应的URL保存为书签了，这是应该按照Location首部字段提示的URL重新保存。 5. 302：Found代表临时重定向。该状态码表示请求的资源已经被分配了新的URL，但是和301的区别是302代表的不是永久性的移动，只是临时的。就是说这个URL还可能会发生改变。如果保存成书签了也不会更新。 6. 303：See Other和302的区别是303明确规定客户端应当使用GET方法。 7. 304：Not Modified该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但是没有满足条件。304状态码返回时不包含任何数据实体。304虽然被划分在3XX中但是和重定向没有关系。 8. 307：Temporary Redirect临时重定向，与302 Found相同，但是302会把POST改成GET，而307就不会。 9. 400：Bad Request表示请求报文中存在语法错误。需要修改后再次发送。 10. 401：Unauthorized表示发送的请求需要有通过HTTP认证的认证信息。 11. 403：Forbidden表明请求访问的资源被拒绝了。没有获得服务器的访问权限，IP被禁止等。 12. 404：Not Found表明请求的资源在服务器上找不到。当然也可以在服务器拒绝请求且不想说明理由时使用。 13. 408：Request Timeout表示客户端请求超时，就是在客户端和服务器建立连接后服务器在一定时间内没有收到客户端的请求。 14. 500：Internal Server Error表明服务器端在执行请求时发生了错误，很有可能是服务端程序的Bug或者临时故障。 15. 503：Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After字段再返回给客户端。 16. 504：Getaway Timeout网关超时，是代理服务器等待应用服务器响应时的超时，和408 Request Timeout的却别就是504是服务器的原因而不是客户端的原因。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非“你”不可]]></title>
    <url>%2Fposts%2F2229ab2%2F</url>
    <content type="text"><![CDATA[我们之所以要购买产品和服务，是因为我们需要购买它们来为我们完成某项特定的任务。这是我们购买一件产品或是一项服务的初衷。我们不会去买我们不需要的东西，因为并不存在潜在的解决任务需求。 一个产品，当它与其他同类产品的差异逐渐缩小，这里的差异也可以认为是它对于完成我们那些“任务”的效率差异逐步缩小。再没有更好选择时，那么我们可能才会对比其他方面，从其他方面入手，例如产品的外观、材质，是否更耐用，外观更出色。 曾经我们购买一件产品时的出发点就是如此，但如今随着经济的繁荣，各式商品琳琅满目，我们会看到许多外观十分特别，功能是“独特”的产品，但当我们使用时会发现，本质上它和一些我们熟悉的类似产品在解决任务的效率上并没有本质变化，价格更为昂贵，只是我们“认为”它们能更出色的完成任务，但事实上并不一定。 就拿柔性电子产品来说，它分为三大类：柔性屏幕，柔性电池和柔性集成电路。目前来看，国内最大的相关公司是柔宇科技，国外则是三星，我觉得这个产品是否更“出色”，不是它外观的新颖，形式的创新，而是它在全面屏满足的需求上又解决了什么问题，哪些地方更好，而这些点是否紧贴用户的潜在需求，那么这样产品才能被买单。 跳出原有的认知，将这样的产品应用于其他领域，是否在其他领域上使用这把“刀”要比原有的方式更出色，探索这样的可能性，一意孤行的去创造一种新形式的产品，哪怕它具有很先进的技术，但它所能解决问题的能力并不比其他传统产品大多少，先进的技术应用在其上就是一种浪费，它也注定了被市场抛弃的结局。 有交易就会有信息不对称，通过“包装”，我们确实可以让一个普通产品成为“爆款”，风靡一时，但一家企业想要基业长青，需要的是真正富有意义和价值的产品，去关注用户的潜在需求，而不是驻足于花样繁多的形式本身。但如果一个好的设计使得产品本身的优势不断提高，那么这样的形式也是值得肯定的，但它很难成为产品的核心。不断地追求产品本身的价值，而非本末倒置，让它在某段时期里，非“你”不可，才能尽可能的创造用户，它比创造利润本身更为重要。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java线程池]]></title>
    <url>%2Fposts%2Fc158fcfc%2F</url>
    <content type="text"><![CDATA[关于线程池线程池是Java并发中一个非常重要的概念，可以把它理解为一个线程的池子，里面包含了若干线程，可以继续复用执行新任务，避免了线程创建的开销。 线程池类似于我们排队办理业务，办理业务时可能提供了若干的窗口，我们根据自己的需要选择合适的窗口。其中办理业务的各个业务员就是线程池中的工作者线程，而我们排队的队列就是线程池中的任务队列。 线程使应用能够合理地协调利用CPU、内存、网络等系统资源。线程的创建需要消耗资源，同时线程的销毁也需要回收这些系统资源。频繁地创建和销毁线程会浪费大量的系统资源。另外，在服务器负载过大的时候，如何让新的线程等待或者友好地拒绝服务，这些都是线程自身无法解决的。所以需要通过线程池协调多个线程。 使用线程池线程池不建议使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。在 ThreadPoolExecutor 提供了四个构造方法。1234567891011public class ThreadPoolExecutor extends AbstractExecutorService &#123; ... public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler); ...&#125; 通过其源码，可以看到其中包含四个参数，它们分别表示： corePoolSize：核心池的大小 maximumPoolSize：线程池最大线程数 keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止 unit：参数keepAliveTime的时间单位 workQueue：工作队列，本质是一个阻塞队列，用来存储等待执行的任务，一般阻塞队列有：ArrayBlockingQueue（有界阻塞队列，一旦创建容量不能改变）、LinkedBlockingQueue（无界队列，没有预先定义容量）、SynchronousQueue（直接传递）。 threadFactory：线程工厂，主要用来创建线程 handler：当线程的数量已经到了边界值，并且workQueue中任务也达到最大值，此时需要使用它拒绝多余的任务 Java并发类库目前提供了五种不同的线程池创建配置，它们分别是： newCatchedThreadPool():用来处理大量短时间工作任务，它会尝试缓存线程并重用，当无线程可用时，就会创建新的工作线程。如果线程限制且时间超过60秒，就会被终止并移出缓存。 newFixedThreadPool():重用指定数目的线程，除非任务数量超过了工作线程，就会在工作队列等待空线程出现，如果有工作线程结束退出，就会创建新的工作线程，达到上限的指定数目。 newSingleThreadExector(): 工作线程数目限制为1，保证所有任务都是顺序执行。 newSingleThreadScheduledExector()/newScheduledThreadPool(int corePoolSize): 可以定时或者周期性的进行切换调整，区别在于单一工作线程还是多个工作线程 newWorkStealingPool():Java8引入，可以并行的处理任务，但不保证处理顺序 如果需要较多等待任务，例如I/O操作，可以参考下这个计算方法：线程数 = CPU 核数 × （1 + 平均等待时间 / 平均工作时间） 使用线程池要注意： 合理设置各类参数，根据需要合理的设置线程数，避免过度扩展线程，可能引起线程泄漏 不要自行创建线程，线程资源通过线程池来创建，避免资源耗尽的风险 避免任务堆积，如果处理跟不上入队的速度，工作线程数量不足，就会占用大量内存空间 线程和线程池的名称最好直观易于理解，必要时增加注释 线程池的好处线程池可以实现类似主次线程隔离、定时执行、周期执行等任务。使用线程池的好处有： 有效的管理并复用线程、控制最大并发数。 有利于实现某些与时间相关的功能，如定时执行、周期执行等。 有利于实现任务线程队列缓存策略和拒绝机制。 隔离线程环境，避免相互间线程的影响。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文化与媒介]]></title>
    <url>%2Fposts%2F5af50fe0%2F</url>
    <content type="text"><![CDATA[有人说文化可以用四句话表达：植根于内心的修养，无须提醒的自觉，以约束为前提的自由，为他人着想的善良。 “文化”是一个很抽象的概念，它本身也具有很强的人文意味，因为文化本身就是“人文化成”的一个缩写。人文一词在我看来，它是把很多客观现实的存在经过我们人为的重组与再认知，概括为了一个抽象层次更高的概念，而它是客观世界原本不存在的，并且它可以成为我们的一种生活方式。 相对于其他物种而言，“文化”活动可以说是人类所独有的，对于人类而言，文化是不可或缺的。为什么文化显得重要，从其他角度来看，或许文化是一种非物质化的“媒介”，它抽象层次更高，依托于很多不同的实体，它本身就能很好的传递一些信息，但它也可以很抽象，令人难以理解。 对于媒介本身而言，它最重要的作用就是作为承载信息的桥梁，实现信息的交换，如果一个媒介在信息交换的速度上很快，那么它对整个社会的影响力也会不断提高。文化，无论是对社会，还是对国家，又或者对公司，乃至个人，在某些方便都可以算是一个很好的“媒介”。但它不像文字或是图片，具有固定的形式，文化是不同实体结合抽象后的统称。 一些思想的具体内容，可能以文字这类形式没法具体的传递给对方。例如，中国传统武术文化里，关于太极的思想，其实它是一个极为抽象的概念，可能通过文字的表述我们很难领悟其中的真谛，达到所谓知行合一的境界。但武术文化不同，它将这样的思想和具体的动作结合，当我们在演练时，我们可以通过具体的动作，将那种刚柔并济，圆润统一的意味具体的外化表现出来，通过这样的形式加深我们对于“太极”的理解，乃至上升到哲学里的矛盾的对立与统一。这类复杂抽象的哲学思想，通过武术文化的具象表现形式，可以有效地传递给对方。 不同的地方有着不同的文化，它们所承载的东西也截然不同。就像在公司工作时，当一个公司刚起步，处于初创阶段，可能人才，资金，技术会很重要，但随着时间的推移，公司不断的发展壮大，就需要把这些有形资源变为具体的流程和价值标准来执行，当一个公司发展足够庞大，那么就需要企业拥有自己的文化，由文化价值观来驱动各项流程的顺利实施。所以我们不光要学习国外先进企业的研发能力，更要学习他们的职业文化，达成企业到员工之间的一种无形的沟通桥梁。 若有更好的方式能实现“文化”所发挥的作用，那么文化的作用便会被弱化，但在某些方面“文化”确实是一个出色的“媒介”。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC与需求变化]]></title>
    <url>%2Fposts%2Ffe27ee39%2F</url>
    <content type="text"><![CDATA[需求变化是程序员需要面对的一个难题，尤其在需求频繁变更的情况下，这意味着我们可能又要加班加点忙活一阵了。不断地完成旧需求，又不断地解决新需求，凭借我们的直觉，实现需求即可，只要把要求的需求一个个按时完成上线就万事大吉，没有更多考虑到未来可能产生的需求变化。“僵硬”的构建过程所带来的就是日后依然需要投入很多时间处理需求变化，而非一个灵活的设计，可以不被需求牵着鼻子走，直接自己掌握多样化的需求。可以有效减少本没有必要出现的加班乱象。 控制反转（IOC）作为面向对象编程的一种设计思想，意味着在 Java 中，我们将设计好的对象交给容器来控制，而不是传统的操控对象本身，由对象内部再来作控制。具体来说，传统的程序设计是主动地创建一个具体对象，再将它们组合起来，其中一个类可能依赖于另一个类，所以我们需要由我们创建的对象去主动地获取依赖的对象。 控制反转思想则由容器来为我们完成查找相关依赖对象，再将它们注入进来的工作，然后我们就能获得我们需要的具体对象，因为我们只能被动接受依赖对象的注入，不再像传统过程一样，由我们自己创建自己去获取，这个过程被反转了，由容器来控制。通过依赖注入可以有效实现解耦，但IOC并不仅仅作用于此。 控制反转，是一种重要的设计思想，其实也比较好理解，我们买电脑时，可能对于外行人来说，什么处理器型号，显卡型号，内存大小啥的，他们可能听过，但对具体区别不是特别了解，如果再具体细分处理器是标压还是低压，超频多少，风扇转速之类的，他们会晕了的。他们只知道他们想要的是一台可以玩大型游戏，剪辑视频的电脑，又或者是一台轻薄便携续航长可以流畅办工上网的电脑。 我们不用专门给他们介绍具体硬件上参数型号的差异，因为他们认知里，电脑就是电脑，能实现这个需求的就可以称为“电脑”，就像能打电话聊天的便携设备就可以叫“手机”，我们不用去知道实现的具体标准是啥，它需要哪些硬件，啥处理器、显卡、内存之类的，这个标准早就由产业本身制定规划好了，用户的需求要在这个标准下才能满足，而非漫无目的根据用户的需求，实现了一堆充斥不知名硬件设备形似电脑的东西，虽然它也实现了我们对电脑的定义需要的种种需求，但这样也使得我们要疲于应对各式需求，想办法做出符合需求的东西。 有了一个标准，一个有效的设计模式，可以大大节省我们不必要的人力投入，用户需求将成为设计的约束条件和验证手段，而不是出发点和目标。这样可以避免需求的变化让我们疲于奔命的工作状态。毕竟，谁又喜欢经常性不必要的加班呢？]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声望的陷阱]]></title>
    <url>%2Fposts%2F621d5fbd%2F</url>
    <content type="text"><![CDATA[命运是解不开的谜团，声望是没有实际意义的云烟。 什么是声望？一个官方的解释是：声望是众所仰望的名声。人生在世，我们总有为声望所累的时候，但我的阅历尚浅，对于“声望”不好妄作评判，仅仅只能按我的理解，谈谈在当前时代下的“声望”的影响。 个人具有声望，组织和团体也具有声望，声望是一种看不见的影响力，它不好量化，但它却能无形中影响很多东西，就像我们玩的游戏，会有所谓的声望值，当你具备不同声望值时，就有权限获得一些稀有物品一样。 但游戏终究和现实不同，现实世界充满着许许多多的不确定性。可能具有很高声望的人或事物，会对人们的判断施加一定的影响，因为我们辨别和判断一件事物的好坏需要经过深思熟虑，这个过程对很多人而言并不那么“友好”，而具有了高声望，就能在判断上无形给予一定的肯定，简化了“深思熟虑”这项工作的任务量，因为声望的积累是基于大量的评价和时间的考量的，更能使人确信“它”对自身是有益的，由于思维的“惯性”我们就会自然而然选择了相信。 如同品牌效应，大厂出品一定会因为它完善的工艺和流程，质量上一定比同类产品更好。但销量高并不一定代表质量好，它们之间并不存在绝对意义上的正相关。对外部具有很高声望事物的盲目肯定，终会使我们的判断受制于对方。 假如没有了声望对判断施加的影响，那么真正吸引我们的，又是对方的什么呢？就拿衣食住行来说，我们选购一件衣物的判断，究竟是基于对品牌所积累的声望的信任，认为它一定用了优质的物料，一流的设计，还是商品本身质量就很不错呢？毕竟我们的世界是变化的，同样的产品或是服务，终究会随着时间的流逝产生差异的变动，很难“始终如一”。 如果商品和服务是我们还能切身在短时间内能感受到变化的，比较容易减小声望对人判断的影响。那么人呢？评判和了解一个人或许是一件复杂度极高的任务，我们难以短时间真正了解一个人，我们所基于的判断，来源于那个人的过去经历，例如他的受教育水平，是否具有本科学历，进而又要细分是否是名牌一流大学，因为那些大学本身所具有的声望能证明很多东西。如果是在校时就看在校的比赛获奖情况，进而又要区别看比赛的规模和大小，因为一些比赛具备参考价值，它确实选拔出了许多出色的人才，随着时间的积累，这个比赛所积累的声望就成为了一种“隐性标志”，暗示只要我获奖了，那么代表了我和曾经获奖的那些名人也具备同样的素质和潜力，而名人的成功也间接为类似比赛的声望添砖加瓦。但事物是变化的，我们只能保证在那样一个时间段里，它确实具有参考价值，含金量十足，但随着时代的发展，事物的更迭，能时刻保持领先，并始终拥有与之匹配的声望的事物是何其稀少。 当前的时代是网络时代，处于这个时代背景下的我们无法避免声望对我们判断施加的影响，而且网络的虚拟化，谁又知道一切是真的，而非虚张声势搭建起来的声望呢？网上购物商城的一些评价可以通过刷单刷好评取得消费者的信任，而最近大火的抖音，我们可以搬运别人的创意，成为自己涨粉的途径，哪怕只是从一些科普常识上搬运一些看起来有价值的东西，加上一个相关行业的背景，却能带来巨大的流量，点赞量和粉丝量无形为其树立起了某种声望，因为这类开放平台的用户量太多了，聚集了不同层次的人，但点赞量和粉丝量却是“一视同仁”的。 在这样的时代里，最能直接影响声望变化的，或许就是建立于社交媒体之上的舆论导向的，通过巧妙刻意的包装，引起舆论的关注，随即带来巨大的流量，无论是提高声望还是影响竞争对手的声望，都是无形的，如果对方的公关不能应对得当，那么就会陷入舆论的漩涡，或许可以通过一些形式“洗白”，但也依然会产生一些无形的影响，而往往这些“看不见”的东西更具风险性。 不要因为“声望”影响了我们对真实世界的认知，它可以作为评判的依据和参考，但不能作为先入为主的第一选择，无论是对任何事物，亦或是任何人，我们要关注于那些真正决定其本身的东西，避免陷入声望的陷阱。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript的“面向对象”编程]]></title>
    <url>%2Fposts%2F672169fd%2F</url>
    <content type="text"><![CDATA[初识JavaScript面向对象相对于 Java 里的面向对象来说， JavaScript 里的面向对象机制绝对可以称之为“另类”了，因为如果我们具有 Java/C++ 这类传统面向对象语言的经验，那么以那样的思维来理解 JavaScript 的面向对象令你产生很多疑惑。 定义一个 JavaScript 对象很简单，我们可以：1var a = &#123;&#125;; 也可以用其他的方式：12function f() &#123;&#125; 可能你很费解，这不应该是一个函数吗？为什么就变成对象了，因为在 JavaScript 里函数也是对象，而且还是一等公民。而在很多传统语言中，例如 Java、C/C++ 等，函数都是二等公民的身份。什么叫二等公民呢？你只能用语言的关键字声明一个函数然后调用它，如果需要把函数作为参数传给另一个函数，或者赋值给一个本地变量，又或是作为返回值，就需要通过函数指针、代理等特殊的方式周折一番。 而在JavaScript里的函数，它不仅拥有一切传统函数的使用方式，而且可以做到像简单值一样赋值、传参、返回，而且JavaScript中的函数还可以充当“类”的构造函数，同时又是一个Function类的实例，这样的多重身份让JavaScript里的函数变得极其重要，使得 JavaScript 更像是 Scheme （一种函数式语言）。 JavaScript提供了一个构造函数模式来在创建对象时初始化对象，而构造函数也只是一个普通的函数，只不过它内部使用this，使用new生成实例，在这一点上很像传统的面向对象语言。而this总是指向当前对象，无论是添加属性还是方法，都只在当前对象添加，实例化一个新对象时，就会在内存里复制一份，但过多的新对象不可避免会造成大量的内存浪费。 为了解决这一问题，于是有了原型prototype的形式，在JavaScript里，每一个构造函数都有一个 prototype 属性，指向另一个对象，这个对象的所有实例和方法都会被构造函数的实例继承，对于不变的属性和方法，可以直接添加在类的 prototype 对象上。功能上来看，很像Java里接口的概念，尤其是 Java 8 引入了接口的默认方法，二者在功能上看上去更为接近。123456function Dog(name,color)&#123; this.name = name; this.color = color; &#125; Dog.prototype.type = "宠物"; Dog.prototype.eat = function()&#123;alert("吃狗粮")&#125;; 当我们生成实例时，实例里的属性和方法其实都在同一个内存地址里，指向 prototype 对象，避免了不必要的内存浪费。但也会因为改动一个对象的属性而可能影响到其他相关的对象，而利用构造函数的形式则没有这样的弊端。 传统的面向对象语言里，例如Java，会有相应的访问控制功能，借助于 public 、 protected 、 private 这三个关键字，而 JavaScript 里则没有这样的关键字，但为了实现类似的功能，例如属性和方法的私有，就要借助于函数作用域的特性，因为函数内的局部变量如果不通过闭包等方式是无法直接访问的，对外层作用域而言就是“私有”的。 Javascript里的“类”在ES6之前，JavaScript只有一些近似类的语法元素。JavaScript里没有“子类”和“父类”的区分，也没有“类”和”实例“的区别，我们可以模拟出传统面向对象语言里类的特点，但它的机制和我们理解的类的概念是完全不同的，只是通过”语法糖“的包装和”类“库的存在让我们误以为JavaScript的类存在而已。 那么”类“中的继承又是如何做到的呢？JavaScript主要依靠继承链来解决继承的问题。传统情况下，我们在JavaScript生成一个实例的方法都是通过构造函数，类似于这样：12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 而在其他传统面向对象语言里，一般情况下，都是生成一个class，然后再通过类的构造器来生成相应的实例对象，所以 JavaScript 显得很特别。在ES6里引入了“class”的概念和关键字，通过这个关键字，可以定义一个“类”。像这样：12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 这样的形式就不容易使人困惑了，它就更接近我们认知里的类的概念了。ES5里的Point构造方法就是ES6里Point“类”里的构造方法,而且toString方法也定义在了“类”里，而在“类”里的方法是不需要function关键字的。 某种意义上ES6里的“类”就是一个语法糖而已。。。实际上基本可以看作传统构造函数的一种简便写法。因为类里的所有方法实际上还是定义在 prototype 属性上面。12345678910111213class Point &#123; constructor() &#123; &#125; toString() &#123; &#125;&#125;//等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;,&#125;; 而在“类”的实例上调用方法，其实就是在调用原型上的方法。不过也有一些差别，在“类”的内部所有定义的方法都是不可枚举的。 在JavaScript里，定义函数的方式有两种，一种是函数声明，一种是函数表达式：1234567//函数声明function functionName(arg)&#123;&#125;//等同于函数表达式var functionName = function(arg)&#123;&#125;; 对于类来说一样也可以通过表达式定义12345const MyClass = class Point &#123; getClassName() &#123; return Point.name; &#125;&#125;; 只不过这个类的名字不再是Point，而是MyClass，Point只在class的内部使用，指代当前类。 JavaScript里的函数声明具有函数声明提升的特征，即使放在相关调用语句之后，也会在执行代码之前先读取函数声明，而类不存在这样的提升特性。因为ES6里的“类”，依然只是之前的构造函数的一层包装罢了。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口和抽象类的区别]]></title>
    <url>%2Fposts%2F8275df43%2F</url>
    <content type="text"><![CDATA[接口和抽象类是 Java 面向对象里的两种不同机制，尽管某些方面它们看起来相似，但却有本质的不同，定义类的过程就是抽象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行为和特征。由于Java本身不支持多重继承，它们是Java为实现多重继承行为的扩展延伸。 抽象类抽象类是不能实例化的类，使用 abstract 关键字修饰，除了不能实例化和一般的 Java 类没什么大的区别，可以包含或者不包含抽象方法,但如果一个类包含一个或多个抽象方法，它一定是抽象类。 抽象类一般是抽取相关的Java类中得共有的方法或属性，然后通过继承实现代码复用，例如我们常用的 collection 集合框架。 如果我们继承抽象类，并且想创建新类的对象，那么我们必须为父类的所有抽象方法提供具体实现，否则这个子类也是抽象类，并且编译器会强制用 abstract 关键字修饰这个类。 接口的本质接口（interface）是对行为的抽象，它是抽象方法的集合，但接口不能被实例化。接口也不能包含任何非常量成员，因为默认其中的域隐式都为 public static final 的。 实现 interface 时使用 implements 关键字，接口中不能有任何非静态方法的实现，只能包含抽象方法和静态方法。并且接口中的域隐式都是 static final的，所以接口很适合用来作为创建常量组的手段。不过在Java 8以后，接口也提供了默认方法的支持,使用 default 关键字 接口中，它允许我们创建方法名，参数列表和返回类型，但不包含任何具体的实现。由于Java中并不支持多重继承，通过interface可以使我们创建一个可以被向上转型为多种基类的类型，变相实现多重继承的行为特征。 接口中所有的方法都是 public 的，所以即使我们不显式指定，它们也是 public 的。 接口也是可以继承的，通过继承，可以很容易的在接口中添加新的方法声明，还可以通过继承在接口中组合多个接口，接口的继承仍然使用 extends 关键字，其继承的类型也是接口。不过要注意在不同的接口中使用相同的方法名会加大阅读代码的难度，尽量避免这种情况发生。 接口和抽象类关于接口和抽象类的区别可以看一下这个表： 接口与抽象类的共同点是都不能被实例化，但可以定义引用变量指向实例对象。抽象类在被继承时体现的是 is-a 关系，接口在被实现时体现的是 can-do 关系。与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方法、属性变量。如果一个抽象类只有一个抽象方法，那么它就等同于一个接口。 使用接口和抽象类是为了防止创建该类的对象，确保别人使用你所设计的类时，仅仅是建立一个API接口， 如果我们要创建任何不带方法定义和成员变量的基类，那么我们就应该选择接口而不是抽象类。当纠结定义接口还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接口，然后再用抽象类去 implements 某些接口，这样做可方便后续的扩展和重构。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为何会选择技术之路]]></title>
    <url>%2Fposts%2F8750774a%2F</url>
    <content type="text"><![CDATA[你会发现，曾经后悔走上的弯路或许是人生的必然曾经那些看似无法改变的路程，都可以彻底调整。我们没有走过弯路，就不会知道什么是直路。 回顾往昔，当初我为何会选择技术这条路，与接触新媒体息息相关，理解了媒介变化的本质，就理解了技术在其中所产生的作用。在这个时代，能推动信息流动的加快，那么这样的技术是富有潜力的，而每一次信息流动的加快在人类的发展史中始终都有着至关重要的作用。同样的信息，过去使用书信往来，现在使用微信互动，传播的速度也是大相径庭的。也因为信息流动的加快，使得人与人之间，组织与组织之间因为地理位置差异所造成的隔阂不断缩小，我们能更频繁的进行贸易的往来，文化的交流等等，媒介就像是催化剂，它不能对事物的变化起决定作用，但它可以推动这个变化的速度，加快频率，那我们就能在同样的时间单位里完成更多的事。 媒介的发展，亦即传播速度的加快，在我看来，不仅仅是数据传输速度的加快，还包括处理的速度，也就是信息背后所包含的思想是否更容易被吸收和理解。不同媒介的传播速度是不一样的，文字作为人类文明承载信息的重要媒介之一，其本身却不是一个出色的媒介，通过文字所记录的信息，难免会在传递的过程中，由于个体的背景差异产生一些信息的失真。尤其我们在阅读一本晦涩难懂的书时，很难将作者所要表达的原意通过文字完完整整的解析出来，如果这本书还是翻译的版本，又会在翻译的过程中不可避免的损失一部分信息，全靠译者来把关，如果译者水平有限。。。那就只能听天由命或者直接选择阅读原著了。 相对于文字来说，人们更容易接受从图像中获取信息，而文字最初的产生。如中国古代的象形文字，或是苏美尔人所创的楔形文字，它们雏形的诞生，都多为图像。这也说明我们了解世界最开始某种程度上来说是从图像开始的。如今我们获取信息的渠道更多了，承载信息的主要方式不再以文字记录为主，图片、视频、音频、VR技术等新的形式，它们更多都从视觉的接受度上出发，在传播的过程中也更利于被人们接受。 通过某种方式对信息进行加工，实现信息在传输和理解的“便利化”，一定程度上是可以推动信息的流动，但取决于“加工”的形式。例如我们可以精炼出一本书的核心要义，将一本书最核心的观点进行总结和转述，用便于人们理解的简洁明了的方式进行传播，那么其他人就可以在很短的时间里完成了“阅读”一本书的任务。但这个方式更多依赖于那个所谓的“领读者”，他不一定能完整的按原作者的思路和逻辑进行转述，而原作者本身是希望你通过阅读他的那本书的过程来完成你和他之间的信息传递。 当然，我们也可以通过更好的表述方式，将原作者希望表达真实意思再现。或许原本他需要用大量的语言和文字来作为铺垫才能表述清楚他的想法，现在你可以用更少的语言和文字实现同同样的目的，或者通过其他方式，例如音视频、图片等等。说不定比文字更利于表达你想要说明的东西。但这样的方式要更困难。这也是为什么除了文字，绘画、音乐等形式能够在历史的长河中熠熠生辉的原因，它们本身也承载着各自不同的文化底蕴，容纳了很多信息在它们所特有的形式之中，需要我们以恰当的方式“解读”出来。 对原有信息的“精炼”，将信息量缩减这样的方式，一旦逐渐发展成为了主流，大众便逐渐失去了接受信息后对信息的“再处理”的能力，简化信息量，使得用户不用思考便能吸收理解，真的好吗？抖音，今日头条，微信公众号，微博，它们通过不同的交互手段和信息呈现形式，不断地冲刷和改变着人们的意识流。我们的世界观似乎不再是由我们自己来主导，而是由这些新媒介，它们逐渐把控着我们对世界，对人和事物的认知。新媒介的发展不应如此，它的本质应该是使用户接受原有信息的效率更高，通过技术手段实现多样化的表现形式，发掘触觉，听觉，视觉等等方面，根本上的重构信息的展现形式，因为媒介是“人的延伸”，而文字并不是一个很好的用来表达思想的媒介，重新唤醒人们接受信息，处理信息的深度思考的能力，这或许是我认为技术终极的追求目标。 在我看来，“每天听本书”这样类似的形式，将原有体系精炼肢解后，以人们最便于直接理解，最易获得及时反馈的形式并不应该成为主流，即使因为工作生活原因，挤不出更多时间阅读思考，也不应该将这个思考过程“外包”出去。过程本身对自身思维的训练比直接获得结果更为重要。 纠结于文字本身，何不将重心往其他媒介上靠拢试试呢？一旦有了一个更为恰当的方式，不是以牺牲个人主动思考的能力为主，它的出现令人们主动地去判断信息的价值，那么它确实具备了促进人类的进步的意义和价值。而技术本身对于实现这样的“新媒介”是有重要意义的，因为不同技术本身也有各自的特性，适用于解决的问题也有所不同，没有最好的，只有最适合的。只要通过技术能实现和解决这些旧有痛点，就是颠覆的可能，创建新的行业形式。 反之，技术仅仅被用于去提高原有“错误形式”的影响力，那么技术始终只是技术。比起实现需求，分析需求背后所带来的价值比单纯的需求更为重要。我为何会选技术之路，因为我希望看到不同技术背后对社会和人的影响，如果它并不能带来积极的影响，促使人和社会的进步，我希望我能发现更好的形式。这一切的基石是技术，需要靠它来实现，也只有自身更懂技术才能更好的实现这一过程。只有这样，技术在我手中才具有了意义，不再限定于程序员本身。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat学习总结]]></title>
    <url>%2Fposts%2F9b6e0dfb%2F</url>
    <content type="text"><![CDATA[关于Tomcat本质上Tomcat就是一个程序，由于我们用HTML，CSS写的页面只有我们自己可以访问，Tomcat就是提供了能让别人也可以访问我们页面的程序。 Tomcat不是一个完整意义上的Jave EE服务器，它甚至都没有提供对哪怕是一个主要Java EE API的实现；但由于遵守apache开源协议，tomcat却又为众多的java应用程序服务器嵌入自己的产品中构建商业的java应用程序服务器，如JBoss和JOnAS。一些开源组件如Structs、Spring和Hibernate，Tomcat都能够对这些组件实现完美的支持。 Tomcat的目录结构 backup: 保存了一些配置文件，是在第一次运行了Tomcat服务器以后产生的。它是对服务器进行简单的备份日志。和conf文件下的内容几乎一样。 bin: 启动和关闭Tomcat脚本文件，很多环境变量也在此处设置。 conf: Tomcat服务器的各种配置文件，其中Catalina子目录下可以设置默认加载的项目。Catalina文件可以设置tomcat服务器内存大小。context.xml可以用来配置数据源之类的东西。logging文件记录tomcat服务器运行的日志记录。server.xml可以设置域名、端口号、IP、请求的编码、默认加载的项目。web.xml可以设置tomcat服务器支持的文件类型。 lib: Tomcat服务器所需要的所有Jar包。 logs: Tomcat的日志文件。 temp: Tomcat运行时的临时文件。 webapps: Tomcat自带的两个web应用：admin和manager，用来管理Tomcat的Web服务。也是tomcat默认部署路径，目录用来存放应用程序，当Tomcat启动时会加载webapps目录下的应用程序。当然可以以war包、Jar包、普通文件夹三种形式发布应用。你也可以把应用程序存放在电脑磁盘的任意一个位置，但是在配置文件中要配置好，使其映射好。 work: JSP经过Tomcat编译后生成的Servlet。 wtpwebapps: 和webapps功能差不多，但是它是eclipse默认的部署路径。与webapps同时存在时，默认选择wtpwebapps。 配置Tomcat的配置文件在conf目录下，其中： catalina.policy：Java相关的安全策略配置文件，在系统资源级别上提供访问控制的能力 catalina.properties：Tomcat内部package的定义及访问相关的控制，也包括对通过类装载器装载的内容的控制 context.xml：所有host的默认配置信息 jaspic-providers.xml：tomcat 实现了 JASPIC 1.1 Maintenance Release B 标准，并通过这个配置文件集成第三方 JASPIC 身份验证 jaspic-providers.xsd：定义了 jaspic-providers.xml 所使用到的标签 logging.properties: 日志记录器相关的配置信息，可以用来定义日志记录的组件级别以及日志文件的存在位置等 server.xml: Tomcat的主配置文件，包含Service, Connector, Engine, Realm, Valve, Hosts主组件的相关配置信息 tomcat-user.xml：Realm认证时用到的相关角色、用户和密码等信息；Tomcat自带的manager默认情况下会用到此文件；在Tomcat中添加/删除用户，为用户指定角色等将通过编辑此文件实现 tomcat-users.xsd：定义了 tomcat-users.xml 所使用到的标签 web.xml：遵循Servlet规范标准的配置文件，用于配置servlet，并为所有的Web应用程序提供包括MIME映射等默认配置信息]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Java泛型]]></title>
    <url>%2Fposts%2F7ca0722f%2F</url>
    <content type="text"><![CDATA[泛型的本质是类型参数化，解决不确定具体对象类型的问题。泛型可以定义在类、接口、方法中，编译器通过识别尖括号和尖括号内的字母来解析泛型。 与C++根据模板类生成不同的类的方式不同，Java使用的是类型擦除的方式。不过了解C++模板有助于你理解Java泛型的机制，理解它的局限是什么以及Java泛型的边界。 关于泛型泛型是接口概念的延伸，我们通过泛型可以为类、接口、方法应用更为广泛的类型，使得操作的数据不再和代码绑定在一起，不仅可以复用代码、降低耦合度，还可以提高代码的可读性和安全性。 泛型类一个简单的泛型类是这样的：123456789public class Test&lt;T&gt; &#123; T first; public Test(T first)&#123; this.first = first; &#125; public T getFirst() &#123; return first; &#125;&#125; 相对于普通类而言，类名的后面多了一对尖括号，和一个字母T，这个T表示的就是类型参数，泛型就是类型参数化，处理的数据并不是固定的，而是可以作为参数传入。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 在定义泛型时，一些常见的类型参数表示： E代表 Element ，用于集合中的元素 T代表 the Type of object ，表示某个类 K代表 Key、 V代表 Value ，用于键值对元素 泛型方法方法也可以使用泛型，而且泛型方法并不需要其所在的类一定要是泛型类，一个简单的泛型方法大概是这样的：123public static &lt;T&gt; getData(T t) &#123; return t;&#125; 泛型方法使得该方法可以独立于类产生变化，如果使用泛型方法可以取代将整个类泛型化，那就应该使用泛型方法。 对于 static 方法而言，它无法访问泛型类的类型参数，除非把它定义为泛型方法，才可以具有使用泛型的能力。 泛型接口泛型接口与泛型类的定义及使用基本相同，举个例子：123public interface Test&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口时：12345class FruitTest&lt;T&gt; implements Test&lt;T&gt;&#123; public T next() &#123; return null; &#125;&#125; 类型擦除Java泛型是使用擦除来实现的，这意味着当你使用泛型时，任何具体的类型信息都要被擦除，你唯一知道的只是你在使用一个对象。擦除机制可以在不破坏现有类库的情况下，将泛型融入Java语言，使得非泛型的代码能够在不改变的情况下继续使用。 编译器编译后，Java的源代码变为了.class文件，虚拟机再加载这个文件运行。对于泛型类，Java虚拟机会把泛型代码转化为非泛型的普通代码，将类型参数“擦除”，替换为Object，再进行必要的强制类型转化。泛型就是在编译期增加了一道检查而己，目的是促使程序员在使用泛型时安全放置和使用数据。 不过要注意，擦除机制的存在会使重载方法产生相同的类型签名，例如：1234public class MyList&lt;W,T&gt; &#123; void f(List&lt;T&gt; v) &#123;&#125; void f(List&lt;W&gt; v) &#123;&#125;&#125; 所以，当擦除后因为参数问题导致相同的参数列表，要提供不同的方法名。 泛型的好处可能你会疑惑，既然泛型最后也会转化为普通的类，那我们使用泛型的目的是什么？其实泛型的好处包括： 类型安全：放置的是什么，取出来的自然是什么，不用担心会抛出 ClassCastException 异常 提升可读性：从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么 代码复用：泛型合并了同类型的处理代码，使代码复用度变高]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本技术类书籍]]></title>
    <url>%2Fposts%2F59cc6e2d%2F</url>
    <content type="text"><![CDATA[前不久重读了《如何阅读一本书》，这本书成书时并没有计算机相关的读物，在介绍阅读不同读物的方法时，我认为技术类的书籍可能更接近于它里面所提到的科学与数学，而且更多偏实用型而非理论型，并且计算机一类的阐述特定技术的书时新性很强，随着技术的更新换代，很多都会过时，这一点在其他一类的书上没那么明显，一旦过时，其实用性就会大大下降，这里结合我的认知，谈一下关于技术类书籍应该如何阅读。 这里指的阅读，并非粗读或是泛读，虽然很多技术类的书也可以作为手册，需要的时候再进行查阅即可，但也不乏很多经典，它们需要我们细细品读，结合实践会不断提高我们的技术水平。这里总结了一些值得参考的书：每一个程序员都值得读的经典 首先我们明确它是否属于论说类的书籍，其次我们要分析这本书是否属于*理论性的，类似《算法导论》一类的书，还是属于实用性的，类似《effective java》这样的书。 然后我们可以用几句话简单的叙述一下这本书主要讲了啥，将书里面重要的章节列举出来，说明它是如何根据某种逻辑来组成一个相应体系的，进而能够用来解决实际问题。关注作者希望通过这本书来为我们解决一个什么样的具体问题，这个问题属于哪一类别。因为计算机体系的模块化，抽象化和层次化，所以不同的书针对的方向和层次也是不一样的。 然后我们要关注一些重要的名词，看是否在翻译的版本中所要表达的东西是你印象里熟悉的那一个概念，然后我们要关注一些核心重要的部分，因为技术类的书具有很完整的逻辑，我们要对这些重要且难以理解的部分去理顺逻辑，看作者是如何逐步叙述他所要表达的内容的。如果是因为欠缺了某一部分的内容，造成了阅读过程中理解的困难，如果你觉得跳过，并不影响后续阅读，而且它并不属于这本书的核心内容，或是所描述的技术类别已经过时了，那么你可以先跳过。反之，我们可能需要花一些时间去了解一下那些与此相关的我们所不懂的概念，然后再尝试回过头阅读，看逻辑是否通畅，是否能继续读下去。当然这个过程最好的方式就是多实践，将其中的一些能够实现的东西，自己尝试做一下，可能很多不理解的东西就理解了。 在你对作者的一些实践方法作出评价之前，你最好已经明白了它的所有细节，你知道作者想要以此解决的问题，并且你也亲自实现过，然后你才可以对所谓的“最佳实践”作出评判；因为有的“最佳实践”所针对的只是那个特定的历史时期。然后你就可以通过类比得出适合自己的技术实践方式，不断地去更新这些“最佳实践”，可以使你的开发效率和代码质量不断提高。 尊重书中作者和你个人观点的不同，通过实践来证明，是否作者是针对某一特定的环境，而不是普遍的情况，寻找各自的理论基础作为支撑，另外技术类的书更新换代很快，我们在看一些经典“老书”时，要学会判断哪些观点和看法是过时了的，哪些是真知灼见，去吸收那些依然有用的思想洞见。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PO、VO、BO、DTO、POJO、DAO之间的关系]]></title>
    <url>%2Fposts%2Fa24ff975%2F</url>
    <content type="text"><![CDATA[PO（persistant object持久对象）PO 就是数据库中的一条记录，只是把一条记录作为一个对象处理，可以方便的转化为其他对象。有时也被称为Data对象，对应数据库中的 entity 。PO中不应该包含任何对数据库的操作。PO是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。PO有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。PO的属性是跟数据库表的字段一一对应的 VO（value object值对象/view object表现层对象)主要对应界面显示的数据对象,可以和表对应，也可以不，这根据业务的需要。VO是用new关键字创建，由GC回收。存活在业务层，是业务逻辑使用的，他存活的的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！不过，另外一点，如果我们没有使用数据持久层，那么PO和VO也可以是同一个东西，但这并不好。 BO(business object业务对象)主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。它只包含业务对象的属性或是方法，或者二者都包含。 DTO（Data Transfer Object数据传输对象）主要用于远程调用等需要大量传输对象的地方 POJO（plain ordinary java object 简单Java对象）一个最常见的的对象了，只有属性字段及setter和getter方法,属于一个中间对象，可以转化为PO、DTO、VO，一个POJO持久化之后就是PO；POJO在传输过程中，就会转化为DTP，这个传输过程就是DTO；POJO用作表示层就是VO DAO（data access object数据访问对象）学习数据库时遇到最多的对象了，它负责持久层的操作,主要用来封装对数据库的访问，提供数据库的CRUD操作.通过他可以把POJO持久化为PO，]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类的理解]]></title>
    <url>%2Fposts%2Ff7cd9195%2F</url>
    <content type="text"><![CDATA[内部类是一个很实用的特性，可以将一个类定义在另一个类的内部，这就是内部类。内部类自动拥有对外部类成员的所有成员的访问权。可以将其看作一种有效的代码隐藏机制。 内部类的本质对Java虚拟机而言，内部类只是Java编译器的概念，他并不知道内部类是什么，因为每个内部类最终都会被编译为一个独立的类。每一个内部类都可以替换为一个独立的类，就单纯的技术实现而言。内部类可以方便的访问外部类的私有变量，也可以通过 private 或是 protected 关键字，将内部类的实现对外完全隐藏，而一般的类只具有public和默认包访问权限。 如果在内部类里要生成对外部对象的引用，可以使用“外部类.this”，当我们要创建内部类的对象时与平时创建新对象略有不同，需要这样创建：12OutClass oc = new OutClass();OutClass.InnerClass oi = oc.new InnerClass(); 每个内部类都能独立的继承一个接口的实现，不会因为外部类已经实现了某个接口而影响内部类。而且内部类允许继承多个类或抽象类，内部类使得Java的“多重继承”变得更为完整。 内部类可以有多个实例，每个实例都可以有自己的状态，并且和外部类对象相互独立。我们可以在一个外部类中，利用内部类以不同的方式实现同一个接口，或继承同一个类。内部类和外部类之间并不存在“ is-a ”的关系，是独立的实体。内部类很像“闭包”，它具有很多和闭包接近的功能特征，如果你理解闭包，那么更有助于你理解内部类的一些思想。 内部类的划分根据位置和方式的不同，主要有四种内部类 静态内部类 成员内部类 局部内部类 匿名内部类 静态内部类静态内部类有时也被称作嵌套类，静态内部类和静态方法或者静态代码块一样，都需要 static 关键字修饰，一个典型的静态内部类是这样的：1234567891011public class Outer &#123; String name1 = "Tom"; Static String name2 = "King"; public class StaticInner &#123; Static String name3 = "Oliver"; public void show() &#123; System.out.println(name2); System.out.println(name3); &#125; &#125;&#125; 非静态内部类是不能定义静态成员的，同时外部类的静态成员才可以直接使用静态内部类，对于静态内部类来说，也不能访问外部类的实例成员。 静态内部类不能通过“外部类.this”引用外部类的对象，因为它并不存在 this 引用。 静态内部类可以在接口中使用，它也会自动的变为 public static，所以放在接口中的类是静态内部类，只是看上去没有public static，会以为是成员内部类。甚至我们可以在内部类中实现它的外围接口，但对于Java虚拟机来说，内部类最终还是会被看作一个独立的类，而在独立的类中实现接口并不矛盾。12345678public interface ClassInInterface &#123; void hello(); class Test implements ClassInInterface &#123; public void hello() &#123; System.out.println("Hello!"); &#125; &#125;&#125; 定义包内可见静态内部类的方式很常见，这样做的好处是 作用域不会扩散到包外。 可以通过”外部类.内部类”的方式直接访问。 内部类可以访问外部类申的所有静态属性和方法。 成员内部类成员内部类也叫实例内部类，它作为外部类的一个成员存在，与外部类的属性和方法并列，成员内部类持有外部类的引用,只不过这个引用是隐式保存的，指向创建它的外部对象，成员内部类也是最常见的内部类。123456789public class Outer &#123; private int a = 10; public class Inner &#123; int b = 20; public void test() &#123; System.out.println(a+b); &#125; &#125;&#125; 局部内部类局部内部类也叫作方法内部类，它定义在外部类的方法中，局部内部类只在该方法中才能使用。123456789101112public class Outer &#123; public void show() &#123; int a = 2; class MInner &#123; int b = 4; public void test() &#123; System.out.println(a); System.out.println(b); &#125; &#125; &#125;&#125; 如果内部类对象仅仅为外部类的某个方法使用，使用局部内部类，但要注意不能使用 private、protected、public 权限修饰符，因为它不是外部类的一部分，也不能包含静态成员，但它可以访问当前代码块内的常量和外部类的所有成员。 匿名内部类匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制，因为有时候有的内部类只需要创建一个它的对象就可以了，以后再不会用到这个类，这时候使用匿名内部类就比较合适。 匿名内部类使用new创建，没有具体位置，默认继承或实现new后面的类型。匿名内部类编译后生成的.class文件的命名方式是”外部类名称$数字.class”，数字为1，2，3…n，数字为x的文件对应的就是第x个匿名类。 1234567891011public class Outer &#123; public Contents contents() &#123; return new Contents() &#123; //匿名内部类 private int a = 10; public int value() &#123; return a; &#125; &#125;; &#125;&#125; 匿名内部类末位的分号，并不是表示内部类结束，而是表示表达式的结束，只不过这个表达式正好包含了匿名内部类。 如果你需要在匿名内部类中使用一个外部类定义的对象，那么它的参数需要有 final 修饰才能通过编译，因为没有名字，所以也没有显式的构造器可以创建使用。 匿名内部类可以扩展类也可以用来实现接口，但不能二者兼备，而且对于接口来说，也只能实现一个接口。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector、ArrayList、LinkedList的区别]]></title>
    <url>%2Fposts%2F73a15e6%2F</url>
    <content type="text"><![CDATA[关于Vector、ArrayList、LinkedListJava 提供了许多容器类型用以保存对象，合理使用它们可以大大提高开发效率。但不同的容器类型之间也存在着相似和不同，例如：Vector、ArrayList、LinkedList之间具体的区别是什么？ Vector、ArrayList、LinkedList 都是通过集合框架的List实现的，所以在一些功能上十分相似，比如可以通过提供具体的位置进行定位，添加或是删除的操作，都提供了迭代器可以进行内容的遍历，但因为内部设计的差异，在行为、性能和多线程上又有差异。 ArrayList 是可以改变的线程不安全的集合类型。也因为它是线程不安全的所以它的性能要好很多。内部存储使用的是动态数组进行存储，集合扩容时会自动创建更大的数组空间，把原有数据复制到新数组中。 ArrayList 支持对元素的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动其他元素。 Vector 是 Java 早期提供的线程安全的动态数组，它的内部使用对象数组保存数据，可以需要自动增加容量，当数组空间到达上限时，会创建新的数组，将原数据“复制——移动”到新数组。 Vector和ArrayList作为动态数组，它内部的元素都是顺序存储的，很适合需要随机访问的场合，除非我们是在尾部插入删除元素，不然对于随机插入删除元素，需要移动后续所有元素，性能会差很多。实际开发过程，要事先估计应用的操作更偏向插入删除还是随机访问， LinkedList其实就是双向链表，其中的每个对象包含数据的同时还包含指向链表中前一个和后一个元素的引用。它也不用像Vector、ArrayList一样调整容量大小，它也不是线程安全的。与ArrayList相比，LinkedList进行节点插入和删除速度效率更高，但是随机访问速度很慢。 关于集合框架 在Java的集合类里，Collection 接口是所有集合的根节点。它也衍生出了三种类型的集合，分别是 List、Set、Queue。 List 前面已经说了，它提供随机访问以及插入删除的操作，在随机访问效率上更出色。而Set类型不允许出现重复的元素，保证元素的唯一性，很多场合也会需要用到它的这个特性。 如果我们使用的是固定数量的元素，那么既可以选择使用 List ，也可以选择真正的数组，尽管通常来说首选的会是ArrayList，但这种弹性需要开销，而数组的效率要比ArrayList高。而且数组可以持有基本类型，而泛型之前的容器类型则不能。 Queue 是 Java 提供的队列结构的实现类型，除了基本的增删改查操作，它还提供 FIFO （先进先出）、LIFO（后进先出）的行为支持。 每一种具体的集合类型都会被抽象到相应的抽象类中，如 AbstractList、AbstractSet、AbstractQueue ，它们又进一步抽象到 AbstractCollection 类中，实现了接口和实现的分离和结构化。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别浅析]]></title>
    <url>%2Fposts%2F323a1dd8%2F</url>
    <content type="text"><![CDATA[字符串相关类型主要有三种 String、StringBuild、StringBuffer。String是字符串常量，也就是不可改变的对象，而 StringBuffer和StringBuilder 是字符串变量，是可以改变的对象。 String的不可变性String 是只读字符串，典型的 Immutable 类，被声明成为 final class,所有属性也都是 final 的，对它的任何修改，实际上都是创建了一个全新的 String对 象，再把引用指向该对象。String 对象赋值操作后，会在常量池中进行缓存，如果下次创建新对象时，缓存中已经存在需要的String对象，就直接返回相应引用给创建者。 当我们把 String 对象作为方法的参数传递时，实质都是复制一份它的引用，但在方法结束后这个复制引用就消失了，返回的引用会指向一个新的对象，而原引用依然还在原地址，并未修改。 当我们声明一个String对象时：String s = &quot;abc“； 将一个变量赋值给String对象：s1 = s;当我们调用concat方法连接字符串时：s = s.concat(&quot;d&quot;); StringBuffer和StringBuilderStringBuffer 可以在原对象上进行修改，用于解决String拼接时产生大量中间对象的问题，它是线程安全的，也随之带来了额外的性能开销。 StringBuffer 所实现的线程安全是通过把各种修改数据的方法加上 synchronized 关键字实现的，简单粗暴。StringBuilder和StringBuffer均继承自 AbstractStringBuilder ，区别仅在于最终的方法是否加了 synchronized 。该抽象类在内部与 String 一样，也是以字符数组的形式存储字符串的。 StringBuilder是线程不安全的，也正因为如此，它的效率要比StringBuffer高。因为大多数情况下我们是在单线程环境下进行的操作，所以建议用StringBuilder而不用StringBuffer。 需要注意的是，在非基本数据类型的对象中，String 是仅有的支持直接相加操作的对象，很方便进行字符串的拼接，但在循环体内，字符串的拼接方式应该使用 StringBuilder 的append方法进行拼接。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript中的继承机制]]></title>
    <url>%2Fposts%2Fa6e7bbf3%2F</url>
    <content type="text"><![CDATA[原型链传统的面向对象语言里，基本都支持继承的两种方式：接口继承和实现继承。接口继承继承方法签名，而实现继承则继承实际的方法。至于JavaScript里的继承，由于函数没有签名，只能支持实现继承，而且主要通过原型链来实现的。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例又都包含一个指向原型对象的内部指针，通过使用原型，将方法添加在”父类“的原型里，然后”子类“的原型就是父类的一个实例化对象。1SubClass.prototype = new SuperClass() ; 如此层层递进，就构成了实例与原型的链条，这就是原型链。但原型链也有问题，原先实例的属性会在这个继承的过程中顺理成章的成为其“子类”的原型属性。而且创建的”子类“的实例，无法在不影响所有对象实例的情况下，像”超类“的构造函数传递参数，于是有了构造函数继承。 构造函数继承构造函数继承的核心思想就是SuperClass.call(this),通过call()和apply()方法，在新创建的对象上执行构造函数，然后改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题。123456function SuperClass()&#123; this.colors = ["read","blue","yellow"];&#125;function SubClsss()&#123; SuperClass.call(this);&#125; 组合式继承组合式继承，也叫作伪经典继承，结合了前两者的特点，既不会使每个实例化的“子类”互相影响，也避免了内存的浪费。它使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。既可以在原型上定义方法实现实现函数复用，又能保证每个实例都有它自己单独的属性。123456789101112131415161718192021function SuperClass()&#123; this.name = name; this.colors = ["read","blue","yellow"];&#125;SuperClass.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubClass(name, age)&#123; //继承属性 SuperClass.call(this, name); this.age = age&#125;//继承方法SubClass.prototype = new SuperClassSubClass.prototype.constructor = SubClass;SubClass.prototype.sayAge = function() &#123; console.log(this.age);&#125; 寄生式继承寄生式继承的思路是创建一个仅用于封装继承过程的函数，该函数的内部以某种方式来增强对象，然后返回对象，就像所有都是它做的一样，很像工厂模式。12345678function MyClass(original)&#123; //通过调用函数创建一个新对象 var clone = object(original); clone.sayHello = function() &#123; console.log("Hello"); &#125;; return clone;&#125; 不过使用这种模式来为对象添加函数，会因为不能做到函数复用而降低效率，所以出现了寄生组合式继承。 寄生组合式继承组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。集寄生式继承和组合继承的优点于一身，本质上就是使用寄生式继承来继承“超类”的原型，然后再将结果指定给“子类”的原型。123456789101112131415161718192021222324function inheritObject(subClass,superClass) &#123; //复制一份父类的原型保存在变量中 var p = inheritObject(superClass.prototype); //修正因为重写子类原型导致子类constructor属性被修改 p.constructor = subClass; //设置子类的原型 subClass.prototype = p; &#125; //定义父类var SuperClass = function (name) &#123; this.name = name; this.books = ['javascript','html','css'] &#125;;//定义父类原型方法SuperClass.prototype.getBooks = function () &#123; console.log(this.books)&#125;;//定义子类var SubClass = function (name) &#123; SuperClass.call(this,name)&#125;inheritObject(SubClass,SuperClass);var subclass1 = new SubClass('Java')]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何高效提问]]></title>
    <url>%2Fposts%2F95c05072%2F</url>
    <content type="text"><![CDATA[如何提问是一门学问，不会提问的人很难通过问问题解决问题，最终可能变成别人替你“代劳”解决了问题。不懂得如何正确提问，无论是对于你还是对于被问的人都是十分痛苦的，久而久之，别人也失去了帮你解决问题的耐心。所以，如何正确高效的提出一个问题，甚至使得被问的人也能有所收获，是一个很有必要学习的方法。 首先我们要明确我们要问的问题，它属于哪一个范畴，如果是技术类的问题，它又会具体的归为某一个模块，我们可以将问题的范畴逐步确定和缩小。当然，每一个人的能力和水平是不一样的，可能有的人看问题很有针对性，一针见血，他根据他的经验和判断能把问题立马缩减到一个具体的范畴里，而有的人可能只能有个大致的模糊认知。 然后我们要明确我们发问的“对象”，我们最终想要的不过是解决问题的办法，那么除了向其他人提问，是否有更好的方式和其他途径解决问题。例如，善用搜索引擎，我们基本上能解决我们所遇到的大部分问题，尤其是对于技术类的问题，像 stackoverflow 这样的社区，你基本能找到你想要答案，或是阅读相关的文档或是手册，都是不错的办法。而且这样一个搜索的过程，本身也是在不断试错中学习，能使我们对于整个问题的把握更为清晰，下一次遇到同类问题，将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人，举一反三。 不过，不是每次我们都能顺利的找到解决问题的答案，就拿技术类的问题来说，可能由于不同的系统环境，过去能解决的问题的步骤，可能现在不适用了，我们只能不断寻找。这个过程可能会很枯燥漫长，浪费很多时间，虽然我觉得最后发现“蓦然回首，那人却在灯火阑珊处”很舒畅，但这意味着可能这段时间里我们都无法继续推进我们的项目进度，倘若时间又很紧，那么此时可能找正确的人或是正确的论坛发问会是一个不错的办法。 向陌生人发问是充满不确定性的，因为对方并不一定能根据我们对于问题的描述完美的解决我们的问题。如果我们问的问题还不够明确，简洁易懂，可能对方就懵了，所以我们需要： 简单描述你需要完成什么样的需求，最终的目标是什么 简洁明了的叙述你的想法或思路 描述你具体的实现过程，其实就是你做了哪些尝试，最小化的重现问题的步骤 描述遇到的问题，例如报错信息，务必要让问题简单易读 如果是技术类问题，根据情况，再看是否需要给出具体某段实现代码 切记不要问与主题无关的问题，如果是那种通过自己搜索就能很容易找到解决办法的问题，最好不要去问，这类问题在别人看来肤浅甚至觉得你是个不愿独立思考的“lazy boy”，只想依靠别人，浪费别人时间。也不要低声下气，觉得有求于人，要知道一个好的问题，可能会促进双方的共同进步，别人也会因为能帮人解决了一个“难题”而高兴，礼貌客气不代表卑微，反而会增加你得到有用回答的机会，当然前提你事先经过做足了功课，别人也会认为你很有经验，问的问题可能是独到巧妙的。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this原理]]></title>
    <url>%2Fposts%2Fcbb9bef1%2F</url>
    <content type="text"><![CDATA[关于this为啥要有这个关键字呢？如果不使用this，我们在写代码时就需要显示的传入上下文对象。会很麻烦，随着代码量的增多，会使代码变得混乱，而this可以隐式“传递”一个对象的引用，利于代码复用，因为它会动态的判断上下文环境，然后引用合适的上下文对象。 我们可能会在学习时产生片面的误解，一种是我们认为this指向函数自身，另一种是我们认为this指向函数的作用域。因为在一些情况下，它们是对的，但有时却是错误的，举例来说：12345678function foo() &#123;var a = 2;this.bar();&#125;function bar() &#123;console.log( this.a );&#125;foo(); // ReferenceError: a is not defined 如果按之间的观点，那这段代码应该能正确调用，但实则不能，可见this关键字不是我们之前想的那样。 this是什么 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。 理解this的前提，我们需要知道什么叫做调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置，通过调用位置我们才好判断this究竟引用的是什么。 this的指向this永远指向最后调用它的那个对象，通过这句话就能很容易判断this的指向，因为调用位置就在当前正在执行的函数的前一个调用中。 默认绑定12345function foo() &#123;console.log( this.a );&#125;var a = 1;foo(); // 1 我们可以看到，最后调用foo()的地方，它的前面没有明显的调用对象，所以就是全局对象window，相当于window.foo()那么this的指向就是就是window这个全局对象，所以window.a的值就是1。这是默认的绑定情况。 隐式绑定我们有时候还要考虑调用位置是否具有上下文对象，可以看一个例子：12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;obj.foo(); // 1 这就简单了，因为this永远指向最后调用它的那个对象，最后调用它的是obj，所以就相当于obj.a，所以值为1，下面是另一种情况，可能我们调用时是在一个属性引用链上：123456789101112function foo() &#123;console.log( this.a );&#125;var obj2 = &#123;a: 2,foo: foo&#125;;var obj1 = &#123;a: 1,obj2: obj2&#125;;obj1.obj2.foo(); // 2 不用在意obj1，这里我们要强调“最后调用”，所以最后调用的是obj2，obj1先调用obj2，obj2再调用foo(),所以结果就是obj2.a，所以值为2。 但假如我们给函数起了别名，可以通过一个例子看一下：12345678910function foo() &#123;console.log( this.a );&#125;var obj = &#123;a: 1,foo: foo&#125;;var bar = obj.foo; // 函数别名！var a = "hello"; // a 是全局对象的属性bar(); // "hello" 虽然我们将 obj 对象的 foo 方法赋值给变量 bar 了，但是没有调用，所以bar()最后还是被全局对象window调用了，this的指向就是window，就相当于window.a，所以值为hello。 不过我们需要尤为注意回调函数里的this的指向问题，因为回调函数里我们传入的函数，实际上它相当于给里面的形参取了一个别名。当我们分析this的指向时，它实际的指向会被误导，但实质上它还是指向最后调用它的那个对象。 显式绑定如果我们想在某个对象上强制调用函数，可以直接指定this指向的对象，什么意思呢，我们先看一个例子：12345678function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:1&#125;;var a = 2;foo.call( obj ); // 1 我们通过call()函数，将obj的作用域传递进了foo中，因为JavaScript存在一个作用域链，相当于我们window.obj.foo(),所以最后调用的是obj对象，所以值为1。我们把foo的this绑定到了obj上。也可以通过apply()和bind()方法。 new绑定12345function foo(a) &#123;this.a = a;&#125;var bar = new foo(1);console.log( bar.a ); // 1 使用new来调用foo()时，我们会构造一个新对象，这个新对象会绑定到foo()调用中的this上，所以bar.a的值就是1，和隐式绑定里的取别名是不一样的，它依然指向最后调用它的那个对象。 箭头函数ES6里，我们可以使用箭头函数始终指向函数定义时的this，不用担心执行时改变，在箭头函数里也没有this绑定了，上面四条绑定原则也不存在了，要根据作用域链来决定它的值，箭头函数会继承外层函数调用的 this 绑定。12345678910111213var a = "hello";var ogj = &#123; b : "hi" func1: function () &#123; console.log(this.b); &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;obj.func2() // hi 总结总之，我们要记住”this永远指向最后调用它的那个对象“，具体绑定的方式，如果是由new调用，那它就绑定到了新创建的对象上，如果由call()、apply()、bind()调用，那么就是在绑定的那个对象上，如果包含上下文调用的隐式绑定，要注意上下文对象，如果包含回调函数，要格外小心。如果使用了箭头函数，注意根据作用域链来决定“this”的指向。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、finally、finalize的区别]]></title>
    <url>%2Fposts%2F928edaac%2F</url>
    <content type="text"><![CDATA[final关键字使用到final的三种情况：变量、方法、类，分别具有不同意义。 final 的变量是不可以修改的，一个既是 static 又是 final 的变量只占据一段不能改变的存储空间，是一个常量。 使用 final 修饰方法是为了把方法锁定，防止任何继承类修改它的含义，确保在继承中方法的行为不变，不会被覆盖重写。 类中所有用 private 修饰的方法隐式都是final的，但给它们再加上 final 关键字没有意义，因为private修饰的方法，本身局无法覆盖重写。 final 修饰的类表示不可继承，不能拥有子类，而其中的方法默认隐式也都是 final 的，无法覆盖重写。 final并不等同于immutable ，尽管看起来语义上某些地方final很像是immutable。 关于finallyfinally 则是 Java 保证重点代码一定要被执行的一种机制。搭配 try-finally 或者 try-catch-final 来进行类似关闭 JDBC 连接等的操作。不过更推荐在JDK7后添加的 try-with-resources 语句，对于关闭连接等资源。 finally 使得无论 try 块里发生了什么，内存总能得到释放，当要把除内存之外的资源恢复到它们的初试状态时，就要适用finally 子句。不过如果 finally 子句中包含了 return 语句，这个返回值就会覆盖原始的返回值。 因为finally总是会执行，但如果在finally之前执行了System。exit(1);，finally里面的代码就不会被执行。 finalize方法finalize 是基础类 java.lang.Object的一个方法，是为了保证对象在被垃圾收集前完成特定资源的回收。在 JDK9 之后直接被标记为过时方法，并不推荐使用了。 我们无法保证finalize什么时候执行，是否符合预期，]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈产品需求分析]]></title>
    <url>%2Fposts%2Fe380f54d%2F</url>
    <content type="text"><![CDATA[对于一个好的产品而言，我们要确立标准，培养用户对于产品的习惯性的认知，它的外观是不是具有标志性，我们能在众多的产品中不用花费很多心力就将它识别出来。就像苹果公司的产品，它的工艺设计就是它最明显的标志，哪怕外形做到和它类似的同类产品，但我们也能一眼识别出哪一个是苹果公司的产品。 其次，好的产品它的哪些功能具有特色，并且是它所独有的，它完成同样的任务就是比一般的同类产品好。因为用户选择我们的产品，出发点更多是为了很好的解决他们手头所需要应对的任务，所以功能应该比外观更为重要。而且这些功能要易于使用，它的用户群体可以不用面对很高的门槛就能轻松使用。 就像创新扩散理论里提到的认知特征的几个方面： 相对优越性，它相对于其他同类产品是否更优越，体现在什么方面。 兼容性，它和生活的融合度如何，是否能够在生活中有应用的可能性。 复杂性，它是否操作简单，利于人们上手直接操作，门槛低。 可实验性，它是否具有试用的机会，而且实验过后能否把握用户的痛点，让用户能喜欢，形成用户粘度。 可观察性，新技术的显示度如何，是否能引起广泛的社会讨论，这个可能需要运营来促进这一过程的推进，提高技术曝光度。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析Java的static关键字]]></title>
    <url>%2Fposts%2Fb43f4028%2F</url>
    <content type="text"><![CDATA[关于static关键字当我们创建一个对象时，相应的也会为对象分配一块数据存储空间，然后再调用对象的方法。但有时我们也需要一块独立的数据存储空间，而不用去纠结创建多少个对象，甚至不用创建对象，也能去调用方法，为此引入了static关键字。 当声明一个方法或是域为static时，它就不会与包含它的那个类的任何对象实例关联在一起。即使从未创建对象，也可以调用其static方法或是访问static域，通过类名直接引用。而且仅占用固定的数据存储空间。 静态方法通过 static 修饰的方法称为静态方法，静态方法又称为类方法。本质其实就是没有 this 的方法，在没有任何对象的前提下，可以仅仅通过类本身来调用 static 方法，这一点上看有点全局方法的意味，但Java里是禁止使用全局方法的。如果具有其他语言基础，要注意Java里static关键字修饰的方法与全局方法的不同，并非等价，Java中的static关键字不会影响到变量或者方法的作用域。 一个方法是静态的，它的行为也不会具有多态性。对于构造器来说，即使没有显式的使用static关键字修饰，但构造器实际也是静态方法，所以构造器并不具有多态性。 使用静态方法需要注意： 静态方法中不能使用实例成员变量和实例方法 静态方法不能使用super和this关键字 通常静态方法用于定义工具类的方法，静态方法如果使用了可修改的对象，那么在并发时会存在线程安全问题。所以，工具类的静态方法与单例通常是相伴而生的。 静态变量通过static修饰的变量称为静态变量，静态变量又称为类变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰，没有被静态修饰的内容，其实是属于对象的特殊描述。 静态变量的生命周期和成员变量不同，成员变量随对象的创建而存在，随着对象回收而释放。而静态变量随着类的加载而产生，随着类的消失才消失。 静态代码块静态代码块在类加载的时候就被调用，并且只执行一次。静态代码块是先于构造方法执行的特殊代码块。静态代码块不能存在于任何方法体内，包括类静态方法和属性变量。 静态内部类在内部类里，通过 static 修饰的内部类就是静态内部类。如：static class StaticInnerClass{} 定义静态内部类的好处有： 作用域不会扩散到包外 外部可以通过OutClass.StaticInnerClass的方式直接访问 内部类可以访问外部类中的所有静态属性和方法。 初始化顺序由于static关键字的存在，对于初始化顺序需要格外注意，静态初始化只在类首次加载的时候进行一次。单类初始化顺序，一般是按：静态变量 &gt; 静态代码块 &gt; 成员变量 &gt; 非静态代码块 &gt; 构造器12345678910111213141516171819202122public class ClassTest &#123; public static String staticField = "静态变量"; static &#123; System.out.println("静态代码块"); &#125; private String field = "成员变量"; &#123; System.out.println("非静态代码块"); &#125; public ClassTest() &#123; System.out.println("构造器"); &#125; public static void main(String[] args) &#123; ClassTest a = new ClassTest(); &#125;&#125; 程序输出：12345静态变量静态代码块成员变量非静态代码块构造器 对于静态变量和静态代码块而言，它们的初始化顺序是由在类中的顺序决定，而不是静态变量一定先于静态代码块进行初始化。只是相对于成员变量和非静态代码块，它们优先级更高。 对于包含继承关系的父类和子类初始化顺序，也可以通过一个例子进行测试：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Parent &#123; private static String parentStaticField = "父类-静态变量"; static &#123; System.out.println(parentStaticField); System.out.println("父类-静态代码块"); &#125; private String parentField = "父类-成员变量"; &#123; System.out.println(parentField); System.out.println("父类-非静态代码块"); &#125; public Parent() &#123; System.out.println("父类-构造器"); &#125;&#125;public class Child extends Parent &#123; private static String childStaticField = "子类-静态变量"; static &#123; System.out.println(childStaticField); System.out.println("子类-静态代码块"); &#125; private String childField = "子类-成员变量"; &#123; System.out.println(childField); System.out.println("子类-非静态代码块"); &#125; public Child() &#123; System.out.println("子类-构造器"); &#125; public static void main(String[] args) &#123; new Child(); &#125;&#125; 程序输出：12345678910父类-静态变量父类-静态代码块子类-静态变量子类-静态代码块父类-成员变量父类-非静态代码块父类-构造器子类-成员变量子类-非静态代码块子类-构造器 可以得出一个结论：父类静态变量 &gt; 父类静态代码块 &gt; 子类静态变量 &gt; 子类静态代码块 &gt; 父类成员变量 &gt; 父类非静态代码块 &gt; 父类构造器 &gt; 子类成员变量 &gt; 子类非静态代码块 &gt; 子类构造器 总体上，父类静态初始化先于子类静态初始化进行，而静态变量和静态代码块的执行顺序由类中具体的顺序决定，然后再依次从父类进行初始化再到子类。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript的闭包]]></title>
    <url>%2Fposts%2F7fd81dde%2F</url>
    <content type="text"><![CDATA[JavaScript里的闭包是它的一个特色，这也是静态语言所不具备的一个特性，很多高级功能都依靠闭包来实现，理解闭包其实一点都不困难。 变量作用域理解闭包的前提是理解JavaScript的变量作用域，变量的作用域分为全局变量和局部变量， JavaScript具有基于函数的作用域，每声明一个函数都会为其自身创建一个自己的执行环境，而且在函数内部就可以直接访问全局变量。12345var a = 1function func1()&#123; console.log(a);&#125;func1(); // 1 但是在函数外是无法访问函数内的局部变量的。不过如果不使用var关键字，就会在内部作用域声明一个全局变量。1234function func1()&#123; var a = 1&#125;console.log(a); // error 这里就涉及到一个问题，假如我们需要读取函数内部的变量怎么办？于是我们只能在函数的内部再定义一个函数。123456789function func1()&#123; var a = 1 function func2()&#123; console.log(a); &#125; return func2;&#125;var n = func1();n(); // 1 此时，func1内的所有局部变量对于func2来说都是可见的，func1的返回值，也就是func2（），赋值给变量n，然后调用n(),实际只是通过不同的标识符来引用调用了内部的函数func2(). 闭包说了半天，那么闭包到底是啥，我的理解是：闭包就是函数的局部变量的集合，能够读取其他函数的局部变量，只有定义在函数内部的子函数才可以获取局部变量，当一个函数定义在另一个函数内，并且试图通过子函数获得局部变量，它就是闭包。 闭包使得函数内部作用域和函数外部作用域的连接成为了可能，局部变量可以在函数返回后被访问，而且闭包里变量的值可以始终保持在内存中，我们可以通过一个例子来看：123456789101112131415function func1()&#123; var n=1; Add = function()&#123; n += 1 &#125; function func2()&#123; console.log(n); &#125; return func2;&#125;var result = func1();result(); // 1Add();result(); // 2 可以看到局部变量n一直保存在内存中，不会随着函数调用的结束而被垃圾回收，func2是func1的子函数，但作为func1的返回值，却被赋值给了一个全局变量result，这就使得func2始终在内存中，因为func2的存在依赖于func1，所以func1也就跟着保存在了内存中。 前面提到，如果不使用var关键字，会在内部声明一个全局变量，所以Add就是一个全局变量，但它可以在函数外部对内部的局部变量进行操作，实则它也是一个闭包。 过渡的使用闭包，内存消耗会很大，但闭包的用处也很多，在定时器、事件监听器、Ajax 请求、跨窗口通信或者任何其他的异步或者同步任务中，只要使用了回调函数，实际上就是在使用闭包。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中医与程序员]]></title>
    <url>%2Fposts%2Fbf0d7143%2F</url>
    <content type="text"><![CDATA[在我看来，计算机产业还是一个很“年轻”的行业，相比于其他传统的行业起步要晚，但它发展迅猛，短短几十年便跻身影响当今世界发展的重要产业之一。而且从事计算机这个行业可以说“门槛”很低，这个门槛并不是入行的门槛，而是能让你不断提高有机会成为这个领域大牛的门槛，相对于其他复杂度接近的行业来说。因为技术是相对开放和自由的，只要你愿意，你能获得很多的资源，像 Github这样的开源社区，亦或是 stackoverflow 这样的技术问答网站，你都能从中了解和学习到很多流行的技术。 计算机科学里很多概念可以让我们从一种新的角度来理解事物，若利用得当，可以避免陷入解决不同问题时，总用使用“一把锤子”的思维局限，不同的问题若用同样的方式来处理，真的一定能把问题完美处理好吗？ 例如中医和西医，如果从计算机专业的角度，中医更像是“应用型程序员”，他们通过现有的框架和API的调用，建立在抽象的角度来解决不同的问题，为此他们需要熟知各类方法，API接口的作用和组合后产生的影响，很像中医里对草药作用的了解和应用。 《thinking Java》里说“万物皆为对象”，其实创造这些草药的“库程序员”正是大自然本身，它所采用的构建方式极其复杂，抽象层次很高，它把这一系列的细节都已经封装好了，使得传统中医并不需要知道这些草药中究竟是哪一具体的物质是对特定病症有效的，因为“草药对象”本身封装了“数据”和“方法”，传统中医只需知道它们的作用以及用法对症下药即可。 西医与中医不同，对于医药研究来说，它们更像是“库程序员”，需要对自然界不同的物质进行分析、提取和研究，以便真正弄清是哪一具体物质对人体的哪一具体细胞组织产生作用，因而也要研究人体的生理层次的构造。或是进行组合，看这种变化是否符合预期，而对于产生作用了的新物质，会用一个特定的标识符来为其命名。 但有一个问题，它们所研究的这些“对象”本身就是由自然界这个最伟大的“库程序员”经历漫长的演化而来的，所以生命是伟大的，看似简单，但那是因为它们“构建”于不同的抽象层次并封装了一系列的实现细节，我们研究“抽象”，而“抽象”也形塑我们。 西医的一些研究过程，就如同抽丝剥茧般的去“解封装”，通过不同的工具去试图解构更底层的实现，通过了解物质之间的相互作用，就能获取特定的物质，再以此为基础研究新型的药物，这些新药是“自然界”之前所没有的，被人为创造出来，如同通过一个旧有的框架和库，依托于它产生了一个新的框架和库。 有趣的是，中医更多依赖于于大自然这个“标准库”，依靠大自然这位最伟大的“库程序员”来提供解决问题的方法，而西医更多通过“解封装”，再进行抽象的形式自建“第三方库”，来解决问题，谈不上哪个更为高明，本质上就是不同的。西医也无法保证，已经“解封装”到了最底层，弄清了各个原子对象及其所有实现细节，需要不断地去推进对于“对象构建”本身的研究。而中医也不可能完全驾驭“自然界”这个庞大的库，因为宇宙是无垠而未知的，我们对它的探索也远未到极限。 只要存在了可能性，中医也好西医也罢都会在各自的道路上不断前进。那个推动我们朝一个领域前进的动力又是什么呢？]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式小记]]></title>
    <url>%2Fposts%2F12f92ebd%2F</url>
    <content type="text"><![CDATA[关于正则表达式正则表达式是为了从大量数据中检索匹配出所需数据的一种强有力的工具，它赋予使用者描述和分析文本的能力，如果没有正则表达式，我们也可以实现同样的功能，只是需要通过循环遍历，通过大量的条件判断才能得到想要的结果。而正则表达式只需要简单的而命令，就能够检索所有文件。 常用元字符“ . “: 使用.字符匹配任意单个字符、字母、数字或者.字符本身，不过要在.的前面加上 \ ，对它进行转义，匹配其他元字符也一样。“^”: 使用^会匹配行或者字符串的起始位置“$”: 使用$会匹配行或者字符串的末位“\d”: 匹配数字，如果是匹配非数字字符，只用把d大写就行\D“\w”: 匹配字母数字和下划线，等价于[a-zA-Z0-9_],如果是匹配非字母数字或下划线字符，只用把w大写就行\W“\s”: 匹配空白字符，如果是匹配非空白字符，只用把s大写就行\S“\b”: 匹配一个单词的开始或是结尾，这个“单词”在正则表达式看来就是一个与\w相匹配的字符和一个与\W相匹配的字符之间的位置，它只匹配一个位置，不匹配任何字符，\B表示不匹配一个单词的边界“ [ ] “: 只匹配括号内定义的字符集合，字符集合可以按字符区间来表示区间内所有字符，以下是一些合法的字符区间例子: A-Z 匹配A到Z的所有大写字母 a-z 匹配A到Z的所有小写字母 A-z 匹配ASCII字符A到ASCALL字符z的所有字符，其中也包含[或是^等类似字符，可能匹配到多余结果。 POSIX字符类POSIX字符类是一种正则表达式的简写形式，可以通过元字符和POSIX字符类的组合来简化正则表达式。 重复匹配正则表达式可以进行重复匹配，匹配多个连续出现的字符或者字符集。 “ * “：匹配零次或多次例如：a*会匹配到所有的字符或字符集为”a”的情况 “ + “：匹配一次或多次，至少一次例如：a+会匹配到字符或字符集中为”a”的情况，a+与a*不同在于”+”至少是一次而”*” 可以是0次 “ ? “：匹配零次或一次例如：a?只会匹配一次，也就是结果可能只有单个字符a “{n}”：重复n次匹配例如：a{3}结果就是匹配到满足3个a字符的情况 “aaa” “{n,m}”：重复n到m次匹配例如：a{2,3} 将a重复匹配2次或者3次 所以匹配到的字符可以是两个”aa”也可以是三个”aaa” “{n,}”：重复n次或更多次匹配，至少匹配n次 子表达式子表达式是为了解决一些特殊匹配情况下使用的，使用一对圆括号把正则表达式括起来，按我的理解，其实它就是解决一个优先级和整体匹配的问题，类似于C语言里的双括号，为了显式增强操作符优先级顺序，避免混乱。 举个例子：&amp;nbsp;{2,4} 这个正则表达式的原意是为了匹配&amp;nbsp两次到四次，但实际{2,4}只作用于它的前一个字符，相当于它只会匹配到&amp;nbsp;; 、 &amp;nbsp;;; 、 &amp;nbsp;;;;。 所以引入了子表达式，(&amp;nbsp;){2,4}这样就能按我们预期的结果进行匹配了，它会把&amp;nbsp;看成一个整体进行匹配。 子表达式也是可以进行嵌套使用的，但我们要尽量避免嵌套次数过多引起的逻辑混乱，阅读困难。 常见问题的正则表达式这里是一些网上搜集的常见的正则表达式匹配的例子，学习正则表达式最好的方式就是多练习多思考，通过这些简单的例子作为参考来学习，由浅入深，而不是直接复制拿来用，真正掌握了正则表达式才能灵活应对各种情况。它仅仅是一个方法的参考，而非方法本身。 检验数字 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m - n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1 - 2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1 - 3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 非零的负整数： ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 非负浮点数：^\d+(\.\d+)?$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 浮点数：^(-?\d+)(\.\d+)?$ 校验字符 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 可以输入含有\^\%\&amp;\’\,\;\=\?\$\“等字符：[^%&amp;&#39;,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 其他需求 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? URL地址：^https?://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^([1][3,4,5,6,7,8,9])\d{9}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[\da-zA-Z]{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代，如果你觉得空字符串也可以接受的话，最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 双字节字符 (包括汉字在内，可以用来计算字符串的长度，一个双字节字符长度计2，ASCII字符计1)：[^\x00-\xff] 空白行的正则表达式 (可以用来删除空白行，windows的换行是\n\r，而linux和unix中换行是\n，这点需要注意)：\n\s*\r HTML标记 (仅仅能部分匹配，对于复杂的嵌套标记依旧无能为力)：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; 首尾空白字符(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等，非常实用)：^\s*|\s*$或(^\s*)|(\s*$) 腾讯QQ号(腾讯QQ号从10000开始) ：[1-9][0-9]{4,} 中国邮政编码 (中国邮政编码为6位数字)：[1-9]\d{5}(?!\d) IP地址 (提取IP地址时有用)：(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5])) 或 ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 参考文章： http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些值得参考的摄影名言]]></title>
    <url>%2Fposts%2F74940404%2F</url>
    <content type="text"><![CDATA[“Your first 10000 photographs are your worst.“你拍的前一万张照片都是拙劣的。 “Think about the photo before and after, never during. The secret is to take your time. You mustn’t go too fast. The subject must forget about you. Then, how ever, you must be very quick.”在摄影之前和之后思考，而不是在摄影的过程中。街头摄影的奥秘在于放慢步调，仔细斟酌。拍摄的主题必须要看不到你的存在，而此时你的速度必须要很快。 “The most difficult thing for me is a portrait. You have to try and put your camera between the skin of a person and his shirt”对我来说最难的是肖像摄影。你必须要将摄影机放置在一个人的皮肤与他的衣服之间适当的位置。 “The single most important component of a camera is the twelve inches behind it.”摄影机最重要的元件是它后方十二寸的那玩意儿。 “A good photograph is knowing where to stand”一张好的照片是知道该在哪驻足。 “A true photograph need not be explained nor can it be contained in words”真正的摄影作品不需要言语去描述它，因为它也无法用言语来表达。 “If I saw something in my viewfinder that looked familiar to me, I would do something to shake it up.”如果我透过取景器看到某个我觉得熟悉的东西，我会试着去从不同的视角出发重新看一遍。 “The best camera is the one that is with you”最好的相机就是你需要时恰好在你身边的那一个。 “The best camera is the one that you left at home.”优秀的相机是你忘在家里的那台。（如果“home”是手机，那或许就是某一个下载的优秀的摄影软件了，哈哈） “Everyone will take one great picture, I’ve done better because I’ve taken two.”每个人都有机会拍出一张很棒的照片，我比较厉害是因为我拍出两张。 “You cannot depend on your eyes if your imagination is out of focus”当你的想像力无法集中时不能依赖你的眼睛。 “If you can smell the street by looking at the photo, it’s a street photograph”如果你在看照片的时候能嗅到大街的气息，那就是街头摄影。 “All photography is propaganda”所有的照片都是一种宣传。 “I have discovered photography. Now I can kill myself. I have nothing else to learn.”我终于了解了摄影，现在我可以自杀了，因为我已经没什么好学的了。 “If you keep your cool, you’ll get everything”如果你能保持冷静，那你将能得到一切。 “Great photograph is about depth of feeling, not depth of field”好的照片在于情感的深度，而非景深。 “Sometimes the simplest picture are the hardest to get”很多时候最简单的照片反而是最难拍的。 “Which of my photographs is my favorite? The one I’m going to take tomorrow.”你问我最喜欢自己拍的哪张照片？那就是我明天要拍的那一张。 “It’s not what you look at that matters, it’s what you see.”摄影跟你看到什么事物没有太大的联系，而是取决于你是如何看的。 “My life is shaped by the urgent need to wander and observe, and my camera is my passport.”我的生命是以不断想到处寻觅的急迫感所形成，而相机就是我的护照。 “I am forever chasing light. Light turns the ordinary into the magical”我不断追逐着光，光能化腐朽为神奇。 “I only use a camera like I use a toothbrush. It does the job.”我的相机就跟我的牙刷一样，它做着它本职的工作，就是拍照。 “Don’t pack up your camera until You’ve left the location”别把相机收起来，除非你要离开拍摄现场。 “I’m a Tourist”我是个观光客。 风光摄影并不意味着风景一定是作品中最重要的元素，摄影师心中的风光才是作品的灵魂所在。光线，构图和影调都能被用于情绪的表达和传递。 在时间的概念中！没有任何两者是绝对相同的，因为任何事物都会随着时间消逝，因此，每一时刻都为摄影提供了无限可能！ 打破创意的界限：如果某一瞬间是值得被拍下来的，那么，就算成功的概率不高，也同样值得一试。毕竟，胶片相对来说还是比较便宜的，而数据储存卡也可以反复使用。勇于挑战摄影的极限会获得超乎想象的意外收获。 对影像倾注感情，并不代表要将影像修饰得浓、重或阴沉。但作为一张可塑性较强的，底片或数字文件，它们必须具备完整的影调范围，为后期调整和印制提供最大的自由度。 使用做工精细的木制相机和品质优异的顶级镜头是一件多么令人愉悦的事啊，但如果摄影师过分依赖器材，他将不会拥有别具一格的视角，以及对光线的解读能力。 风光摄影的挑战在于个性化的方式表达。众所周知，那些为人所熟悉的场景更需要新鲜的视角。 再三研读杂志里提供的所谓“黄金法则＂是徒劳无功的，因为影像的表达是源自内心的感动，而非别人为你制定的一张富有表现力的照片也许是精巧的，也许是浓重的， 摄影是一种让人去感受的途径，令人感动和感到爱。被摄在照片上的会直到永远，而它能够在你忘记所有后，仍然令你想起那些小事情。 摄影是一项观察的艺术。摄影就是在平凡的地方寻找不平凡之处，而这与你所见到的东西无太大关系，真正重要的是你怎样去看事物的方式。 摄影是捕捉一个转眼即逝但却真实的瞬间。 照片是秘密中的秘密。它说得越多，你知道的就越少。 摄影是虚拟现实，它的作用就是帮助你产生一种置身在另一世界的幻觉。 摄影是从时间中抽出一个瞬间，通过它来改变生活。 摄影是塑造人类感知的要素。 摄影既是世上最简单的事，也是最复杂的事，因为难以使它发挥真正作用。 摄影是一个瞬间，让人在半秒钟内获得照片，去记录当刻的他们。 摄影是一种即时反应，而绘画是一种沉思。 摄影是在认知到当下是重要时刻的同时，以准确的画面铺排去表现所发生的事。 摄影不仅是思想交流的媒介，也是创作的艺术。 摄影是找出相框内发生什么事。当人把事实加上四个边框，事实就被改变。 摄影是真理，而电影是每秒 24 次的真理。 摄影是简单的事，你只是对你看到的反应，并拍很多很多的照片。 摄影在社会上是微小的声音，但一张或一组照片可以引起人的意识。 摄影是现实，奇妙的是它变得比现实更真实。 摄影是区别自己及工作的行为，也帮我看得更清楚我这是在做什么。 摄影是向人类解释人类。 摄影是最简单的媒介，几乎任何人都可以胜任。摄影也是最难的媒介，因为要有独特的个人触觉和风格。]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于指针和数组]]></title>
    <url>%2Fposts%2F725972d9%2F</url>
    <content type="text"><![CDATA[数组和指针之间的关系很微妙，我们有时会遇到这样的例子，对于a[2]这样的数组，其实就相当于*(a + 2)，然后我们就自然而然地认为数组和指针是一样的了，可以互换，除非是在我们实际应用过程中出现了问题，我们才会在不断修正中明白，其实数组和指针并不同，只有在满足一些条件的情况下，数组和指针才可以进行互换。 指针和数组的不同指针是用来保存数据的地址的变量，而数组则是用来保存数据；我们可以通过指针进行间接访问，取得里面的地址值，再通过那个地址值提取数据，如果p是一个指针，它有一个下标，例如p[2],它就把指针里储存的地址值与2相加，再从这个新地址求值，而数组则是直接访问数据，a[2]只是简单的以a + 2的偏移量取得数据。指针通常指向匿名数据，而数组自身就是数据名，所以指针依赖于malloc(),free()这类函数来解决内存问题，而数组的话则是隐式的分配和删除。 什么情况下指针可以和数组互换首先表达式里的数组名被编译器当做一个指向该数组第一个元素的指针时，例如1int a[5],*b,i = 2; 那么我们访问a[i]时，可以通过以下方式12b = a;b[i]; 12b = a;*(b+i); 12b = a + i;*b; C语言把数组下标改写为指针偏移量的根本原因是因为指针和偏移量是底层硬件使用的基本模型。当下标总是与指针的偏移量相同时，就可以互换。例如：12for(i = 0; i&lt;=10; i ++) a[i] = 0; 相当于123b = a;for (i = 0; i&lt;=10; i++) b[i] = 0; 其中的b[i] = 0又可以写成*(b + i) = 0 如果声明是int *a[]呢，由于下标的优先级更高所以它表示一个数组，它里面的元素类型是指向整型的指针，所以它相当于一个指针数组。指针数组最频繁的用处在于储存长度不同的字符串，因为你不用固定分配大小去浪费储存空间，指针数组更具动态扩展性。 我们可以使用括号，使得int (*a)[]，那么它就表示一个指向整型数组的指针。 还有一种情况数组名等于指针，那就是当一个数组作为函数参数时，因为编译器会把数组的形式改写为指向数组的第一个元素的指针的形式，它只向函数传递一个地址值，而不是整个数组的拷贝，这更多是出于效率考虑。例如int (*abc())[10],abc是一个函数，它返回一个指向包含10个int元素的数组的指针。 在C语言中，严格来说，函数是不能直接返回函数和数组的，但可以让函数返回一个指向任何数据类型的指针，例如int *a(),它的返回值是一个指向整型的指针，而int (*a)()，左边的一对对括号迫使间接访问在函数调用之前进行，使a成为一个函数指针,它所指向的函数返回一个整型值。 我们再来看下int *(*a)(),它所指向的函数的返回值是一个指向整型的指针。如果声明是int (*a[])()，可能有点复杂，但实质上它表示一个数组，数组的类型是指向函数的指针，它所指向的函数的返回值是一个整数，如果声明是int *(*a[])()，我们就知道，它表示一个数组，数组的类型是指向函数的指针，而它所指向的函数的返回值是一个指向整型的指针。 关于指针和多维数组对于C语言而言，定义和引用一个多维数组的办法就是使用数组的数组，也就是数组的嵌套，例如a[3][5]，那么a是啥呢，我们可以把它看作是一个一维数组，它包含三个元素，每个元素包含五个整型值，所以a所指向的就是一个包含五个元素的数组而a+1就相当于指向a的另一行数组，如果是*(a+1)则表示它指向那一行的第一个元素而*（a+1)+1，其实就相当于比原来的表达式向后移动了一个元素，如果对整个表达式进一步处理一下，*(*（a+1)+1),那么它作为右值就相当于对那个位置的值间接引用，而作为左值，这个位置就代表那块空间，它可以被赋予新值。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和操作符]]></title>
    <url>%2Fposts%2F857245dc%2F</url>
    <content type="text"><![CDATA[关于操作符你需要知道在谈论指针之前，我们很有必要说一下C语言里的操作符，C语言里有着种类繁多的各式操作符，大致可以分为算术操作符（+ - / %）、移位操作符（&lt;&lt; &gt;&gt;）、位操作符（&amp; | ^）、赋值符（=）、复合赋值符（+= -= = %= /= &lt;&lt;= &gt;&gt;= &amp;= |= ^=）、单目操作符（! ++ – - &amp; sizeof ~ + ）关系操作符（&gt; &lt; == &gt;= &lt;= !=）逻辑操作符（&amp;&amp; ||）条件操作符（expression1 ? expression2 : expression3）、*逗号操作符（,）。 操作符的复杂主要体现在它的优先级和结合性，两个相邻的操作符哪一个先执行取决于它的优先级，在它们优先级相同的情况下又要考虑它们的结合性，是左结合还是右结合，尤其是和指针联系在一起时更容易产生错误的执行结果，因为相对于其他语言，诸如Java、Python来说，指针是C语言的一个特色，也是一个难点。 对于操作符的优先级问题，可能一个最直接有效的办法就是添加括号，但是当表达式有太多的括号时反而不容易理解，所以适当的记住一些常见易混的操作符优先级，并适当的使用括号来辅助理解是一种很不错的方法。为此我们需要记住任何一个逻辑运算符的优先级都要低于任何一个关系运算符，而移位操作符的优先级比算术操作符要低，但要比关系操作符高。 关于指针你需要知道指针实质是表示内存地址的变量，指针主要做两件事：避免副本和共享数据。由于C语言中的一切函数调用，值传递都是“按值传递”的，它会创建一个拷贝的副本来进行操作，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成，也就是“按址传递”，而这个过程数据是共享的。所有赋值都会复制数据，如果你想复制数据的引用，就应该赋指针。 对指针进行间接访问之前，要确认它们已经被初始化，否则仅仅声明了一个指针却没有对他进行初始化，例如：12int *a;*a = 12; 是无法得知它的正确地址的，因为声明一个指针变量并不会分配任何内存。 指针和操作符的问题举个例子，就拿以下代码来说12int ab = 4;int *cp = &amp;ab; 当不同的表达式作为左值和右值时，它们表达的东西是不同的，对于左值来说，他表示的是一块明确的地址空间，而右值是一块地址空间里的值。 当我们的表达式是&amp;ab时，作为右值他表示变量ab的储存空间地址值，他也有一个地方来储存这个值，但我们没办法知道那块空间的具体位置，没有标识是一个明确的特定位置，所以作为左值，使用取址操作符的变量都是非法的。 当我们的表达式是cp时，作为左值他就表示的是cp本身的地址空间，作为右值就是表示变量ab的地址值。 当我们的表达式是&amp;cp时，我们知道它不能作为左值，对于右值来说，他是一个空间地址的值，也就是指针变量所在的那块空间的地址值，而指针变量中又保存着他指向那个对象的地址值，也就是指针的指针。对于指针的指针，类似于int **a,只有当确实需要时，才应该使用多层间接访问，不然程序会变得难以维护和理解。 当我们的表达式是*cp时，它相当于一个间接访问(解引用)，作为左值就表示ab所在那块空间，我们可以将新的值作为右值替换掉里面的原内容，作为右值就表示那块空间里原本存放的内容。 当我们的表达式是*cp + 1时，由于*操作符的优先级高于+，所以首先执行*cp,作为右值，也就是ab里保存的内容4,所以作为右值的结果就是5，但作为左值，我们知道这个结果需要一个位置保存，但那个位置没有明确定义，所以作为左值是不合法的。 当我们的表达式是*(cp + 1)时,作为右值，我们知道cp它表示ab的地址值，由于有括号，所以优先级更高，地址值+1后对那块地址值空间进行间接引用，获得那块空间里保存的对象。 涉及到前置和后置递增递减运算符时，可能是最容易产生错误的了，无论是遇到前置递增（递减）操作符还是后置递增（递减）操作符时，它都会产生一个原指针的拷贝，也就是里面所保存的指向某一内容的地址值，然后拷贝的这个地址值会放到一个新的空间里，如果是前置递增（递减）操作符会先进行原地址值的自增（自减）操作，所以他复制的拷贝会是自增（自减）后的新地址值，然后新的指针和原指针都将指向一个新的位置，并可以在拷贝上执行间接访问操作，访问那个未知的值；如果是后置，不会先进行自增操作求值，所以拷贝的值会是原指针的地址值，它和原指针指向相同的位置，而之前保存地址的那个位置将进行自增/自减操作，地址值更新并指向一个新的位置，由于我们是在拷贝的指针上执行间接访问操作，所以依然指向原地址值。C语言中所有对象，包括指针本身都是 “复制传值” 传递。例如： ++cp,在进行运算前它会先获取一个自增后的拷贝，我们知道作为右值时，cp代表的就是ab那个位置的地址值，由于自增，所以指向它的下一个地址值，但作为左值，因为自增后的拷贝结果是位于一个无法清晰定义的位置，所以不能作为左值。 cp++,由于是后置自增运算，所以不会先进行自增操作，所以拷贝的值的位置依然指向原地址，而原cp会在运算结束后求值，所以它会指向ab位置的下一块内存空间。 *++cp，通过++cp我们知道它指向的是ab的下一块内存空间，由于*的操作符优先级要比自增（自减）操作符低，所以它相当于(*(++cp))，对那块空间执行间接引用，作为左值时表示那块空间的地址，作为右值则表示那块空间里存储的未知值。 *cp++,通过运算符优先级我们知道，它相当于(*(cp++)),由于cp++的结果是指向ab，所以作为左值*cp++就表示ab所在的那个地址空间，而作为右值，它就是ab保存的值：4。 ++*cp,根据运算符优先级，它相当于(++(*cp))，我们确实先进行自增操作，但由于*cp是一个整体，所以先对其本身求值，也就是4，然后我们复制一份拷贝，将运算结束后的新值5保存进去。所以对于字符串的操作，如果使用*++string,会漏掉首字符，所以用*string++可以方便对字符串进行遍历。 (*cp)++，如果不通过括号，我们要表达的就是*cp++，也就是*(cp++)，在这里我们就是先对cp进行间接引用取得ab保存的值，然后进行后置自增运算。 ++*++cp，根据操作符优先级，它的意思就是(++(*(++cp))),由于(*++cp)，我们知道作为右值是对ab的下一块空间的位置的间接引用，再对那个保存的未知值进行前置自增运算，但作为左值它是不合法的，因为自增后新值保存的那块空间位置不明确。 ++*cp++,根据前面的经验，我们可以知道它相当于((++(*(cp++)))),而*cp++作为右值相当于指向ab，进行间接访问的值为4,对其进行前置递增运算，并将拷贝计算的新值保存到一个新的位置，因为那个位置不明确，所以不能作为一个合法的左值。 通过上面的分析，我们发现，优先级上最后进行自增(自减)运算的不能作为一个左值使用，而取址操作符&amp;也一样，因为它们产生的新的值(不是地址值)会被保存到一个新的未知空间，所以不能作为左值使用。我们也发现”指针 +/- 整数”,只能作为右值，实质就是对里面保存的地址值的运算 #define、typedef和指针C语言里，typedef是一个很不错的机制，他可以给数据类型定义新的名字，和使用#define重定义常量的用法很像，但要注意的是，#define没办法很好的处理指针类型，例如12#define char_pointer char*char_point a,b; 那么其中的b就不能被正确的声明为一个指向字符的指针类型，而用typedef就不一样了，例如：123char *char_pointer; //声明一个指向字符的指针类型typedef char *char_pointer; //把char_pointer作为指向字符的指针的新名字char_pointer a; //声明a是一个指向字符的指针 就可以很好的用来处理指针类型。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看得见的与看不见的]]></title>
    <url>%2Fposts%2F6b0c6098%2F</url>
    <content type="text"><![CDATA[19世纪法国经济学家巴斯夏在《看得见的和看不见的》中曾说，在经济学领域，任何一种行为或习惯、制度、法律等，可能会造成一种结果，也可能会产生一系列的结果。因此，一个优秀的经济学家和一个平庸的经济学家之间的差别就是，优秀的经济学家能够看到事件后续发展的结果，所以宁愿放弃当下微小的不幸而追求长远的利益；而对于平庸的经济学家而言，他只能看见眼前的利益而忽略这件事情之后可能会带来的巨大失败。 经济学关心的一个最核心的问题是比较和选择。而要做好比较和选择，一个重要的前提，就是不仅要看见那些看得见的东西，还要尽量去看见那些不容易看见的东西，那些需要推测才能看得见的东西。其实不仅仅是经济学，这是一种观察事物本质的方式。 就像我们可以轻易识别出哪些东西是看起来对身体健康有害，但对精神意志产生危害的事物，我们的认知还依旧停留在色情暴力或是人性丑恶一类上面。但有一些新的事物确是我们难以识别的，例如碎片化阅读，经常沉溺于这些经过精心包装修饰后可以直接理解的信息，会逐步降低我们对深刻事物的理解能力，以及影响对事物的主观判断，它们让我们的思想变得“浅薄”。 殊不知，它们这样做的出发点或许仅仅是为了流量，而非内容本身，它们使人变得浮躁而难以静下心来通过传统阅读来进行深度思考，更容易使人跟风随大流，认知也将被“大流”所限制。这些影响是“看不见的”。仔细想想，相对于传统阅读学习方式，如今的社交媒体、内容分发平台是否真的增进了我们对世界的理解和认知呢？ 除了这些社会现象以外，其实我们在做一件事时也要去看到那些“看不到”的东西。摄影师把所有的器材和技法交给你，也无法保证你能和他拍的一样出色。同样，熟知同样的健身理论也无法保证你能和其他人练得一样好，因为每个人的身体代谢，消化吸收，以及意志力和动作发力这些“看不见”的因素是不好衡量的。 但一个人可以选择去积极的改变这些内在的因素，结合不同的工具和方法论，达到相同乃至更好的效果。而这需要我们在熟知工具使用和方法理论的同时大量实践，并不断地纠错，保持积极专注，并坚持下去。否则再好的工具和训练路径都无益。因为你需要迎难而上。 过去的经历、习惯和思维惯性，常在我们思考时自动植入“隐含假设”，让我们意识不到更多的“可能选项”，它使得我们只能看到那些我们能够看到的东西。 看似无用的知识，并不是说它真的无用，它需要一个适用的场景，或许这个场景你暂时遇不到，但未来是不可预测的，所以你才需要不断的去学习，而且不同领域的体系融合和撞击，会迸发出很多新颖的点子，无论是学术研究，还是创业，都将产生很大的帮助。往往每一个伟大创新的背后，都是由于看到了一些别人所忽视，暂时“看不到”的东西。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2Fposts%2F1fe3367f%2F</url>
    <content type="text"><![CDATA[ls命令用来显示目标列表或者目录内容，常用的可选参数有： -a 显示所有子目录和文件，包括隐藏文件 -l 显示文件的详细信息，可以把ls -l简写为ll cp/mv命令用来把一个文件或者多个文件复制/移动到目标目录 rm命令刪除一个目录中的一个或多个文件或目录，其中需要注意的参数有： -f 不需要确认删除多个文件，强制删除 -r 将文件的全部目录和子目录都删除 cat命令可以显示文件内容，也可以连接两个或者多个文件 which命令显示文件的所在路径 man命令用于查看Linux中的命令帮助信息，遇到不会的命令就man一下，它也有一些参数需要注意： -a 在所有的man帮助手册中搜索； -f 等价于whatis指令，显示给定关键字的简短描述信息； ps命令ps命令列出执行这个命令时刻时的那些进程，类似一个当前进程的快照，是最基本也是最强大的进程查看命令，需要注意的参数有： a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 -au 显示较为详细的信息 tar命令很常用的压缩&amp;&amp;解压命令了，但tar这个命令….参数是真的多，看到一种不错的记忆方法，只要记得参数是【必选+自选+f】即可，首先是必选参数，五选一： -c 意为 create，表示创建压缩包 -x 意为 extract，表示解压 -t 表示查看内容 -r 给压缩包追加文件 -u 意为 update，更新压缩包中的文件 然后是自选参数，必选的话只能选一个，而可以根据需要挑着选： -z 使用 gzip 属性 -j 使用 bz2 属性 -Z 使用 compress 属性 -v 意为 verbose，显示详细的操作过程 -O 将文件输出到标准输出 最后一个参数一定要是f，后面再跟上你要压缩或者解压的文件包名。 一般我们常用的解压方式就是： *.tar -&gt; tar -xf *.tar.gz -&gt; tar -xzf *.tar.bz2 -&gt; tar -xjf *.tar.Z -&gt; tar -xZf *.gz -&gt; gzip -d *.rar -&gt; `unrar e *.zip -&gt; unzip kill命令用于终止指定进程的运行，对于后台进程我们可以先通过ps/pidof/pstree/top等命令获取进程PID，然后用kill结束该进程。不过也可以使用killall命令，直接使用进程的名称结束进程，使用它可以结束一组同名进程，而不用先获取进程PID，killall相当于把这两个过程合二为一，是一个很好用的命令 head命令可以用来查看一个文件的前几行，可以配合其他命令使用，例如配合管道做grep tail命令tail命令和head相反，查看文件的最后几行。不过最常用的还是加上 “-f” 参数后和grep一起使用 grep命令一个极其强大的命令，常用来在很多数据中找到匹配某一模式的字段，可以是正则表达式，常用的几个参数有： -a 以文本文件方式搜索 -c 计算找到的符合行的次数 -i 忽略大小写 -n 顺便输出行号 -v 反向选择，查找没有搜索字符串的行 du命令du命令是对文件和目录磁盘使用空间的查看 top命令用于动态的显示进程的信息，不过也有可以自定义的形式，例如:top -u root可以用来查看某用户进程 find命令查找所需文件的命令，如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，常用的参数有： -type 只寻找符合指定的文件类型的文件,其后跟随指定文件类型参数，类型参数有 f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p FIFO -name 根据文件名查找 -size 根据文件的权限或者大小名字类型进行查找 -mtime 查找在指定时间曾被更改过的文件或目录，单位以24小时计算； -print 假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出 -exec 假设find指令的回传值为True，就执行其后跟着的指令 cmp命令用来比较两个文件的差异。如果两个文件完全一样，就不会显示任何信息。如果发现有差异，会标示出第一个不同之处的字符和列数编号。 touch命令修改文件的创建日期，或者以当前的系统日期创建一个空文件 date命令显示当前日期和时间的，可以通过一些参数进行日期的格式化： %Y year %m month (01~12) %d day of month %H hour (00~23) %I hour (01~12) %M minute (00~59) %S second (00~60)例如：1234date + &quot;%Y%m%d %H%M%S&quot;20180519 223856date + &quot;%Y-%m-%d %H:%M:%S&quot;2018-05-19 22:39:07 wc命令统计指定文件中的字节数、字数、行数，并将统计结果输出，需要了解的参数有： -c 统计字节数 -l 统计行数 -m 统计字符数，不能与-c参数一起使用 -w 统计字数 env/export命令env: 查看当前环境变量 类似于配置Python环境，在一台不熟悉的机器上，如果出现了配置问题，可以通过env命令查看shell下的所有环境配置，看一下路径是否正确。 export: 设置或显示环境变量 useradd命令useradd命令用于创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。其中有几个需要注意的参数： -e 指定帐号的有效期限 -g 指定用户所属的群组 -G 指定用户所属的附加群组 -r 建立系统帐号 -u 指定用户id，设定ID值时尽量要大于500，以免冲突 groupadd命令用于创建一个新的工作组，也可以用groupdel命令删除工作组，常用的参数有： -g 指定新建工作组的id -r 创建系统工作组，系统工作组的组ID小于500 curl/wget命令curl命令是一个利用URL规则在命令行下工作的文件传输工具,而wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。 netstat命令用来显示网络系统的状态信息，可让你了解整个系统的网络情况，需要注意的参数有： -a 显示所有连线中的Socket -n 直接使用ip地址，而不通过域名服务器 -t 显示TCP传输协议的连线状况 -u 显示UDP传输协议的连线状况 -l 显示监控中的服务器的Socket -s 显示网络工作信息统计表 -n 直接使用ip地址，而不通过域名服务器 可以通过参数的组合实现不同的功能，例如1234567netstat -at #列出所有tcp端口netstat -au #列出所有udp端口netstat -lt #只列出所有监听 tcp 端口netstat -lu #只列出所有监听 udp 端口netstat -st #显示TCP端口的统计信息netstat -su #显示UDP端口的统计信息netstat -an | grep &apos;:80&apos; #找出运行在指定端口的进程]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匠人的情怀]]></title>
    <url>%2Fposts%2F36da542e%2F</url>
    <content type="text"><![CDATA[“匠心”一词，横贯古今。如今，不管我们从事哪一行，不管我们做什么，都能和匠人、匠心沾上边，不少广告都以此作为噱头，宣传其产品是如何的“匠心独运”。 中国古代对于一个真正的匠人的描述是：一生只专注于一件事，用精细的工艺反复打磨自己的作品。因为他们值得尊敬，他们用一生的时光来做好一件事，并将这样的手艺不断的传承下去，所以中国古代出土的许多工艺品，我们大多都会赞叹其手艺的精妙绝伦。 曾经看过一部叫做《寿司之神》纪录片，里面讲述了一个在日本有着“寿司第一人”称号的老人——小野二郎，它对于寿司有着极致的追求，无论从选材，加工上都亲力亲为，做了60年寿司，一辈子都在将这门手艺不断地精进，不断尝试，脚踏实地，不失进取。 匠心精神可以扩展到各行各业，它是一种追求极致的专业精神。或许这个时代里追求匠心的人少了，但每当我们看到真正具有匠人精神的产品出现时，我们都会乐意为其买单。十年磨一剑，拥有匠心的人始终很难被市场所辜负，就像电影市场里，评价一部电影的好坏，并不是它投资了多少钱，请了多少大牌明星，人们更关注电影的本质，它是否能把一个故事讲好，而演员的演技，道具布景灯光，后期的处理等等都是为了推进故事本身。好的电影，会斟酌每一个镜头的运用，通过细节的刻画将人物的内心活动巧妙的展现出来，完成这样一部电影，导演很重要，但参与制作拍摄的人也同样重要。如果这是一个追求匠心精神的团队，那么它们终不会被时间所辜负。 对于技术人员来说，不应该去炫耀技术本身的复杂度和高难度，看似高大上，好像能做很多事，有很大潜力，但技术若不是以解决用户需求作为根本出发点，就会被那些水平看起来更低的技术组合和创新的使用方式所超越，因为它们恰好用对了地方，更好的解决了用户的需求，那么他的价值就要高于复杂度很高的技术。因为本身的技术壁垒，会让这项技术和很多产业的结合产生一定阻力和门槛，那么用其他更简单的方式却能取得同样效果的东西，无疑更容易取胜。毕竟，匠心诞生的初衷就是希望随着自身手艺的精进，能更好的解决别人的需求，发挥更好的效果。除非我们能将新技术用在正确地方，那么它才会发挥它不可替代的作用，而这个过程需要不断地尝试，不断精进。 如今，一个伟大产品的诞生已不再单靠个人的努力了，而是依靠一个公司、一个团队的通力配合，保持初心很重要，不断坚持、努力的同时也要保持热情和专注，对于拥有顶尖技术人员的公司，CEO固然很重要，但必须要有一个很重要的想法和理念来让这把“刀”恰到好处的发挥，才能构建出伟大的产品，而非人才、技术、资本的胡乱堆砌，如何让一个公司、团队具备匠心精神无疑成为了新时代的复杂挑战。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google实用搜索技巧]]></title>
    <url>%2Fposts%2Fdbaa5747%2F</url>
    <content type="text"><![CDATA[善用搜索引擎的都是信息时代的富翁，不懂搜索引擎的都是信息时代的负翁。 完整匹配在Google的搜索框里，所有的空格都会被视为”+”号，可能对于用惯了百度的人很好理解，因为我们要搜索啥时，肯定是优先搜索关键词，加了空格就相当于多个并列的关键词，那搜索结果就会把所有包含相关关键词的内容都全部罗列出来。 对于搜索一个具体的问题，例如一句描述问题的话，在中文里基本是没空格的，但我们使用Google时更多是用的英文，当我们搜索英文关键词是没问题的，但当你使用英文描述一个具体问题时，就需要在搜索字段的前后加上引号，无论是全角字符（ “ 或者 ” ）还是半角字符（ “ ），Google都能正确处理，这就是完整匹配。 筛选过滤为了进一步筛选搜索结果，我们可以使用” - “操作符，如&quot;mysql connect error&quot; - &quot;nodejs&quot;就要求Google返回含有mysql connect error但不包括nodejs的文章。当然，中文搜索也是适用的。 也可以使用”+”操作符，因为Google会忽略和过滤一些常用的英文词汇，例如and，how之类的，使用”+”操作符可以让搜索引擎强制包括它们，也可以强制过滤掉关键词的一些特定时态形式。 通配符其实就是我们熟知的符号“*”，举个例子，当我们搜索 “mysql connect error *” Google就会返回所有已知的关于MySQL连接错误的文章。 其他操作符我们熟知常用的一些操作符，可以在Google里使用，辅助完成一些特定搜索，例如： ~ 关键词前加上它，可以显示同义词 | 作用和OR一样 .. 用来限定数值的范围，例如2015..2018 站内搜索可以根据特定的网站，搜索对应网站内所有相关内容，例如：&quot;mysql connect error&quot; site:stackoverflow.com就会返回Stackoverflow内所有关于MySQL连接错误的文章。 搜索指定文件格式我们可以搜索特定的文件格式，不过一些文件类型是不支持的，但日常用来搜索一些PDF资源或者搜索特定图片格式是很方便的，只需要加上filetype: + 特定格式，就可以了。不过对于图片搜索，我们还可以限定搜索的图片尺寸，加上imagesize:，例如：imagesize:500x500 搜索相似网页通过related:这个关键字搜索到相关相仿的网页或相关页面，例如：related:www.taobao.com 关闭安全搜索最直接简便的方法就是在搜索网址时附加一个参数：&amp;safe=off]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪辑的艺术]]></title>
    <url>%2Fposts%2F1f1c6b63%2F</url>
    <content type="text"><![CDATA[“当你剪辑声音时，你要思考让什么为画面服务以及如何操控观众的情绪。我很喜欢将音乐和音效融合在一起，创造一种很有氛围的“汤”,这样你就无法区分开音乐和音效了。” 不同于视频拍摄，视频剪辑看似简单，但却是一个一部电影或是短片的重要流程之一。拍摄如同市场买菜，在剪辑台上工作才是真正的烹饪。 剪辑前我认为我们应该站在观众的角度来思考，当他看到整体画面以及故事时会是怎样的感觉，定下整个电影的基调。剪辑不是组合，而是探索路径。它是直觉和经验的整合，同时伴随着无数次的实验。 电影的初衷是为了“讲故事”，而剪辑是为了推动故事发展而剪辑的，如果过于死板的依赖于计划，不懂得灵活变通，电影就会变得死板平淡，因为你的故事无法打动关注，例如蒙太奇手法没能正确的讲故事，什么是蒙太奇呢？当不同的镜头组接在一起时，往往会产生各个镜头单独存在时所不具有的含义，这就是蒙太奇，更可以看作是一种“观念的连接”。 每当我们进行剪辑时，面对诸多的素材，我们可能会变得难以取舍，犹豫不决。但经验告诉我们，不要想太多，放胆剪下去就是了。忘掉理论，每一部电影都是不同的，观看第一个镜头，凭借直觉找出你认为开始切入的地方。然后按播放键，在你认为合适的地方按暂停，反复进行这一操作。你会发现每次都会选到同一帧，那么这或许就是你最想要的剪辑效果了。当然，更为重要的是知道什么是不该剪辑的，这也是一个漫长的学习过程，伴随着不断地实验。 节奏，角色，反应镜头在剪辑中是我们需要时常留意的元素，如果观众非常欣赏故事，却没有留意到镜头的并置时，剪辑师就成功了，它令一部电影变得深入人心，充满了吸引力。 剪辑的艺术只有当两个或更多的镜头结合起来产生另一个水平的意义时，我们才会在其中感到兴奋和震惊，我们会感叹剪辑是如此的神奇，通过组合，产生了 1 + 1 &gt; 2 的效果。但我们也要知道，剪辑的风格由故事驱动，是故事让我们的剪辑变得更有意义，而非剪辑风格驱动一个故事的发展。]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于碎片化阅读的思考]]></title>
    <url>%2Fposts%2Fc0990ce6%2F</url>
    <content type="text"><![CDATA[如今，碎片化阅读是大部分人获取信息的方式，因为文章很短，便于理解，我们可以利用我们的碎片时间来获取各类信息，尤其是工作比较忙，腾不出多余时间时。加之现代的人，心也比较浮躁，我们都渴望通过学习提升自我，也知道学习充电的重要性，但总试图一目十行，快速获取信息，完成学习的任务。 殊不知这恰恰掉进了碎片化阅读的陷阱，因为读这些文章，会让人产生及时的满足感，它们本身不需要多费脑筋，就可以很快了解我们之前所不知道的事，给我们一种很大的“激励”，然后在碎片化的文章中乐此不疲的继续深耕着，因为读一本完整的书过程很漫长，过程越长我们对之前的内容就会忘记，读完一本书的过程就很痛苦。加上一些书本身阅读门槛就很高，如果贸然阅读，很可能令人中途放弃。 不可否认，碎片化阅读确实也有其长处，因为比起在碎片化时间里干一些杂事，阅读一些过去所不知道的东西终归是有益，取决于你对待碎片化阅读的方式。 传统的阅读方式是重要的，但它需要我们保持成为一个习惯，不然就会像一壶等待烧开的水，我们频繁中断，永远也烧不开。当我们走出校园，传统的阅读学习方式是我们未来几十年里最主要的“充电”模式了。但我们需要尊重农事法则，不要试图一蹴而就，阅读过程本身比结果更为重要。 碎片化阅读是没有体系的，它就像是无根浮萍，而传统阅读的书籍则不同，它有其背后的一套价值体系，它会在你阅读的过程中，循循善诱，当你阅读的书积累一定量时，你也会诞生出属于自身的一套价值体系，这通过碎片化阅读是无法做到的。 对于碎片化阅读，需要我们学会汲取，汲取内容中能够启发我们个人知识体系里的那部分内容，它是对个人知识体系里经验的辅助理解和加深对原有事物的感悟，同时也是对其的再修正。这些零散的观点犹如树叶，需要我们来筛选补全以形成一颗郁郁葱葱的参天之木。但我们本身需要”树干“的支持，若没有树干的依托，也就是个人基本的知识体系作为基点，这些碎片的观点和讯息只会成为一种负担，因为我们无法衡量后作出取舍。 但这棵树本身也存在一定问题，就是我们是否会由于个人的某种价值取向而在潜意识里自动过滤掉那些违背我们价值观、世界观的内容讯息，因为它们可能是对我们自有知识体系的一种否定，这样容易使我们一条道走到黑，也让我们以后更难以听取那些反对的声音。如何能够客观的来权衡汲取碎片化的内容是一个值得权衡深思的问题。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小记]]></title>
    <url>%2Fposts%2F3419b273%2F</url>
    <content type="text"><![CDATA[常用命令设置和配置 git config12345678git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on git 创建和获取项目 git init初始化本地git仓库（创建新仓库） git cloneclone远程仓库 快照 git add应该理解为“添加内容到下一次提交中更合适” 12git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至index git commit 123git commit -m &apos;xxx&apos; # 提交并键入提交信息git commit --amend -m &apos;xxx&apos; # 重新尝试提交，合并上一次的提交，用于反复修改git commit -am &apos;xxx&apos; # 将add和commit合为一步 git diffgit diff本身并不会显示出自上一次提交以来所有的变更，而只会显示出还没有进入暂存区的那些变更，如果所有变更已经进入暂存区，git diff不会有任何输出。 1234567git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff --staged # 将暂存的变更与上一次提交相比较git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git rm 12git rm xxx # 删除index中的文件git rm -r * # 递归删除 git mv 1git mv README README2 # 重命名文件README为README2 git status用来查看当前文件状态，查看是否进行了修改 1git status -s # 更为紧凑的形式查看变更 分支与合并 git log 123456git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log --stat # 查看每个提交的简要统计信息git log -p -2 # 显示出最近两次提交所引入的差异git log v1.0 # 显示v1.0的日志git log --pretty=format:&apos;%h %s&apos; --graph # 更改日志输出默认格式，其结果不会随着Git软件版本更新而改变 git tag 12git tag # 显示已存在的taggit tag -a v1.0 -m &apos;xxx&apos; # 增加v1.0的tag git branch列出你所拥有的分支、创建的新分支、删除分支以及重命名分支 123456789git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git checkout切换分支并将内容检出到工作目录 1234567git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v1.0 # 检出版本v1.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退） git merge用于将一个或多个分支合并，然后将合并的分支作为当前分支 1git merge origin/master # 合并远程master分支至当前分支 git stash 123git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存 项目共享和更新 git remote用来查看已经设置了哪些远程仓库，然后列出每个远程仓库的简短名称，也可以用来管理远程仓库记录，将一段很冗杂的URL地址保存成一个简单的字符串句柄，比如origin，方便操作 1git remote add &lt;name&gt; &lt;url&gt; # 增加远程定义（用于push/pull/fetch） git push与其他仓库通信，确定本地内容和远程仓库异同，然后将差异推送到其他仓库 123git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有服务器上还没有的标记都推送过去 git fetch 123git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git fetch origin # 与服务器同步 git pull可以理解为git fetch和git merge的组合，先从远程仓库获取内容，再尝试合并进你所在分支 1git pull origin master # 获取远程分支master并merge到当前分支 git reset 1git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） 检视和比较 git show能够以简单易读的形式显示Git对象，通常用来显示标签或提交的相关信息 12345678git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git show v1.0 # 显示v1.0的日志及详细内容git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git show HEAD~3git show -s --pretty=raw 2be7fcb476 git ls-files 1git ls-files # 列出git index包含的文件 git show-branch 12git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史 调试 git grep可以帮助你在源代码的所有文件中找到任意字符串12git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e &apos;#define&apos; --and -e SORT_DIRENT 打补丁 git cherry-pick 1git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git rebase基本上就是一个自动化的git cherry-pick命令，它确定一系列提交，然后在别处以相同的顺序逐个对其挑拣。不要对已经存在于本地仓库之外的提交执行rebase操作。 git revert与git cherry-pick命令的效果恰好相反，将变更撤销或还原 1git revert dfb02e6e4f2f7b # 撤销提交dfb02e6e4f2f7b 管理 git reflog显示所有提交，包括孤立节点 git gc执行”垃圾回收“，删除无用文件，将余下的文件打包成一种更有效的形式 git fsck用于检查内部数据库存在的问题或不一致性 Git使用规范流程 在团队开发中，遵循一个合理、清晰的规范是很重要的，例如Git,如果每个人都很随意的提交一堆commit，项目很快就会变得难以维护和管理了，所以需要规范化这个流程。 一、新建分支每次开发一个新的功能，我们都应该新建一个单独的分支123456# 获取最新代码git checkout mastergit pull# 新建一个开发分支git checkout mybranch 二、提交分支分支修改后，就可以提交了123git add .git statusgit commit 三、撰写提交信息提交commit时，必须要简洁明了的叙述提交的信息，可以参考这个例子：123456简要的变更汇总，然后空一行（不超过50个字符），如果有必要，就要附加更详细的说明，每行长度限制在72个字符左右。- 通常使用连字符或者星号作为条目符号- 改动原因- 主要变动- 需要注意的问题 四、与主分支同步开发的过程中要时常与主分支保持同步12git fetch origingit rebase origin/master 五、合并开发完成后，我们需要把一堆commit合并到主分支关于合并多个commit,可以看这篇文章：「Git」合并多个 Commit不过也有一种简洁的合并方式,就是先撤销过去5个commit，然后再建一个新的：1234git reset HEAD~5git add .git commit -am &quot;Here&apos;s the bug fix that closes #28&quot;git push --force 六、推送远程仓库1git push --force origin myfeature 之所以要加上 force 参数，是因为 rebase 后，分支历史改变引起的远程分支不兼容问题 七、发出Pull Request提交完毕后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review ，确认是否可以合并到 master 分支。 Git工作流主流工作流 Git Flow GitHub Flow GitLab Flow Git FlowGit Flow 是最早诞生、并得到广泛采用的一种工作流程。 Git Flow 存在两个长期分支，分别是主分支 master 和开发分支 develop ，前者是对外发布的稳定版本，后者相当于测试开发版，用于日常开发使用。 Git Flow还有三个协助分支，分别是功能分支（分模块功能开发）、补丁分支（线上的紧急 bug 修复）、和预发分支（版本发布的预发布），分别对应不同的业务需求，一旦开发完成，它们会先合并进开发分支，再合并进主分支，或者直接并入主分支。 Git Flow的优点在于直观明了，易于控制，但需要维护两个长期分支，需要频繁切换，而且这个模式更多基于“版本发布”的，对于一些“持续发布”的项目，两个长期分支的区别就不大，没必要都维护。 GitHub FlowGitHub Flow 作为 Github 所使用的工作流，其目的也是专门为了配合“持续发布”的。它只有一个长期分支，就是我们所熟知的 master 分支，团队成员们的分支代码通过 Pull Request 来合并到 master 上。 我们通过从 mater 上拉出新的分支，当开发完成时，就发起一个Pull Request，然后会审核你的代码，如果被接受就可以合并进 master 分支。 不过由于它只有一个主分支，所以如果你的开发时间很长，主分支就会与你得分支版本不一致，而你不得不专门建一个分支跟踪线上的新版本。 GitLab FlowGitlab flow 吸取了 Git flow 与 Github flow 的优点。既有适应不同开发环境的弹性，又有单一主分支的简单和便利。 对于”持续发布”的项目，建议在 master 分支以外，再建立不同的环境分支。比如，”开发环境”的分支是 master ，”预发环境”的分支是 pre-production ，”生产环境”的分支是 production 。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。只有上游没有问题，才能发布到下游，除非是紧急情况，才能直接合并到下游分支。 对于”版本发布”的项目，都要从 master 分支拉出一个分支，比如1-3-stable、1-4-stable等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。 Git代码规范具体可以看一下这篇文章：Git Style Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的字符串拼接技巧汇总]]></title>
    <url>%2Fposts%2F44624dc5%2F</url>
    <content type="text"><![CDATA[Python里的字符串拼接方式有好几种，我们最熟知的可能是利用加号连接或是通过join函数连接，其实在Python里还存在了一些字符串拼接的方法，使用得当，可以有效提高我们的效率，这里作一个小的总结。 利用加号拼接入门模式，利用+字符连接字符串，实现字符串的拼接，实则是操作符的重载。如果是数据量不大的字符串拼接，推荐使用它。1234&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; a + b'hello, world!' 利用join()拼接字符串的内置方法里有一个join()，通过这个方法也可以实现字符串的拼接。但join的参数是数组或者元组之类的序列类型。如果要拼接大量字符串推荐使用它，而不是+。1234&gt;&gt;&gt; a = "*"&gt;&gt;&gt; b = ['a','b','c']&gt;&gt;&gt; a.join(b)'a*b*c' 直接拼接在Python中，连续的字符串会拼接为一个字符串12&gt;&gt;&gt; print("hello, " "world!")hello, world! 利用逗号拼接1234567&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; c = 4&gt;&gt;&gt; print(a,b)hello, world!&gt;&gt;&gt; print(a,c)hello, 4 逗号操作符可以把两个变量的值进行拼接，不过只能用于print打印里。 格式化字符串可以通过格式化字符串的方式，进行字符串的拼接，而格式化字符串可以通过%操作符，也可以通过format()函数。12&gt;&gt;&gt; print('%s %s' % ('hello, ', 'world!'))hello, world! format()方法可以非常方便地连接不同类型的变量或内容12&gt;&gt;&gt; "&#123;&#125; &#123;&#125;".format("hello, ", "world!")'hello, world!' Python3.6中引入了字面量格式化字符串，简称f-string，用法和%、format()类似,但它的可读性比使用+号更好，当我们要拼接大量数据内容，例如像key:value类型的字段时，推荐使用f-string,它的性能也更好。1234&gt;&gt;&gt; a = "hello, "&gt;&gt;&gt; b = "world!"&gt;&gt;&gt; f"&#123;a&#125; &#123;b&#125;"'hello, world!']]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“视界”]]></title>
    <url>%2Fposts%2F13deedeb%2F</url>
    <content type="text"><![CDATA[未理解一件事物之前，不要轻信他人的判断和所谓的“权威”，没有一种思想是完美的，不同的文明，诞生了不同的思想，东方的思想不能因为它历史悠久而认为更好，西方思想也不一定代表着先进，不同的情境适用于不同的“智慧”。 全球化的大背景下，文化的边界在逐步融合，人与人之间日趋包容，新事物、新潮流在当前的社会接受度不断提高，即使是老一辈人也在不断地接受新的变化，例如移动支付。也因为这些新的形式的出现，诞生了许多新的问题，很多由于规则的不健全，出现了游走于法律灰色地带的事，以此谋取暴利的事也时有发生。但我们也知道，每一个时代的背景下都会有所谓的“新事物”，新的形式也不断地推进中逐步获得人们的认可。 因为变化的存在，所以我们的思想认知其实也是在变化的，凡所已有之事，必有其存在的价值，我们可以不断地修正我们对事物的判断，去吸取一些有益的东西，不同的文化，不同的思想，不同的“潮流”新事物，不同人对事物的看法，都能让我们看到更多的可能性。 于不同的地域间不断“争渡”，去体会不懂地缘文化的差异，以及对人的影响，感受不同的风土，南方与北方，沿海与内陆，国内与国外，去体验不同的新事物，不断地学习，最终我们会发现，其实，这个世界本来就没有多少标准答案，或是说，一个“题目”本来就可以有若干个正确答案，而且这些“正确答案”相互之间还很矛盾。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2Fposts%2Fd6b33154%2F</url>
    <content type="text"><![CDATA[标题 如果你需要插入标题，可以在行首插入1到6个#，对应标题的1到6级,最高可以到六级标题，最好在#后加一个空格，例如:# 这是一级标题## 这是二级标题####### 这是六级标题 也可以使用=====表示高级标题，使用------表示次级标题，大于两个=,-都可以用来表示标题 引用如果你需要一个引用，那么你可以使用&gt;符号放在文字开头，例如:&gt;这是一个引用引用是可以嵌套的，同时引用的区块内部也可以使用其他的Markdown语法，例如 这是一个引用 这是一个嵌套引用 这是二级标题 列表项 列表项 列表如果你需要一个列表，在Markdown里，你可以选择有序列表和无序列表两种形式，列表本身也是可以嵌套，例如 列表项 列表项 列表项 嵌套列表 嵌套列表 无序列表可以使用*、+、-这三个符号中的任意一种作为列表标记，也可以和引用标记进行嵌套 列表项 列表项 列表项 这是一个嵌套的引用 可以进一步嵌套 字体 粗体: 通常用**或者__表示粗体 斜体: 通常用*或者_表示斜体 斜粗体：通常用***或者___表示斜粗体 链接如果你需要链接文字，可以使用[](link)表示一个链接，其中[]内是需要添加链接的文字，()内是链接的地址 代码 使用一对```表示代码块，可以根据你所使用的Markdown编辑器,选择在第一个```后添加代码的language，产生高亮效果，例如： 123public static void main(String[] args) &#123; System.out.println("Hello"); &#125; 使用一对 可以表示一个行内代码，例如： 这是一个Java`代码 图片如果你需要插入一张图片，可以使用![Text](path)，其中Text表示图片无法加载时显示的文字，path为图片所在的路径，也可以是网上的图片链接地址 分割线如果你需要一条分割线，可以使用--- 或者***表示水平分割线，只要-,*大于三个就可以表示水平分割线，使用---作分割线时需要前后都空一行，防止被当成标题的标记方式 删除线如果你需要一条删除线,可以使用一对~~表示删除线，但切记和文字之间不能有空格 表格可以使用以下的格式添加表格,注意表格和文字间空一行：12345| name | age | gender | money ||-------|:---:|-----------|-------:|| rhio | 384 | robot | $3,000 || haroo | .3 | bird | $430 || jedi | ? | undefined | $0 | name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $0 其他如果 Markdwon 的语法达不到预期效果，或者一些地方的处理用 Markdwon 的格式无法实现，可以考虑用 HTML 和 CSS 引用 123&lt;blockquote&gt;***&lt;/blockquote&gt;/* 如果上下间距小，可以这样写 */&lt;p&gt;&lt;blockquote&gt;***&lt;/blockquote&gt;&lt;/p&gt; 居中和右对齐 123456/* 居中 */&lt;center&gt;**&lt;/center&gt;/* 右对齐 */&lt;p style=&quot;text-align:right&quot;&gt;**&lt;/p&gt;/* 右对齐 */&lt;p style=&quot;text-align:left&quot;&gt;**&lt;/p&gt; 字体大小和颜色 1&lt;font color="#xxxxxx" size="number"&gt;**&lt;/font&gt; 分割线和空行 12&lt;hr /&gt;&lt;br /&gt; 关于Markdown的更多细节，可以参看：Markdown 语法说明 (简体中文版)，对于Markdown的规范，可以看一下 ：Google Markdown Style Guide 或者 Markdown Style Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python中__str__和__repr__的区别]]></title>
    <url>%2Fposts%2Fa292341e%2F</url>
    <content type="text"><![CDATA[__repr__和__str__这两个方法都是用于显示的，但实际却存在一些细微的差异，具体我们可以通过一个简单例子来比较一下它们之间有何不同。 123456789101112class Hello(object): pass&gt;&gt;&gt; a = Hello()&gt;&gt;&gt; a&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(a)&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(str(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt;&gt;&gt;&gt; print(repr(a))&lt;__main__.Hello object at 0x000001DE0044AE48&gt; 这里我们想要打印类对象，但显示的确是对象的内存地址，而且无论通过__repr__或是__str__,结果都一样，下面我们重写一下这个类的__repr__方法： 12345678910111213class Hello(object): def __repr__(object): return 'hello'&gt;&gt;&gt; b = Hello()&gt;&gt;&gt; bhello&gt;&gt;&gt; print(b)hello&gt;&gt;&gt; print(str(b))hello&gt;&gt;&gt; print(repr(b))hello 然后我们就会发现无论输出对象，还是调用__repr__和__str__方法，甚至通过print()方法，打印的信息都是按我们__repr__方法中定义的格式进行显示的。现在我们重写一下__str__： 12345678910111213class Hello(object): def __str__(object): return 'hello'&gt;&gt;&gt; c = Hello()&gt;&gt;&gt; c&lt;__main__.Hello object at 0x000001DE00450CC0&gt;&gt;&gt;&gt; print(c)hello&gt;&gt;&gt; print(str(c))hello&gt;&gt;&gt; print(repr(c))&lt;__main__.Hello object at 0x000001DE00450CC0&gt; 现在就很直观了，直接输出对象c时，显示出来的依旧是它的内存地址，而当我们调用print方法时，就会按我们定义的格式输出信息。因为我们覆盖了先前的__repr__方法，即使没有提前覆盖__repr__方法，我们得出的结果依然也是一样的。 总结一下，__repr__和__str__这两个方法都是用于显示的，但__str__更适用于用户，而__repr__更适用于开发人员 打印操作会首先尝试__str__和str内置函数（print运行的内部等价形式），它通常应该返回一个友好的显示 __repr__用于所有其他的环境中，例如交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str，它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使自己看起来更Pythonic]]></title>
    <url>%2Fposts%2Fc53ec731%2F</url>
    <content type="text"><![CDATA[Python这门语言语法很简洁，如果具备其他语言的基础，学习它会很快，但我们可能写出的代码不那么Pythonic，尽管它也能运行，但我们没办法充分发挥这门语言的特性，简化很多不必要的操作，以提高自己的效率。 关于for循环我们使用for循环其实出发点可能是为了遍历一个序列然后提取有用的信息，又或者单纯为了循环一个操作，在其他语言里，我们达到类似的目的确实只能通过循环完成，例如 Java：12345for(int i=0; i&lt;10; i++) &#123; if(i%2==0)&#123; System.out.println(i); &#125;&#125; 在Python里自然也可以写出类似的代码: 123for i in range(10): if i % 2 == 0: print(i) 如果代码逻辑更为复杂些，里面可能就要嵌套一堆if/else的判断，如果再加上try/catch代码块，那代码会变得很长，而且阅读性很差，那么Pythonic的写法是什么呢：1print([i for i in range(10) if i%2==0]) 通过列表推导式，一行代码就解决了，而且逻辑很清晰。 变量交换在其他语言实现变量交换很麻烦，往往要通过引入第三方变量作为桥梁进行变量交换，像这样123tmp = a;a = b;b = tmp; 虽然Python也可以用这样的方式，但这很不Pythonic，我们可以这样，一行代码即可，很方便。1a, b = b, a 字符串拼接关于Python里的字符串拼接，可以看一下这篇总结： Python中的字符串拼接技巧汇总 ，很多都是Python里才有的方式，可以让你的代码看起来更加Pythonic。 文件资源管理关于文件资源的打开和关闭传统的方式是这样的：12345f = open('*.txt')try: data = f.read()finally: f.close() Python提供了更为简便的操作，通过with关键字动态的打开关闭资源：12with open('*.txt') as f: data = f.read() 赋值Python自带了许多很方便的容器类型，例如：元组，列表和字典，当我们要把容器中的值取出来赋值给变量，可能我们会想到通过遍历这些容器类型，调用相关的方法取出值，然后赋值给变量，但那很不Pythonic，就拿元组来说，我们可以通过元组拆包的形式，使用很简短的代码，来为变量赋值。123456789101112&gt;&gt;&gt; result = (1, 3, 5, 7, 9)&gt;&gt;&gt; a,b,c,d,e = result&gt;&gt;&gt; a1&gt;&gt;&gt; b3&gt;&gt;&gt; c5&gt;&gt;&gt; d7&gt;&gt;&gt; e9 Python之禅如果你看过Python之禅，就会理解这门语言的设计哲学，而Python的代码风格也应该向这个目标靠近。 1234567891011121314151617181920212223242526272829303132333435363738394041&gt;&gt;&gt; import thisThe Zen of Python, by Tim Peters#优美胜过丑陋。Beautiful is better than ugly.#显示胜过隐式。Explicit is better than implicit.#简单胜过复杂。Simple is better than complex.#复杂胜过繁复。Complex is better than complicated.#串行胜过嵌套。Flat is better than nested.#稀疏胜过稠密。Sparse is better than dense.#可读性很重要。Readability counts.#虽然理想很丰满，现实很骨感，但是所谓特例并不足以打破上面的这些规则。Special cases aren&apos;t special enough to break the rules. Although practicality beats purity.#所有错误都不应该被直接忽略，除非能够被精确的捕获之后。Errors should never pass silently. Unless explicitly silenced.#当面对不明确的情况时，要拒绝去猜测的诱惑。应该有一种，最好是唯一一种，显而易见的解决方案。尽管起初，那种解决方案可能并不是那么显而易见，因为你不是Python之父——DutchIn the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch.#现在行动胜过永不开始。尽管，永不开始经常好过冲动的开始。Now is better than never. Although never is often better than right now.#如果你的实现难于向别人解释，这往往不是个好主意。如果你的实现很容易向别人解释，这可能是个好主意。If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea.#命名空间是一个令人激动的伟大想法，让我们将它发扬光大。Namespaces are one honking great idea -- let&apos;s do more of those! 这里推荐两本书，如果你Python已经入门，希望进阶，并想写出更为Pythonic的代码，提高开发效率，可以看下《流畅的Python》 、 《Python Cookbook》 关于Python的代码风格可以看一下： Python 风格指南]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表解析的效率问题]]></title>
    <url>%2Fposts%2Fbc25f5cb%2F</url>
    <content type="text"><![CDATA[在列表，字典，集合中根据条件筛选数据 列表 filter 1filter(lambda x:x &gt; 20,data) 列表解析 字典 字典解析1&#123;for k,v in d.interitems() if v &gt;= 20&#125; 集合 集合解析1&#123;x for x in s if x % 2 == 0&#125; 注意：列表解析也可能会被滥用，例如使用列表解析重复获取一个函数等。所以并非一味地使用列表解析式就是好的。 原则：尽量保持其简洁，列表解析的代码不要超过两行以上，只用它来创建新的列表，否则的话还是考虑使用for循环来重写。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>

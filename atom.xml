<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天马的故乡</title>
  <icon>https://www.gravatar.com/avatar/af826c880117989a83a2457623c21a52</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shengshiyu.cn/"/>
  <updated>2019-01-14T16:00:00.000Z</updated>
  <id>https://www.shengshiyu.cn/</id>
  
  <author>
    <name>沉默的超云星</name>
    <email>shengshiyu0508@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新思想和旧思想</title>
    <link href="https://www.shengshiyu.cn/posts/514198ec/"/>
    <id>https://www.shengshiyu.cn/posts/514198ec/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%96%B0%E6%80%9D%E6%83%B3%E5%92%8C%E6%97%A7%E6%80%9D%E6%83%B3.jpg" alt="新思想和旧思想"></p><blockquote><p>知识的条条框框束缚住了你那想纷飞的思想翅膀，你的一切想法都将围绕着“我知道”“我很清楚”“社会原本就是这样的嘛！”打转。一旦这种“我什么都懂”的思想进驻到你的心里，那你就很有可能会失去了解事情真实面目的兴趣，而没有了这种兴趣，你就会丧失前进的动力，那么等待你的就只剩下百无聊赖的空虚日子了。</p></blockquote><p>新的“新思想”和旧的“新思想”，“<strong>新</strong>”不一定就代表了一种<strong>进步</strong>和对旧有事物的否定，旧的思想中可能蕴含着一些我们未充分认识的<strong>创新点</strong>，一旦机会成熟，旧有的思想就会成为一种潮流，至少在我看来，设计就是一个这样的过程，旧有的设计理念和一些新的“新思想”结合，却能成为一种潮流。</p><p>我们的认知观念里总认为旧有的东西就是<strong>落后</strong>的，就应该被<strong>淘汰</strong>的，因为有了继承于它的更好的方式，但那或许仅仅是继承原有的一个点，新旧本身并不应该作为衡量价值的标准。就像销量高的产品并不一定就代表质量好一样，人类总是倾向于接受和他们内心认知看法接近的事物，因为它们不必为此否定自身，就像我们的新闻一样，我们很难看到相悖的两种形式的新闻。</p><p>“主流”的思想将一些“<strong>异端</strong>”思想给排斥在外，但更多时候我们会发现，两种相悖的观点事实上它们都是正确的，不同的环境，不同的时代背景，不同的利用和转化方式，都可以作为我们评判一种思想是否具有价值的<strong>参考条件</strong>。</p><p>成长的过程，就是我们不断地发现过去家长、老师们教的某些东西开始具有了“<strong>片面性</strong>”，随着我们对其更深入全面的了解，随着我们阅历的加深，我们会衍生出自己的一套<strong>价值判断标准</strong>，但我们也会无意识地将与自身观点相悖的思想排斥在外，以维护我们自身观点的“正确性”，尤其是随着我们年龄的增长，我们更原意接受符合我们价值判断标准的事。</p><p>当我们摒弃了新旧思想之争，从全新的角度出发，去发现不同观点背后存在的<strong>可能性</strong>，勇于接受它们，判断哪一种更符合时代的发展的某种需要，哪一种更适合自身，去理解“<strong>变化</strong>”本身，避免使自己陷入<strong>思维的死角</strong>，找到在不同情境下最适宜的技巧。那么旧思想也可以成为”新的旧思想“，它也会有机会在如今的时代里绽放不一样的光芒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Spring Bean的生命周期和作用域</title>
    <link href="https://www.shengshiyu.cn/posts/fbb6f1be/"/>
    <id>https://www.shengshiyu.cn/posts/fbb6f1be/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-01-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" alt="浅谈Spring Bean的生命周期和作用域"></p><p>在 Spring 中，Bean 就是由 IOC 容器初始化、装配并管理的对象，它的生命周期由 Spring 控制，这个过程称为 Spring 中 Bean 对象的生命周期管理。</p><h1 id="Spring-Bean-的作用域"><a href="#Spring-Bean-的作用域" class="headerlink" title="Spring Bean 的作用域"></a>Spring Bean 的作用域</h1><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><p><strong>默认的作用域</strong>，单例模式，仅仅为每一个 Bean 对象创建一个实例，在 Spring IOC 容器中也只会存在一个共享的Bean实例。</p><p>在创建容器时就<strong>自动创建</strong>了一个 Bean 的对象，不管你是否使用，它都存在，在XML中配置 Bean 为 singleton ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"ServiceImpl"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.shengshiyu.service.ServiceImpl"</span> scope=<span class="string">"singleton"</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p><strong>原型模式</strong>，可以根据需要为每个 Bean 对象创建<strong>多个实例</strong>，可以把它理解为一个“模板”，每次我们获取 prototype 定义的Bean都会生成一个新的Bean实例，每一个Bean都有自己的属性和状态。</p><p>prototype它在我们创建容器时没有实例化，<strong>只有在我们获取bwan时才去创建</strong>，在XML中配置和singleleton大同小异，更改一下scope参数即可。</p><h2 id="web作用域"><a href="#web作用域" class="headerlink" title="web作用域"></a>web作用域</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p><strong>一次HTTP请求</strong>，Spring 容器会返回 Bean 的同一实例，仅在当前的请求有效，对于新的 HTTP 请求又会产生新的 Bean，相对其他请求时独立的，当请求结束，这个 Bean 的实例也会被销毁。仅在 web 相关的 ApplicationContext 中生效。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>一次HTTP会话中</strong>，容器会返回Bean的同一实例，不同的会话请求会创建不同的实例，仅在当前会话有效，随着会话结束，实例也会被销毁，和 request 一样，区别仅在于一个是针对一次 request ，而另一个是针对一次 session 。仅在web相关的ApplicationContext中生效。</p><h3 id="Global-session"><a href="#Global-session" class="headerlink" title="Global session"></a>Global session</h3><p>为<strong>每一个全局的HTTP会话创建一个实例</strong>，一般仅在<strong>porlet上下文</strong>中生效。一样仅在web相关的ApplicationContext中生效。</p><h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p>Spring容器可以管理singleton作用域下Bean的<strong>生命周期</strong>，在此作用域下，Spring能够精确地知道Bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的Bean的生命周期。</p><h2 id="Bean创建的方式"><a href="#Bean创建的方式" class="headerlink" title="Bean创建的方式"></a>Bean创建的方式</h2><ol><li>调用<strong>构造器</strong>创建</li><li>调用<strong>静态工厂方法</strong>创建</li><li>调用<strong>实例工厂方法</strong>创建</li></ol><h2 id="ApplicationContext和BeanFactory"><a href="#ApplicationContext和BeanFactory" class="headerlink" title="ApplicationContext和BeanFactory"></a>ApplicationContext和BeanFactory</h2><p><strong>ApplicationContext</strong> 和 <strong>BeanFactory</strong> 是 Spring 两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展。</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>在ApplicationContext容器中，Bean的生命周期，大致是这样的：<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F1.png" alt="浅谈Spring Bean的生命周期和作用域1"><br>不过需要注意，需要根据是否实现了 BeanNameAware、BeanFactoryAware、ApplicationContextAware、BeanPostProcessor、InitializingBean 接口，才能调用它们相应的方法。如果 Bean 配置了 init-method 方法，则会执行 init-method 配置的方法。如果有 Bean 实现了 BeanPostProcessor 接口，则会回调该接口的 postProcessAfterInitialization() 方法。</p><p>容器关闭后，如果 Bean 实现了 DisposableBean 接口，则会回调该接口的 destroy() 方法，如果Bean配置了 destroy-method 方法，则会执行 destroy-method 配置的方法，至此，整个Bean的生命周期结束。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>在 BeanFactory 容器中，Bean 的生命周期和 ApplicationContext 下的 Bean 周期差不多，只不过 BeanFactory 容器启动的时候，不会去实例化所有 Bean，而是<strong>在调用的时候去实例化</strong>，如图所示：<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F2.png" alt="浅谈Spring Bean的生命周期和作用域2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP浅析</title>
    <link href="https://www.shengshiyu.cn/posts/8cc832a6/"/>
    <id>https://www.shengshiyu.cn/posts/8cc832a6/</id>
    <published>2018-12-25T16:00:00.000Z</published>
    <updated>2018-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%90.jpg" alt="TCP和UDP浅析"></p><h1 id="关于UDP你需要知道"><a href="#关于UDP你需要知道" class="headerlink" title="关于UDP你需要知道"></a>关于UDP你需要知道</h1><p>UDP继承了IP包的特性，不保证不丢失，不保证顺序到达，它只管发出去，打个比方，它就像懵懂无知的小孩，它认为只要是发出去的东西，很容易就能送达，不会丢包。而且它<strong>不会建立连接，它也不会进行拥塞控制</strong>，只管往外发就行，一根筋。</p><p>虽然UDP报文<strong>没有可靠性保证</strong>、<strong>顺序保证和拥塞控制</strong>，<strong>可靠性较差</strong>。但也正因为如此，UDP协议的控制选项较少，在数据传输过程中<strong>延迟小</strong>、<strong>数据传输效率高</strong>，适合对可靠性要求不高的应用程序，需要处理速度快，时延低，可以容忍少数丢包，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。</p><p>在网络质量很差的环境下，UDP协议数据包丢失会比较严重。但是由于它传输过程中资源消耗小，处理速度快，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包到达的消息及时反馈回来，那么网络就是通的。在默认状态下，一次“ping”操作发送4个数据包，对方主机发回的确认收到的数据包也是4包，这充分说明了UDP协议是<strong>面向非连接</strong>的协议，没有建立连接的过程。</p><p>UDP协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据包在传输过程中被篡改或者损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测出是否出错。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%901.jpg" alt=""></p><h1 id="关于TCP你需要知道"><a href="#关于TCP你需要知道" class="headerlink" title="关于TCP你需要知道"></a>关于TCP你需要知道</h1><p>TCP是<strong>基于连接</strong>的协议，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来，也因为多了这样一个过程，TCP要比UDP复杂很多，可以看一下TCP头的格式。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%902.jpg" alt="TCP和UDP浅析1"></p><p>TCP的包是没有IP地址的，那是IP层上的事。可以对比看出，相对于UDP来说，TCP多了一个<strong>序号</strong>，这个序号的作用是为了给发送的包标号，<strong>防止乱序</strong>，这样我们好知道哪一个应该先来，哪一个后来，做到有理有序。</p><p>其次，它还具有一个<strong>滑动窗口</strong>，我们可以理解为这就是一个管道的大小，越大自然水的流速流量可以更大，越小自然流速就会变小，流量变少，TCP也一样，窗口的大小就是为了能够控制流量的，通过标识窗口大小，就可以知道对方的处理能力，而不会发送过快了，造成拥塞问题，用于<strong>解决流控</strong>的。</p><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>TCP连接的建立，我们通常称为“三次握手”，打个比方，大概就是这样：<br><strong>A：你好，我是A，想和你连接<br>B：你好A，我是B，我收到你提出的连接请求了<br>A：好的B，收到了</strong></p><p>为啥一定要是三次呢？不是两次或者四次，当A发起一个连接是，如果B没有回复，它又如何知道B收到了呢，它会以为包丢了，或者超时未达，又或者B压根不想和它连接，它会很懵逼，以至于可能再发。</p><p>当B收到了请求包，就知道了A的存在，也知道A想和它连接，而且它要是不回复，A会继续重试“骚扰”它一阵子，直到A自己放弃，建立连接失败。如果B愿意连接，OK，立马发个应答包过去，告诉A，我同意和你连接了。</p><p>但是，这个过程一样会遇到种种未知错误，比如这个应答包丢了。。。那A不知道啊，继续“骚扰”。。。所以B为了不受其烦，肯定要为了确保应答到达，不断尝试重发，只要一次到达，它就解脱了。至于怎么确认到达，当然是等A收到了应答包，然后欢呼雀跃的再发送一个应答包，表示”收到了，我们连接吧！“不过你可能会觉得，那我们也要确定A这个应答包到达B啊，不然B咋知道A收到他第二次握手发的包，难道不应该四次握手吗？<br>其实四次握手也是可以的，几十上百次都OK，但那也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了。</p><p>A当然可以建立连接后空闲着，就是不“搭理”B，对于B来说，对于A这种“占着茅坑不拉屎”的行为，自然可以选择主动关闭，从而把空出的资源给其他客户端使用。</p><p>TCP里的序号在“三次握手”中，可以很有效的解决丢包问题，当它俩连接后，A发送了很多个有序排列的包，但中途可能由于种种未知原因，丢了一个，A不知道，但B知道A发的包的总数，它一数，好像差了一个，然后再告诉A。而且这个序号的起始序号是随时间变化的，不会重复，为了防止某些包绕路，等到了其实已经无用了，所以IP包头里有个TTL，也就是生存时间。</p><p>这里有个<strong>时序图</strong>，可以看一下，而且TCP头里还有一些<strong>状态位</strong>，其中<strong>SYN</strong>表示发起一个连接，<strong>ACK</strong>表示回复，<strong>RST</strong>表示重新连接，<strong>FIN</strong>表示结束连接，这样这个时序图就好理解了。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%903.jpg" alt="TCP和UDP浅析2"></p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>嗯，说散就散，说完了连接，该说下“四次挥手”了，它大概是这样的：<br><strong>A：我们分手吧<br>B: 哦，你想分了啊，那好吧，知道了。。。</strong></p><p>这个时候，只是A想分手离开了，也就是A不再发送数据，那B能不能在ACK的时候直接选择关闭呢，反正A都要分了，自然是不行的，因为A可能是发完了最后的数据就准备分手了，但是B还没做完它的事情，还是可以发送数据的，处在一种半关闭状态，这个时候A可以选择不再接受数据，也可以选择最后再接受一段数据，等待B也主动关闭。于是就有了：<br><strong>B： OK，那我不陪你了，再见<br>A： 嗯，再见</strong></p><p>然后整个连接就关闭了，但是上面是一种理想情况下的分手，可能会遇到很多异常情况，例如，A说完分手后，直接走了，B不知道，B发的回复A就收不到了，B会陷入不知所措。也有可能是B说完分手后，他倒是处于半关闭的还在着，B直接生气走了，A也会陷入两难抉择，究竟B是还有事没处理完，还是一会就关闭了，针对这一系列问题，我们来看断开连接时候的时序图。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%905.jpg" alt="TCP和UDP浅析3"></p><p>从图中我们可以看到，当A说分手了，就进入<strong>FIN_WAIT_1</strong>的状态，可以理解为等待结束第一阶段，而B回复完A后也相应进入<strong>CLOSE_WAIT</strong>状态，理解为等待关闭。A收到B的回复，就进入了<strong>FIN_WAIT_2</strong>状态，如果此时B直接离开了，那A就一直保持在这个状态。如果B没有离开，主动地又说“再见”，然后它就进入了<strong>LSAT_ASK</strong>状态，然后A收到了B说得“再见”他也发送响应，“嗯，再见”然后进入了<strong>TIME_WAIT</strong>状态，当B收到A的ASK就会关闭了。而假如这个ASK没有到达，因为只有到达B才会进入关闭，但A已经进入关闭倒计时了，它会保持在这个状态一段时间，然后自动的关闭了，所以这段时间里，B会不断地发送“再见”，直到收到一条A的ASK为止。</p><p>假如B在A的最后这段“停留期”，还是没有等来一个回复，虽然它还是会发，当A收到这个后，就会直接回复一个<strong>RST</strong>，B就知道A跑了，就不再发“再见”了。</p><h2 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h2><p>其实就是将TCP连接和分手的两个时序图结合起来，就是表面看起来高大上的<strong>TCP状态机</strong>了。网络上的传输是没有连接的，包括TCP也是一样的，所谓的连接不过是通讯的双方维护的一个“<strong>连接状态</strong>”<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%904.jpg" alt="TCP和UDP浅析4"></p>]]></content>
    
    <summary type="html">
    
      传输层里比较重要的两个协议，一个是TCP，一个就是UDP了，而且这两个协议往往放在一起来讲，那么它们之间具体的区别又是啥，又有什么联系呢？TCP的状态机又是什么？
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="TCP" scheme="https://www.shengshiyu.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://www.shengshiyu.cn/posts/1a4b62fe/"/>
    <id>https://www.shengshiyu.cn/posts/1a4b62fe/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-12-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" alt="设计模式之单例模式"></p><h1 id="关于单例模式"><a href="#关于单例模式" class="headerlink" title="关于单例模式"></a>关于单例模式</h1><p><strong>单例模式</strong>作为对象的创建模式之一，它确保一个类<strong>只有一个实例</strong>，而且自行实例化并向系统提供这个实例，而这个类也称为单例类。</p><p>在《Java编程思想》一书中，作者在代码的例子中无形糅合了诸多设计模式，这也是它被誉为经典的原因之一。其中单例模式的出现频率很高，可见作者对单例模式的偏爱。</p><p>当一些对象我们可能只需要一个时，例如线程池、缓存、对话框等等，如果制造多个实例可能就会出问题。像 Spring bean 默认就是单例的，对于一些<strong>共享资源</strong>的管理就可以使用单例。</p><p>单例模式的特点：</p><ul><li>单例类<strong>只有一个实例</strong></li><li>单例类必须<strong>自己创建</strong>自己的唯一实例</li><li>单例类必须给<strong>所有对象</strong>提供这一实例</li></ul><h1 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h1><p>一个简单的单例类是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="comment">//利用静态变量保存Single类唯一实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明构造器为私有，防止实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它通过<strong>静态方法调用私有构造器</strong>，而这个实例在调用时被创建出来，单例模式确保一个类只有一个实例，并提供一个全局访问点。但这样的方式会一直到你需要使用这个实例时才会创建，如果你需要在加载类的时候就创建对象实例，可能需要稍稍修改一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h2><p>对于多线程而言，我们需要在getInstance方法前加上 <strong>synchronized</strong> 关键字，实现同步。<br><code>public static synchronized Singleton getInstance()</code><br>但这样的暴力做法可能会影响性能，除非 getInstance 方法的性能对应用程序不是很关键，那么可以选择暂时无视。更好的方式是利用“<strong>双重检查加锁</strong>”，减少在 getInstance 方法中使用同步。</p><blockquote><p>所谓“双重检查加锁”机制，指的是：并不是每次进入 getInstance 方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p></blockquote><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="comment">//被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 <strong>volatile</strong> 关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，除非有必要，否则尽量不要大量使用这种方式。</p><h2 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h2><p>实现单例的一个更好的方式是利用<strong>枚举类</strong>，代码更加简洁，也是一种更加高效安全的实现单例的手段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    <span class="comment">//定义一个枚举的元素，它就代表了Singleton的一个实例。</span></span><br><span class="line">    uniqueInstance;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//单例可以有自己的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//功能处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      设计模式可以提高代码可重用性、代码的易读性、保证代码的可靠性。这是关于设计模式的第一篇文章，从常用的单例模式开始。
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Design Pattern" scheme="https://www.shengshiyu.cn/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>谈谈大众传媒</title>
    <link href="https://www.shengshiyu.cn/posts/62359f54/"/>
    <id>https://www.shengshiyu.cn/posts/62359f54/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E8%B0%88%E8%B0%88%E5%A4%A7%E4%BC%97%E4%BC%A0%E5%AA%92.jpg" alt="谈谈大众传媒"></p><p>互联网时代，与其说是流量的争夺战，不如说是注意力的争夺战。传统的纸媒时代早期，纽约《太阳报》的创立开启了广告赚钱吸引眼球的新模式。在那之前，广告仅仅作为新闻的一种信息补充，《太阳报》专门把传统公告栏的那些小的信息变成了高大上的广告，因为之前是没有真正意义上的广告业的。商家并不知道这样的模式，当这样的新模式诞生后，商家因此尝到了甜头，很乐意出钱给传统纸媒作宣传，而这也成为了那个时期纸媒的一个重要的收入来源。</p><p>同时《太阳报》里也更注重受众的需求，它们刊登的新闻讯息都是平民百姓很感兴趣的内容，例如<strong>自杀新闻和家庭风波</strong>，成功吸引了它们的注意力，然后也间接促成了<strong>广告事业</strong>的成功。这一点和如今的一些新媒体行业有很多相似之处，用内容去吸引用户，用流量的增长推动广告的成功，不仅仅是免费，甚至还会返利，只要你使用这个产品的时间越多，滞留的时间越长，就可以获得收益，可以在积累到了一定的限额进行提现。</p><p>“科学”的<strong>推荐算法</strong>，使得推送的内容满足了绝大部分用户“个性化”的需求，但也因此使你所收到的信息更多在你了解和感兴趣的范畴内。就像在搜索引擎中搜索一样，你不会知道那些你不知道的东西，所以你最终所了解的东西更多还是停留在了那个层面。</p><p>这是一个<strong>碎片化阅读</strong>盛行的时代，如何有效的吸引用户的注意力成为了重中之重，而一些深度阅读，思想深刻的长篇大论，反倒不那么<strong>受人待见</strong>，除非它是一个“<strong>爆款</strong>”热文，潜意识的让人觉得读完后会受益匪浅，那么对于广大的普通受众来说，他才会考虑耐心去细细品读。当然这也和本身文章内容质量很高有关，它确实吸引人，观点新颖，但很多类似的好文章可能只有石沉大海的宿命。就像微信公众号里的文章，判断文章质量的评判标准更多会从是否是“十万+”出发，似乎这已经成为了“优秀”的一种标志。而一些观点深邃，逻辑更为严谨复杂的好文章，它对受众形成了一定的阅读门槛，可能它就失去了成为“十万+”的可能。</p><p>曾几何时《太阳报》的成功，推动了其他竞争对手的进步，但随着竞争的愈演愈烈，各家报纸都开始提供更 “<strong>low</strong>” 的新闻以<strong>博取大众眼球</strong>，艳俗新闻以及暴力死亡事件中对血腥场景的过度描述。再到后面一些纸媒开始报道假新闻，最终引起了绝大部分人的反感。甚至为了获取利益刊登一些<strong>虚假广告</strong>，对广告主的背景不作具体的了解，刊登广告的门槛越来越低，引起了诸多社会问题。最终没过几年，这样的乱象就消亡了。</p><p>这种形式和如今的一些互联网传媒行业是如此相似，只不过是从线下搬到了线上，而且由于技术不断的发展，基于新技术的新形式和新体验也成为了吸引用户注意力的重要手段之一。如今，每天都在产生着海量的信息，过去所要担心的取材难题在当今时代基本不会成为重要的制约障碍。因为我们可取的素材遍地都是，更需要关注的是搜集后的<strong>整理和结合</strong>。因为如今每一个人都可以算是一个自媒体平台，能人辈出，即使单纯的模仿，对于一些人来说也会由于先入为主认为这是原创，从而有了成为“爆款”的可能，从而获得成为网红的机会。</p><p>其实在模式上，相比于曾经传统的纸媒行业，如今，媒体本身是可以<strong>不生产内容</strong>的，它们更多提供的是一个<strong>平台</strong>，每一个使用这个平台的自媒体人都够为它们创造流量。对于这些人来说，他们吸引了一大波粉丝的同时，也能从中为自己获取收益。因为某些时候，商家费劲花重金做的一个广告，产生的效益甚至不如请一个流量大V来做一次短视频宣传的价值。</p><p>关于<strong>内容价值</strong>和<strong>流量价值</strong>，记得在我上学时，课上总在强调内容为王，但当今的事实却是，内容没有发展起来的时候，更多都是以流量为主。这二者可以说同样重要，在某些方面或许其中的某一者的占比会高一些，但在互联网的大背景下，尤其是移动终端——智能手机的普及，流量显得尤为重要。传统媒体强调的内容为王的产业形态，在这样的时代背景下，虽然也依然重要，但流量带来的红利和影响力会让内容的价值更大，反过来流量的重要性也不断的凸显。</p><p>网红就如同时代的浪潮，随着时间，一浪高过一浪，不断有新的原创模式竞相出现。就个人而言，受制于自身知识的和技能水平，也难免会有<strong>创造力枯竭</strong>的时候，因为用户的注意力来的快去的快。而对于企业而言，关注的更多可能就是哪些新的技术手段，运营模式能便于用户生产出质量更高的内容，能最大化的吸引用户的注意力。</p><p>由于平台本身对于内容质量把控是有限度的，如果把控质量要求过高势必会造成内容量大幅度减少，难以吸引更多用户，太低又会产生诸如假新闻等的一系列问题。用户本身就偏向追逐一些“快餐式”阅读体验，简单轻松，不会需要很高的阅读门槛，也喜欢“鸡汤”，产生心理上的及时反馈，毕竟看似无害的东西谁又知道它真的就有用呢？类似《太阳报》时代不同纸媒曾经用过的手段，如今依然能看到它们的影子，成为了吸引用户注意力，保持较高平台流量的重要手段。大众传媒从来就不是<strong>高雅的产物</strong>，某种意义上而言，它也可以是<strong>低俗</strong>的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>HTTP指北</title>
    <link href="https://www.shengshiyu.cn/posts/2111c3b6/"/>
    <id>https://www.shengshiyu.cn/posts/2111c3b6/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2018-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTP%E6%8C%87%E5%8C%971.jpg" alt="HTTP指北1"></p><h1 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h1><p>HTTP是应用层的协议，当我们打开一个网页时，例如：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>,浏览器会将这个域名地址发送给DNS服务器，然后解析为具体的IP地址。</p><p>建立好连接后，浏览器就可以发送HTTP的请求了，而一个完整的HTTP请求报文由三部分组成：<strong>请求行</strong>、<strong>请求头（首部）</strong>、<strong>请求体（实体）</strong>。每一行的末尾都有回车和换行，在请求体和请求头之间另起一行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是以key:value这样的键值对的形式存在的，请求体就是要传输的数据。<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTP%E6%8C%87%E5%8C%972.jpg" alt="HTTP指北2"></p><p>HTTP里有很多请求方法，其中最常用的就那么几个，对于访问网页来说，使用的最多的就是<strong>GET</strong>方法，用来向服务器端获取一些资源，具体返回什么，由服务端来决定。</p><p>另一个常用的请求方法类型是<strong>POST</strong>，它需要你主动告诉服务端一些信息，一般这些信息放在请求体里，与GET不同，POST更多是用来更新资源信息，GET提交请求的数据实体是放在URL后面，用?来分割，参数用&amp;连接，而且数据长度是有限制的，视具体的客户端而定，而POST没有限制，而且GET提交的数据是不安全的，因为相关参数会暴露在URL上。</p><p>还有一种类型，叫做<strong>PUT</strong>，它的作用是向指定资源位置上传最新内容，类似于FTP协议，文件内容包含在请求体里，不过HTTP服务器一般是不允许上传文件的，所以PUT和POST就都变成了要传给服务器内容的方法。</p><p>最后一种比较常见的方法就是<strong>DELETE</strong>，主要就是用来删除文件，是与PUT相反的方法，DELETE是要求返回URL指定的资源。</p><p>请求行的下面就是请求头了，保存了一些很重要的字段，例如, <strong>Content-Type</strong> 是指正文格式，如果是JSON格式的，就要把值设为JSON，而类似 <strong>Accept-Charset</strong> 则表示客户端可以接受的字符集，避免不必要的乱码。首部字段有很多，其实通过名字我们就能大概它的用法的，用到的时候可以想了解细节再去查。</p><p>当我们使用HTTP发送请求时，由于它是基于<strong>TCP</strong>协议，所以它使用面向连接的方式发送请求，在发送每段报文时，都需要对方回应一个ACK，确认已经到达，如果没有收到对方的回复，TCP就会重新进行传输，直到到达为止，而这个过程是TCP负责的，也就是说无论重新传输了几次，对于HTTP来说它只进行了一次传输，由TCP来完成这个送达的过程。</p><p>TCP每发送一个报文都会加上自己本身所在的地址以及它想要到达的另一端的位置，将它们放在IP头里，然后交给IP层进行传输。IP层会查看目标地址和自己所在的地址是否同在一个局域网里，如果在的话就发送ARP协议，获取目标地址的MAC地址，然后把自己的MAC地址和目标MAC地址放到MAC头发送出去，由另一端来进行层层对比确认，然后发送一个ACK，确认到达。如果不在一个局域网里，就要经过网关，而MAC头里放的就是网关的地址，因为我们不知道目标的MAC地址，网关再根据路由协议来获取下一跳的路由器MAC地址，然后加入到目标MAC地址那，由于还不是真正的目标MAC地址，会不断重复这个“寻找”的过程，直到下一跳是目标所在，然后获取到目标的MAC地址。</p><p>在TCP头里还有端口号，通过确认MAC地址，IP地址后，通过端口号，目标机器就会知道哪一个进程需要这个包，然后发送给那个进程，例如HTTP服务器，然后HTTP服务器就知道请求的资源是什么，然后把相关资源发送给客户端。</p><p>HTTP的返回报文和响应报文类似，简单来说响应报文由<strong>状态行</strong>、<strong>响应头（首部）</strong>、<strong>响应体（实体）</strong>组成，其中第一行是状态行，包含HTTP版本，状态码和状态短语，在一个回车换行之后是响应头，也是以键值对的形式，之后是响应体，也就是要传输的数据。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTP%E6%8C%87%E5%8C%973.jpg" alt="HTTTP指北3"></p><h1 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h1><ul><li><strong>HTTP协议是无状态的</strong><br>什么是无状态，就是协议对于事务处理没有记忆能力，对于同一个URL请求没有上下文的联系，每一次的请求都是独立的，不会受前后结果的差异影响响应，但为了使它具有状态的特点，于是引入了 cookis 和 session 机制。</li><li><strong>基于TCP协议</strong><br>HTTP协议属于应用层，它的目的是规定客户端和服务端数据传输的格式和数据交互行为，而数据传输的实现，它是基于传输层TCP协议实现的，它本身并不能进行数据传输。</li></ul><h1 id="HTTP的响应状态码"><a href="#HTTP的响应状态码" class="headerlink" title="HTTP的响应状态码"></a>HTTP的响应状态码</h1><p>状态码是用来告知客户端服务器端处理请求的结果。凭借状态码用户可以知道服务器是请求处理成功、失败或者是被转发；这样出现了错误也好定位。状态码是由3位数字加原因短语组成。3位数字中的第一位是用来指定状态的类别。共有五个类别。<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTTP%E6%8C%87%E5%8C%974.png" alt="HTTTP指北3"><br>不过常用的也就16种，下面来详细介绍下：</p><p><strong>1. 200：OK</strong><br>代表请求被正常的处理成功</p><p><strong>2. 204：No Content</strong><br>请求处理成功，但是没有数据实体返回，也不允许有实体返回。比如说HEAD请求，可能就会返回204 No Content，因为HEAD就是只获取头信息。</p><p><strong>3. 206：Partial Content</strong><br>这是客户端使用Content-Range指定了需要的实体数据的范围，然后服务端处理请求成功之后返回用户需要的这一部分数据而不是全部，执行的请求就是GET。返回码就是206：Partial Content。</p><p><strong>4. 301： Moved Permanently</strong><br>代表永久性定向。该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL。也就是说如果已经把资源对应的URL保存为书签了，这是应该按照Location首部字段提示的URL重新保存。</p><p><strong>5. 302：Found</strong><br>代表临时重定向。该状态码表示请求的资源已经被分配了新的URL，但是和301的区别是302代表的不是永久性的移动，只是临时的。就是说这个URL还可能会发生改变。如果保存成书签了也不会更新。</p><p><strong>6. 303：See Other</strong><br>和302的区别是303明确规定客户端应当使用GET方法。</p><p><strong>7. 304：Not Modified</strong><br>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但是没有满足条件。304状态码返回时不包含任何数据实体。304虽然被划分在3XX中但是和重定向没有关系。</p><p><strong>8. 307：Temporary Redirect</strong><br>临时重定向，与302 Found相同，但是302会把POST改成GET，而307就不会。</p><p><strong>9.  400：Bad Request</strong><br>表示请求报文中存在语法错误。需要修改后再次发送。</p><p><strong>10. 401：Unauthorized</strong><br>表示发送的请求需要有通过HTTP认证的认证信息。</p><p><strong>11. 403：Forbidden</strong><br>表明请求访问的资源被拒绝了。没有获得服务器的访问权限，IP被禁止等。</p><p><strong>12. 404：Not Found</strong><br>表明请求的资源在服务器上找不到。当然也可以在服务器拒绝请求且不想说明理由时使用。</p><p><strong>13. 408：Request Timeout</strong><br>表示客户端请求超时，就是在客户端和服务器建立连接后服务器在一定时间内没有收到客户端的请求。</p><p><strong>14. 500：Internal Server Error</strong><br>表明服务器端在执行请求时发生了错误，很有可能是服务端程序的Bug或者临时故障。</p><p><strong>15. 503：Service Unavailable</strong><br>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After字段再返回给客户端。</p><p><strong>16. 504：Getaway Timeout</strong><br>网关超时，是代理服务器等待应用服务器响应时的超时，和408 Request Timeout的却别就是504是服务器的原因而不是客户端的原因。</p>]]></content>
    
    <summary type="html">
    
      HTTP的重要性无需多言了，几乎是每一个人上网使用的第一个协议，尤其对于技术岗位来说理解掌握HTTP协议是必须的，这里记录了HTTP的基础知识以及一些常见的用法。
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="HTTP" scheme="https://www.shengshiyu.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>非“你”不可</title>
    <link href="https://www.shengshiyu.cn/posts/2229ab2/"/>
    <id>https://www.shengshiyu.cn/posts/2229ab2/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2018-11-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E9%9D%9E%E2%80%9C%E4%BD%A0%E2%80%9D%E4%B8%8D%E5%8F%AF.jpg" alt="非你不可"></p><p>我们之所以要购买产品和服务，是因为我们需要购买它们来为我们完成某项特定的任务。这是我们购买一件产品或是一项服务的初衷。我们不会去买我们不需要的东西，因为并不存在潜在的解决任务需求。</p><p>一个产品，当它与其他同类产品的差异逐渐缩小，这里的差异也可以认为是它对于完成我们那些“任务”的<strong>效率差异</strong>逐步缩小。再没有更好选择时，那么我们可能才会对比其他方面，从其他方面入手，例如产品的外观、材质，是否更耐用，外观更出色。</p><p>曾经我们购买一件产品时的出发点就是如此，但如今随着经济的繁荣，各式商品琳琅满目，我们会看到许多外观十分特别，功能是“独特”的产品，但当我们使用时会发现，本质上它和一些我们熟悉的类似产品在解决任务的效率上并没有本质变化，价格更为昂贵，只是我们“认为”它们能更出色的完成任务，但事实上并不一定。</p><p>就拿<strong>柔性电子产品</strong>来说，它分为三大类：柔性屏幕，柔性电池和柔性集成电路。目前来看，国内最大的相关公司是柔宇科技，国外则是三星，我觉得这个产品是否更“出色”，不是它外观的新颖，形式的创新，而是它在全面屏满足的需求上又解决了什么问题，哪些地方更好，而这些点是否紧贴用户的潜在需求，那么这样产品才能被买单。</p><p>跳出原有的认知，将这样的产品应用于其他领域，是否在其他领域上使用这把“刀”要比原有的方式更出色，探索这样的<strong>可能性</strong>，一意孤行的去创造一种新形式的产品，哪怕它具有很先进的技术，但它所能解决问题的能力并不比其他传统产品大多少，先进的技术应用在其上就是一种浪费，它也注定了被市场抛弃的结局。</p><p>有交易就会有信息不对称，通过“<strong>包装</strong>”，我们确实可以让一个普通产品成为“爆款”，风靡一时，但一家企业想要<strong>基业长青</strong>，需要的是真正富有意义和价值的产品，去关注用户的潜在需求，而不是驻足于花样繁多的形式本身。但如果一个好的设计使得产品本身的优势不断提高，那么这样的形式也是值得肯定的，但它很难成为产品的核心。不断地追求产品本身的价值，而非本末倒置，让它在某段时期里，非“你”不可，才能尽可能的<strong>创造用户</strong>，它比<strong>创造利润</strong>本身更为重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java线程池</title>
    <link href="https://www.shengshiyu.cn/posts/c158fcfc/"/>
    <id>https://www.shengshiyu.cn/posts/c158fcfc/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-10-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg" alt="浅谈Java线程池"></p><h1 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h1><p>线程池是Java并发中一个非常重要的概念，可以把它理解为一个线程的池子，里面包含了若干线程，可以继续<strong>复用</strong>执行新任务，避免了线程创建的开销。</p><p>线程池类似于我们排队办理业务，办理业务时可能提供了若干的窗口，我们根据自己的需要选择合适的窗口。其中办理业务的各个业务员就是线程池中的<strong>工作者线程</strong>，而我们排队的队列就是线程池中的<strong>任务队列</strong>。</p><p>线程使应用能够合理地<strong>协调利用</strong>CPU、内存、网络等系统资源。线程的<strong>创建</strong>需要消耗资源，同时线程的<strong>销毁</strong>也需要回收这些系统资源。<strong>频繁地创建和销毁线程会浪费大量的系统资源</strong>。另外，在服务器负载过大的时候，如何让新的线程等待或者友好地拒绝服务，这些都是线程自身无法解决的。所以需要通过线程池协调多个线程。</p><h1 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h1><p>线程池不建议使用 <strong>Executors</strong> 去创建，而是通过 <strong>ThreadPoolExecutor</strong> 的方式。在 ThreadPoolExecutor 提供了四个构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过其源码，可以看到其中包含四个参数，它们分别表示：</p><ul><li><strong>corePoolSize</strong>：核心池的大小</li><li><strong>maximumPoolSize</strong>：线程池最大线程数</li><li><strong>keepAliveTime</strong>：表示线程没有任务执行时最多保持多久时间会终止</li><li><strong>unit</strong>：参数keepAliveTime的时间单位</li><li><strong>workQueue</strong>：工作队列，本质是一个阻塞队列，用来存储等待执行的任务，一般阻塞队列有：ArrayBlockingQueue（有界阻塞队列，一旦创建容量不能改变）、LinkedBlockingQueue（无界队列，没有预先定义容量）、SynchronousQueue（直接传递）。</li><li><strong>threadFactory</strong>：线程工厂，主要用来创建线程</li><li><strong>handler</strong>：当线程的数量已经到了边界值，并且workQueue中任务也达到最大值，此时需要使用它拒绝多余的任务</li></ul><p>Java并发类库目前提供了五种不同的线程池创建配置，它们分别是：</p><ul><li><strong>newCatchedThreadPool()</strong>:用来处理大量短时间工作任务，它会尝试缓存线程并重用，当无线程可用时，就会创建新的工作线程。如果线程限制且时间超过60秒，就会被终止并移出缓存。</li><li><strong>newFixedThreadPool()</strong>:重用指定数目的线程，除非任务数量超过了工作线程，就会在工作队列等待空线程出现，如果有工作线程结束退出，就会创建新的工作线程，达到上限的指定数目。</li><li><strong>newSingleThreadExector()</strong>: 工作线程数目限制为1，保证所有任务都是顺序执行。</li><li><strong>newSingleThreadScheduledExector()/newScheduledThreadPool(int corePoolSize)</strong>: 可以定时或者周期性的进行切换调整，区别在于单一工作线程还是多个工作线程</li><li><strong>newWorkStealingPool()</strong>:Java8引入，可以并行的处理任务，但不保证处理顺序</li></ul><p>如果需要较多等待任务，例如I/O操作，可以参考下这个计算方法：<br><code>线程数 = CPU 核数 × （1 + 平均等待时间 / 平均工作时间）</code></p><p>使用线程池要注意：</p><ul><li><strong>合理设置各类参数</strong>，根据需要合理的设置线程数，避免过度扩展线程，可能引起线程泄漏</li><li><strong>不要自行创建线程</strong>，线程资源通过线程池来创建，避免资源耗尽的风险</li><li><strong>避免任务堆积</strong>，如果处理跟不上入队的速度，工作线程数量不足，就会占用大量内存空间</li><li>线程和线程池的<strong>名称最好直观易于理解</strong>，必要时增加注释</li></ul><h1 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h1><p>线程池可以实现类似主次线程隔离、定时执行、周期执行等任务。使用线程池的好处有：</p><ul><li><strong>有效的管理并复用线程、控制最大并发数</strong>。</li><li><strong>有利于实现某些与时间相关的功能，如定时执行、周期执行等</strong>。</li><li><strong>有利于实现任务线程队列缓存策略和拒绝机制</strong>。</li><li><strong>隔离线程环境，避免相互间线程的影响</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>文化与媒介</title>
    <link href="https://www.shengshiyu.cn/posts/5af50fe0/"/>
    <id>https://www.shengshiyu.cn/posts/5af50fe0/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%96%87%E5%8C%96%E4%B8%8E%E5%AA%92%E4%BB%8B.jpg" alt="文化与媒介"></p><blockquote><p>有人说文化可以用四句话表达：植根于内心的修养，无须提醒的自觉，以约束为前提的自由，为他人着想的善良。</p></blockquote><p>“文化”是一个很抽象的概念，它本身也具有很强的<strong>人文意味</strong>，因为文化本身就是“<strong>人文化成</strong>”的一个缩写。人文一词在我看来，它是把很多客观现实的存在经过我们人为的重组与再认知，概括为了一个抽象层次更高的概念，而它是客观世界原本不存在的，并且它可以成为我们的一种生活方式。</p><p>相对于其他物种而言，“文化”活动可以说是人类所<strong>独有</strong>的，对于人类而言，文化是不可或缺的。为什么文化显得重要，从其他角度来看，或许文化是一种<strong>非物质化</strong>的“媒介”，它抽象层次更高，依托于很多不同的实体，它本身就能很好的传递一些信息，但它也可以很抽象，令人难以理解。</p><p>对于媒介本身而言，它最重要的作用就是作为承载信息的桥梁，实现信息的交换，如果一个媒介在信息交换的速度上很快，那么它对整个社会的影响力也会不断提高。文化，无论是对社会，还是对国家，又或者对公司，乃至个人，在某些方便都可以算是一个很好的“媒介”。但它不像文字或是图片，具有固定的形式，文化是<strong>不同实体结合抽象后</strong>的统称。</p><p>一些思想的具体内容，可能以文字这类形式没法具体的传递给对方。例如，中国传统武术文化里，关于太极的思想，其实它是一个极为抽象的概念，可能通过文字的表述我们很难领悟其中的真谛，达到所谓知行合一的境界。但武术文化不同，它将这样的思想和具体的动作结合，当我们在演练时，我们可以通过具体的动作，将那种刚柔并济，圆润统一的意味具体的<strong>外化表现</strong>出来，通过这样的形式加深我们对于“太极”的理解，乃至上升到哲学里的矛盾的对立与统一。这类复杂抽象的哲学思想，通过武术文化的具象表现形式，可以有效地传递给对方。</p><p>不同的地方有着不同的文化，它们所承载的东西也截然不同。就像在公司工作时，当一个公司刚起步，处于初创阶段，可能人才，资金，技术会很重要，但随着时间的推移，公司不断的发展壮大，就需要把这些有形资源变为具体的<strong>流程和价值标准</strong>来执行，当一个公司发展足够庞大，那么就需要企业拥有自己的文化，由文化价值观来驱动各项流程的顺利实施。所以我们不光要学习国外先进企业的研发能力，更要学习他们的职业文化，达成企业到员工之间的一种无形的沟通桥梁。</p><p>若有更好的方式能实现“文化”所发挥的作用，那么文化的作用便会被弱化，但在某些方面“文化”确实是一个出色的“媒介”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>IOC与需求变化</title>
    <link href="https://www.shengshiyu.cn/posts/fe27ee39/"/>
    <id>https://www.shengshiyu.cn/posts/fe27ee39/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/IOC%E4%B8%8E%E9%9C%80%E6%B1%82%E5%8F%98%E5%8C%96.jpg" alt="IOC与需求变化"></p><p>需求变化是程序员需要面对的一个难题，尤其在需求频繁变更的情况下，这意味着我们可能又要加班加点忙活一阵了。不断地完成旧需求，又不断地解决新需求，凭借我们的直觉，实现需求即可，只要把要求的需求一个个按时完成上线就万事大吉，没有更多考虑到未来可能产生的需求变化。“僵硬”的构建过程所带来的就是日后依然需要投入很多时间处理需求变化，而非一个灵活的设计，可以不被需求牵着鼻子走，直接自己掌握多样化的需求。可以有效减少本没有必要出现的加班乱象。</p><p><strong>控制反转</strong>（IOC）作为面向对象编程的一种设计思想，意味着在 Java 中，我们将设计好的对象交给<strong>容器来控制</strong>，而不是传统的操控对象本身，由对象内部再来作控制。具体来说，传统的程序设计是主动地创建一个具体对象，再将它们组合起来，其中一个类可能依赖于另一个类，所以我们需要由我们创建的对象去主动地获取依赖的对象。</p><p>控制反转思想则<strong>由容器来为我们完成查找相关依赖对象，再将它们注入进来的工作</strong>，然后我们就能获得我们需要的具体对象，因为我们只能被动接受依赖对象的注入，不再像传统过程一样，由我们自己创建自己去获取，这个过程被<strong>反转</strong>了，由容器来控制。通过依赖注入可以有效实现解耦，但IOC并不仅仅作用于此。</p><p>控制反转，是一种重要的设计思想，其实也比较好理解，我们买电脑时，可能对于外行人来说，什么处理器型号，显卡型号，内存大小啥的，他们可能听过，但对具体区别不是特别了解，如果再具体细分处理器是标压还是低压，超频多少，风扇转速之类的，他们会晕了的。他们只知道他们想要的是一台可以玩大型游戏，剪辑视频的电脑，又或者是一台轻薄便携续航长可以流畅办工上网的电脑。</p><p>我们不用专门给他们介绍具体硬件上参数型号的差异，因为他们认知里，电脑就是电脑，能实现这个需求的就可以称为“电脑”，就像能打电话聊天的便携设备就可以叫“手机”，我们不用去知道实现的具体标准是啥，它需要哪些硬件，啥处理器、显卡、内存之类的，这个标准早就由产业本身制定规划好了，用户的需求要在这个标准下才能满足，而非漫无目的根据用户的需求，实现了一堆充斥不知名硬件设备形似电脑的东西，虽然它也实现了我们对电脑的定义需要的种种需求，但这样也使得我们要疲于应对各式需求，想办法做出符合需求的东西。</p><p>有了一个<strong>标准</strong>，一个有效的<strong>设计模式</strong>，可以大大节省我们不必要的人力投入，用户需求将成为设计的约束条件和验证手段，而不是出发点和目标。这样可以避免需求的变化让我们疲于奔命的工作状态。毕竟，谁又喜欢经常性不必要的加班呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>声望的陷阱</title>
    <link href="https://www.shengshiyu.cn/posts/621d5fbd/"/>
    <id>https://www.shengshiyu.cn/posts/621d5fbd/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E5%A3%B0%E6%9C%9B%E7%9A%84%E9%99%B7%E9%98%B1.jpg" alt="声望的陷阱"></p><p><br></p><blockquote><p>命运是解不开的谜团，声望是没有实际意义的云烟。</p></blockquote><p>什么是声望？一个官方的解释是：声望是众所仰望的名声。人生在世，我们总有为声望所累的时候，但我的阅历尚浅，对于“声望”不好妄作评判，仅仅只能按我的理解，谈谈在当前时代下的“声望”的影响。</p><p>个人具有声望，组织和团体也具有声望，声望是一种<strong>看不见的影响力</strong>，它不好量化，但它却能无形中<strong>影响</strong>很多东西，就像我们玩的游戏，会有所谓的声望值，当你具备不同声望值时，就有权限获得一些稀有物品一样。</p><p>但游戏终究和现实不同，现实世界充满着许许多多的不确定性。可能具有很高声望的人或事物，会对人们的判断施加一定的影响，因为我们<strong>辨别和判断</strong>一件事物的好坏需要经过深思熟虑，这个过程对很多人而言并不那么“友好”，而具有了高声望，就能在判断上无形给予一定的肯定，<strong>简化</strong>了“深思熟虑”这项工作的任务量，因为声望的积累是基于大量的评价和时间的考量的，更能使人<strong>确信</strong>“它”对自身是有益的，由于思维的“惯性”我们就会自然而然选择了相信。</p><p>如同<strong>品牌效应</strong>，大厂出品一定会因为它完善的工艺和流程，质量上一定比同类产品更好。但销量高并不一定代表质量好，它们之间并不存在绝对意义上的正相关。对外部具有很高声望事物的盲目肯定，终会使我们的判断受制于对方。</p><p>假如没有了声望对判断施加的影响，那么<strong>真正吸引</strong>我们的，又是对方的什么呢？就拿衣食住行来说，我们选购一件衣物的判断，究竟是基于对品牌所积累的声望的信任，认为它一定用了优质的物料，一流的设计，还是商品本身质量就很不错呢？毕竟我们的世界是变化的，同样的产品或是服务，终究会随着时间的流逝产生差异的变动，很难“<strong>始终如一</strong>”。</p><p>如果商品和服务是我们还能切身在短时间内能感受到变化的，比较容易减小声望对人判断的影响。那么人呢？评判和了解一个人或许是一件复杂度极高的任务，我们难以短时间真正了解一个人，我们所基于的判断，来源于那个人的过去经历，例如他的受教育水平，是否具有本科学历，进而又要细分是否是名牌一流大学，因为那些大学本身所具有的声望能证明很多东西。如果是在校时就看在校的比赛获奖情况，进而又要区别看比赛的规模和大小，因为一些比赛具备参考价值，它确实选拔出了许多出色的人才，随着时间的积累，这个比赛所积累的声望就成为了一种“隐性标志”，暗示只要我获奖了，那么代表了我和曾经获奖的那些名人也具备同样的素质和潜力，而名人的成功也间接为类似比赛的声望添砖加瓦。但事物是变化的，我们只能保证在那样一个时间段里，它确实具有参考价值，含金量十足，但随着时代的发展，事物的更迭，能时刻保持领先，并始终拥有与之匹配的声望的事物是何其稀少。</p><p>当前的时代是网络时代，处于这个时代背景下的我们无法避免声望对我们判断施加的影响，而且网络的<strong>虚拟化</strong>，谁又知道一切是真的，而非<strong>虚张声势</strong>搭建起来的声望呢？网上购物商城的一些评价可以通过刷单刷好评取得消费者的信任，而最近大火的抖音，我们可以搬运别人的创意，成为自己涨粉的途径，哪怕只是从一些科普常识上搬运一些看起来有价值的东西，加上一个相关行业的背景，却能带来巨大的流量，点赞量和粉丝量无形为其树立起了某种声望，因为这类开放平台的用户量太多了，聚集了不同层次的人，但点赞量和粉丝量却是“一视同仁”的。</p><p>在这样的时代里，最能直接影响声望变化的，或许就是建立于社交媒体之上的舆论导向的，通过<strong>巧妙刻意</strong>的包装，引起舆论的关注，随即带来巨大的流量，无论是提高声望还是影响竞争对手的声望，都是无形的，如果对方的公关不能应对得当，那么就会陷入舆论的漩涡，或许可以通过一些形式“洗白”，但也依然会产生一些无形的影响，而往往这些“看不见”的东西更具风险性。</p><p>不要因为“声望”影响了我们对真实世界的认知，它可以作为评判的依据和参考，但不能作为先入为主的第一选择，无论是对任何事物，亦或是任何人，我们要关注于那些真正决定其本身的东西，避免陷入声望的陷阱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript的“面向对象”编程</title>
    <link href="https://www.shengshiyu.cn/posts/672169fd/"/>
    <id>https://www.shengshiyu.cn/posts/672169fd/</id>
    <published>2018-10-01T16:00:00.000Z</published>
    <updated>2018-10-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E8%B0%88%E8%B0%88JavaScript%E7%9A%84%E2%80%9D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%9C%E7%BC%96%E7%A8%8B.jpg" alt="谈谈JavaScript的”面向对象“编程"></p><h1 id="初识JavaScript面向对象"><a href="#初识JavaScript面向对象" class="headerlink" title="初识JavaScript面向对象"></a>初识JavaScript面向对象</h1><p>相对于 Java 里的面向对象来说， JavaScript 里的<strong>面向对象机制</strong>绝对可以称之为“另类”了，因为如果我们具有 Java/C++ 这类传统面向对象语言的经验，那么以那样的思维来理解 JavaScript 的面向对象令你产生很多疑惑。</p><p>定义一个 JavaScript 对象很简单，我们可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>也可以用其他的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可能你很费解，这不应该是一个函数吗？为什么就变成对象了，因为在 JavaScript 里函数也是对象，而且还是<strong>一等公民</strong>。而在很多传统语言中，例如 Java、C/C++ 等，函数都是二等公民的身份。什么叫二等公民呢？你只能用语言的关键字声明一个函数然后调用它，如果需要把函数作为参数传给另一个函数，或者赋值给一个本地变量，又或是作为返回值，就需要通过函数指针、代理等特殊的方式周折一番。</p><p>而在JavaScript里的函数，它<strong>不仅拥有一切传统函数的使用方式，而且可以做到像简单值一样赋值、传参、返回，而且JavaScript中的函数还可以充当“类”的构造函数，同时又是一个Function类的实例</strong>，这样的多重身份让JavaScript里的函数变得极其重要，使得 JavaScript 更像是 Scheme （一种函数式语言）。</p><p>JavaScript提供了一个<strong>构造函数模式</strong>来在创建对象时初始化对象，而构造函数也只是一个普通的函数，只不过它内部使用<code>this</code>，使用<code>new</code>生成实例，在这一点上很像传统的面向对象语言。而this总是指向当前对象，无论是添加属性还是方法，都只在当前对象添加，实例化一个新对象时，就会在内存里复制一份，但过多的新对象不可避免会造成大量的内存浪费。</p><p>为了解决这一问题，于是有了<strong>原型prototype</strong>的形式，在JavaScript里，每一个构造函数都有一个 <strong>prototype 属性</strong>，指向另一个对象，这个对象的所有实例和方法都会被构造函数的实例继承，对于不变的属性和方法，可以直接添加在类的 prototype 对象上。功能上来看，很像Java里接口的概念，尤其是 Java 8 引入了接口的默认方法，二者在功能上看上去更为接近。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">this</span>.name = name;</span><br><span class="line">　　　　<span class="keyword">this</span>.color = color;</span><br><span class="line">　　&#125;</span><br><span class="line">　　Dog.prototype.type = <span class="string">"宠物"</span>;</span><br><span class="line">　　Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">"吃狗粮"</span>)&#125;;</span><br></pre></td></tr></table></figure></p><p>当我们生成实例时，实例里的属性和方法其实都在同一个内存地址里，指向 prototype 对象，<strong>避免了不必要的内存浪费</strong>。但也会因为改动一个对象的属性而可能影响到其他相关的对象，而利用构造函数的形式则没有这样的弊端。</p><p>传统的面向对象语言里，例如Java，会有相应的<strong>访问控制</strong>功能，借助于 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 这三个关键字，而 JavaScript 里则没有这样的关键字，但为了实现类似的功能，例如属性和方法的私有，就要借助于函数作用域的特性，因为函数内的局部变量如果不通过闭包等方式是无法直接访问的，对外层作用域而言就是“私有”的。</p><h1 id="Javascript里的“类”"><a href="#Javascript里的“类”" class="headerlink" title="Javascript里的“类”"></a>Javascript里的“类”</h1><p>在ES6之前，JavaScript只有一些近似类的语法元素。JavaScript里没有“子类”和“父类”的区分，也没有“类”和”实例“的区别，我们可以模拟出传统面向对象语言里类的特点，但它的机制和我们理解的类的概念是完全不同的，只是通过”语法糖“的包装和”类“库的存在让我们误以为JavaScript的类存在而已。</p><p>那么”类“中的继承又是如何做到的呢？JavaScript主要依靠<strong>继承链</strong>来解决继承的问题。传统情况下，我们在JavaScript生成一个实例的方法都是通过构造函数，类似于这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>而在其他传统面向对象语言里，一般情况下，都是生成一个class，然后再通过类的构造器来生成相应的实例对象，所以 JavaScript 显得很特别。在ES6里引入了“class”的概念和关键字，通过这个关键字，可以定义一个“类”。像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的形式就不容易使人困惑了，它就更接近我们认知里的类的概念了。ES5里的Point构造方法就是ES6里Point“类”里的构造方法,而且toString方法也定义在了“类”里，而在“类”里的方法是不需要function关键字的。</p><p>某种意义上ES6里的“类”就是一个语法糖而已。。。实际上<strong>基本可以看作传统构造函数的一种简便写法。因为类里的所有方法实际上还是定义在 prototype 属性上面。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>而<strong>在“类”的实例上调用方法，其实就是在调用原型上的方法</strong>。不过也有一些差别，在“类”的内部所有定义的方法都是<strong>不可枚举的</strong>。</p><p>在JavaScript里，定义函数的方式有两种，一种是<strong>函数声明</strong>，一种是<strong>函数表达式</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于函数表达式</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对于类来说一样也可以通过表达式定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Point.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>只不过这个类的名字不再是Point，而是MyClass，Point只在class的内部使用，指代当前类。</p><p>JavaScript里的函数声明具有<strong>函数声明提升</strong>的特征，即使放在相关调用语句之后，也会在执行代码之前先读取函数声明，而类不存在这样的提升特性。因为ES6里的“类”，<strong>依然只是之前的构造函数的一层包装罢了</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="JavaScript" scheme="https://www.shengshiyu.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>接口和抽象类的区别</title>
    <link href="https://www.shengshiyu.cn/posts/8275df43/"/>
    <id>https://www.shengshiyu.cn/posts/8275df43/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-09-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="接口和抽象类的区别"></p><p><strong>接口</strong>和<strong>抽象类</strong>是 Java 面向对象里的两种不同机制，尽管某些方面它们看起来相似，但却有本质的不同，定义类的过程就是抽象和封装的过程，而接口与抽象类则是<strong>对实体类进行更高层次的抽象，仅定义公共行为和特征</strong>。由于Java本身不支持多重继承，它们是Java为实现多重继承行为的扩展延伸。</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类是<strong>不能实例化的类</strong>，使用 <strong>abstract</strong> 关键字修饰，除了不能实例化和一般的 Java 类没什么大的区别，可以包含或者不包含抽象方法,但<strong>如果一个类包含一个或多个抽象方法，它一定是抽象类</strong>。</p><p>抽象类一般是抽取相关的Java类中得共有的方法或属性，然后通过继承实现<strong>代码复用</strong>，例如我们常用的 collection 集合框架。</p><p>如果我们<strong>继承抽象类</strong>，并且想创建新类的对象，那么我们必须<strong>为父类的所有抽象方法提供具体实现</strong>，否则这个子类也是抽象类，并且编译器会强制用 abstract 关键字修饰这个类。</p><h1 id="接口的本质"><a href="#接口的本质" class="headerlink" title="接口的本质"></a>接口的本质</h1><p>接口（interface）是<strong>对行为的抽象</strong>，它是抽象方法的集合，但接口<strong>不能被实例化</strong>。接口也不能包含任何<strong>非常量成员</strong>，因为默认其中的域隐式都为 <strong>public static final</strong> 的。</p><p>实现 interface 时使用 <strong>implements</strong> 关键字，<strong>接口中不能有任何非静态方法的实现，只能包含抽象方法和静态方法</strong>。并且接口中的域隐式都是 <strong>static final</strong>的，所以接口很适合用来作为创建常量组的手段。不过在<strong>Java 8</strong>以后，接口也提供了<strong>默认方法</strong>的支持,使用 <strong>default</strong> 关键字</p><p>接口中，它允许我们创建方法名，参数列表和返回类型，但<strong>不包含任何具体的实现</strong>。由于Java中并不支持多重继承，通过interface可以使我们<strong>创建一个可以被向上转型为多种基类的类型</strong>，变相实现多重继承的行为特征。</p><p>接口中所有的方法都是 <strong>public</strong> 的，所以即使我们不显式指定，它们也是 public 的。</p><p>接口也是可以继承的，通过继承，可以很容易的在接口中添加新的方法声明，还可以通过继承在接口中组合多个接口，接口的继承仍然使用 <strong>extends</strong> 关键字，其继承的类型也是接口。不过要注意<strong>在不同的接口中使用相同的方法名</strong>会加大阅读代码的难度，尽量避免这种情况发生。</p><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><p>关于接口和抽象类的区别可以看一下这个表：<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB1.jpg" alt="接口和抽象类的区别1"></p><p>接口与抽象类的<strong>共同点</strong>是都不能被实例化，但可以定义引用变量指向实例对象。抽象类在被继承时体现的是 <strong>is-a</strong> 关系，接口在被实现时体现的是 <strong>can-do</strong> 关系。与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方法、属性变量。<strong>如果一个抽象类只有一个抽象方法，那么它就等同于一个接口</strong>。</p><p>使用接口和抽象类是为了防止创建该类的对象，确保别人使用你所设计的类时，仅仅是建立一个API接口，</p><p>如果我们要<strong>创建任何不带方法定义和成员变量的基类</strong>，那么我们就应该选择接口而不是抽象类。当纠结定义接口还是抽象类时，<strong>优先推荐定义为接口</strong>，遵循接口隔离原则，按某个维度划分成多个接口，然后再用抽象类去 implements 某些接口，这样做可方便后续的扩展和重构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>我为何会选择技术之路</title>
    <link href="https://www.shengshiyu.cn/posts/8750774a/"/>
    <id>https://www.shengshiyu.cn/posts/8750774a/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-09-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%88%91%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF.jpg" alt="我为何会选择技术之路"></p><blockquote><p>你会发现，曾经后悔走上的弯路或许是人生的必然曾经那些看似无法改变的路程，都可以彻底调整。我们没有走过弯路，就不会知道什么是直路。</p></blockquote><p>回顾往昔，当初我为何会选择技术这条路，与接触新媒体息息相关，理解了<strong>媒介变化的本质</strong>，就理解了技术在其中所产生的作用。在这个时代，能<strong>推动信息流动</strong>的加快，那么这样的技术是富有<strong>潜力</strong>的，而每一次信息流动的加快在人类的发展史中始终都有着至关重要的作用。同样的信息，过去使用书信往来，现在使用微信互动，<strong>传播的速度</strong>也是大相径庭的。也因为信息流动的加快，使得人与人之间，组织与组织之间因为地理位置差异所造成的隔阂不断<strong>缩小</strong>，我们能更<strong>频繁</strong>的进行贸易的往来，文化的交流等等，媒介就像是催化剂，它不能对事物的变化起决定作用，但它可以推动这个变化的速度，加快频率，那我们就能在同样的时间单位里完成更多的事。</p><p>媒介的发展，亦即<strong>传播速度的加快</strong>，在我看来，不仅仅是<strong>数据传输速度</strong>的加快，还包括<strong>处理的速度</strong>，也就是信息背后所包含的思想是否更容易被吸收和理解。不同媒介的传播速度是不一样的，<strong>文字</strong>作为人类文明承载信息的重要媒介之一，其本身却不是一个出色的媒介，通过文字所记录的信息，难免会在传递的过程中，由于个体的背景差异产生一些<strong>信息的失真</strong>。尤其我们在阅读一本晦涩难懂的书时，很难将作者所要表达的原意通过文字完完整整的解析出来，如果这本书还是翻译的版本，又会在翻译的过程中不可避免的损失一部分信息，全靠译者来把关，如果译者水平有限。。。那就只能听天由命或者直接选择阅读原著了。</p><p>相对于文字来说，人们更容易接受从<strong>图像</strong>中获取信息，而文字最初的产生。如中国古代的象形文字，或是苏美尔人所创的楔形文字，它们雏形的诞生，都多为图像。这也说明我们了解世界最开始某种程度上来说是从图像开始的。如今我们获取信息的渠道更多了，承载信息的主要方式不再以文字记录为主，图片、视频、音频、VR技术等新的形式，它们更多都从<strong>视觉</strong>的接受度上出发，在传播的过程中也更利于被人们接受。</p><p>通过某种方式对信息进行加工，实现信息在传输和理解的“<strong>便利化</strong>”，一定程度上是可以推动信息的流动，但取决于“<strong>加工</strong>”的形式。例如我们可以精炼出一本书的核心要义，将一本书最核心的观点进行<strong>总结和转述</strong>，用便于人们理解的简洁明了的方式进行传播，那么其他人就可以在很短的时间里完成了“<strong>阅读</strong>”一本书的任务。但这个方式更多依赖于那个所谓的“<strong>领读者</strong>”，他不一定能完整的按原作者的思路和逻辑进行转述，而原作者本身是希望你通过阅读他的那本书的过程来完成你和他之间的信息传递。</p><p>当然，我们也可以通过更好的<strong>表述方式</strong>，将原作者希望表达真实意思再现。或许原本他需要用大量的语言和文字来作为铺垫才能表述清楚他的想法，现在你可以用更少的语言和文字实现同同样的目的，或者通过其他方式，例如音视频、图片等等。说不定比文字更利于表达你想要说明的东西。但这样的方式要更困难。这也是为什么除了文字，绘画、音乐等形式能够在历史的长河中熠熠生辉的原因，它们本身也承载着各自不同的文化底蕴，容纳了很多信息在它们所特有的形式之中，需要我们以恰当的方式“<strong>解读</strong>”出来。</p><p>对原有信息的“<strong>精炼</strong>”，将信息量缩减这样的方式，一旦逐渐发展成为了主流，大众便逐渐失去了接受信息后对信息的“<strong>再处理</strong>”的能力，简化信息量，使得用户不用思考便能吸收理解，真的好吗？抖音，今日头条，微信公众号，微博，它们通过不同的交互手段和信息呈现形式，不断地冲刷和改变着人们的意识流。我们的世界观似乎不再是由我们自己来主导，而是由这些新媒介，它们逐渐把控着我们对世界，对人和事物的认知。新媒介的发展不应如此，它的本质应该是使用户接受原有信息的效率更高，通过技术手段实现多样化的表现形式，发掘触觉，听觉，视觉等等方面，根本上的重构信息的展现形式，因为媒介是“<strong>人的延伸</strong>”，而文字并不是一个很好的用来表达思想的媒介，重新唤醒人们接受信息，处理信息的深度思考的能力，这或许是我认为技术终极的追求目标。</p><p>在我看来，“每天听本书”这样类似的形式，将原有体系精炼肢解后，以人们最便于直接理解，最易获得<strong>及时反馈</strong>的形式并不应该成为主流，即使因为工作生活原因，挤不出更多时间阅读思考，也不应该将这个思考过程“<strong>外包</strong>”出去。过程本身对自身思维的训练比直接获得结果更为重要。</p><p>纠结于文字本身，何不将重心往其他媒介上靠拢试试呢？一旦有了一个更为恰当的方式，不是以牺牲个人主动思考的能力为主，它的出现令人们主动地去判断信息的价值，那么它确实具备了促进人类的进步的意义和价值。而技术本身对于实现这样的“新媒介”是有重要意义的，因为不同技术本身也有各自的特性，适用于解决的问题也有所不同，没有最好的，只有最适合的。只要通过技术能实现和解决这些旧有痛点，就是颠覆的可能，创建新的行业形式。</p><p>反之，技术仅仅被用于去提高原有“<strong>错误形式</strong>”的影响力，那么技术始终只是技术。比起实现需求，分析需求背后所带来的价值比单纯的需求更为重要。我为何会选技术之路，因为我希望看到不同技术背后对社会和人的影响，如果它并不能带来积极的影响，促使人和社会的进步，我希望我能发现更好的形式。这一切的基石是技术，需要靠它来实现，也只有自身更懂技术才能更好的实现这一过程。只有这样，技术在我手中才具有了意义，不再限定于程序员本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat学习总结</title>
    <link href="https://www.shengshiyu.cn/posts/9b6e0dfb/"/>
    <id>https://www.shengshiyu.cn/posts/9b6e0dfb/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-09-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Tomcat%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.jpg" alt="Tomcat学习总结"></p><hr><h1 id="关于Tomcat"><a href="#关于Tomcat" class="headerlink" title="关于Tomcat"></a>关于Tomcat</h1><p>本质上Tomcat就是一个程序，由于我们用HTML，CSS写的页面只有我们自己可以访问，Tomcat就是提供了能让别人也可以访问我们页面的程序。</p><p>Tomcat不是一个完整意义上的Jave EE服务器，它甚至都没有提供对哪怕是一个主要Java EE API的实现；但由于遵守apache开源协议，tomcat却又为众多的java应用程序服务器嵌入自己的产品中构建商业的java应用程序服务器，如JBoss和JOnAS。一些开源组件如Structs、Spring和Hibernate，Tomcat都能够对这些组件实现完美的支持。</p><h1 id="Tomcat的目录结构"><a href="#Tomcat的目录结构" class="headerlink" title="Tomcat的目录结构"></a>Tomcat的目录结构</h1><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Tomcat%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931.jpg" alt="Tomcat学习总结1"></p><ul><li><p><strong>backup</strong>: 保存了一些配置文件，是在第一次运行了Tomcat服务器以后产生的。它是对服务器进行简单的备份日志。和conf文件下的内容几乎一样。</p></li><li><p><strong>bin</strong>: 启动和关闭Tomcat脚本文件，很多环境变量也在此处设置。</p></li><li><p><strong>conf</strong>: Tomcat服务器的各种配置文件，其中Catalina子目录下可以设置默认加载的项目。Catalina文件可以设置tomcat服务器内存大小。context.xml可以用来配置数据源之类的东西。logging文件记录tomcat服务器运行的日志记录。server.xml可以设置域名、端口号、IP、请求的编码、默认加载的项目。web.xml可以设置tomcat服务器支持的文件类型。</p></li><li><p><strong>lib</strong>: Tomcat服务器所需要的所有Jar包。</p></li><li><p><strong>logs</strong>: Tomcat的日志文件。</p></li><li><p><strong>temp</strong>: Tomcat运行时的临时文件。</p></li><li><p><strong>webapps</strong>: Tomcat自带的两个web应用：admin和manager，用来管理Tomcat的Web服务。也是tomcat默认部署路径，目录用来存放应用程序，当Tomcat启动时会加载webapps目录下的应用程序。当然可以以war包、Jar包、普通文件夹三种形式发布应用。你也可以把应用程序存放在电脑磁盘的任意一个位置，但是在配置文件中要配置好，使其映射好。</p></li><li><p><strong>work</strong>: JSP经过Tomcat编译后生成的Servlet。</p></li><li><p><strong>wtpwebapps</strong>: 和webapps功能差不多，但是它是eclipse默认的部署路径。与webapps同时存在时，默认选择wtpwebapps。</p></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Tomcat的配置文件在conf目录下，其中：</p><ul><li><p><strong>catalina.policy</strong>：Java相关的安全策略配置文件，在系统资源级别上提供访问控制的能力</p></li><li><p><strong>catalina.properties</strong>：Tomcat内部package的定义及访问相关的控制，也包括对通过类装载器装载的内容的控制</p></li><li><p><strong>context.xml</strong>：所有host的默认配置信息</p></li><li><p><strong>jaspic-providers.xml</strong>：tomcat 实现了 JASPIC 1.1   Maintenance Release B 标准，并通过这个配置文件集成第三方 JASPIC 身份验证</p></li><li><p><strong>jaspic-providers.xsd</strong>：定义了 jaspic-providers.xml 所使用到的标签</p></li><li><p><strong>logging.properties</strong>: 日志记录器相关的配置信息，可以用来定义日志记录的组件级别以及日志文件的存在位置等</p></li><li><p><strong>server.xml</strong>: Tomcat的主配置文件，包含Service, Connector, Engine, Realm, Valve, Hosts主组件的相关配置信息</p></li><li><p><strong>tomcat-user.xml</strong>：Realm认证时用到的相关角色、用户和密码等信息；Tomcat自带的manager默认情况下会用到此文件；在Tomcat中添加/删除用户，为用户指定角色等将通过编辑此文件实现</p></li><li><p><strong>tomcat-users.xsd</strong>：定义了 tomcat-users.xml 所使用到的标签</p></li><li><p><strong>web.xml</strong>：遵循Servlet规范标准的配置文件，用于配置servlet，并为所有的Web应用程序提供包括MIME映射等默认配置信息</p></li></ul>]]></content>
    
    <summary type="html">
    
      Tomcat是一个免费的开源的Serlvet容器，Tomcat能够动态的生成资源并返回到客户端，简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序。
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java泛型</title>
    <link href="https://www.shengshiyu.cn/posts/7ca0722f/"/>
    <id>https://www.shengshiyu.cn/posts/7ca0722f/</id>
    <published>2018-09-18T16:00:00.000Z</published>
    <updated>2018-09-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%B5%85%E6%9E%90Java%E6%B3%9B%E5%9E%8B.jpg" alt="浅析Java泛型"></p><p>泛型的本质是类型参数化，解决不确定具体对象类型的问题。泛型可以定义在类、接口、方法中，编译器通过识别尖括号和尖括号内的字母来解析泛型。</p><p>与C++根据模板类生成不同的类的方式不同，Java使用的是类型擦除的方式。不过了解C++模板有助于你理解Java泛型的机制，理解它的局限是什么以及Java泛型的边界。</p><h1 id="关于泛型"><a href="#关于泛型" class="headerlink" title="关于泛型"></a>关于泛型</h1><p>泛型是接口概念的延伸，我们通过泛型可以为<strong>类</strong>、<strong>接口</strong>、<strong>方法</strong>应用更为广泛的类型，使得操作的数据不再和代码绑定在一起，不仅可以<strong>复用代码、降低耦合度，还可以提高代码的可读性和安全性</strong>。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>一个简单的泛型类是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">T first;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T first)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相对于普通类而言，类名的后面多了一对尖括号，和一个字母<code>T</code>，这个<code>T</code>表示的就是<strong>类型参数</strong>，<strong>泛型就是类型参数化，处理的数据并不是固定的，而是可以作为参数传入</strong>。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p>在定义泛型时，一些常见的类型参数表示：</p><ul><li><code>E</code>代表 Element ，用于集合中的元素</li><li><code>T</code>代表 the Type of object ，表示某个类</li><li><code>K</code>代表 Key、 <code>V</code>代表 Value ，用于键值对元素</li></ul><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>方法也可以使用泛型，而且泛型方法并不需要其所在的类一定要是泛型类，一个简单的泛型方法大概是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; getData(T t) &#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型方法使得该方法可以<strong>独立于类</strong>产生变化，如果使用泛型方法可以取代将整个类泛型化，那就应该使用泛型方法。</p><p>对于 static 方法而言，它<strong>无法访问泛型类的类型参数</strong>，除非把它定义为泛型方法，才可以具有使用泛型的能力。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同，举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当实现泛型接口时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><p>Java泛型是使用<strong>擦除</strong>来实现的，这意味着当你使用泛型时，任何具体的类型信息都要被擦除，你唯一知道的只是你在使用一个对象。擦除机制可以在不破坏现有类库的情况下，将泛型融入Java语言，使得非泛型的代码能够在不改变的情况下继续使用。</p><p>编译器编译后，Java的源代码变为了.class文件，虚拟机再加载这个文件运行。对于泛型类，Java虚拟机会把泛型代码转化为非泛型的普通代码，将类型参数“擦除”，替换为Object，再进行必要的强制类型转化。泛型就是在编译期增加了一道检查而己，目的是促使程序员在使用泛型时安全放置和使用数据。</p><p>不过要注意，擦除机制的存在会使<strong>重载</strong>方法产生相同的类型签名，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，<strong>当擦除后因为参数问题导致相同的参数列表，要提供不同的方法名</strong>。</p><h1 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h1><p>可能你会疑惑，既然泛型最后也会转化为普通的类，那我们使用泛型的目的是什么？其实泛型的好处包括：</p><ul><li><strong>类型安全</strong>：放置的是什么，取出来的自然是什么，不用担心会抛出 ClassCastException 异常</li><li><strong>提升可读性</strong>：从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么</li><li><strong>代码复用</strong>：泛型合并了同类型的处理代码，使代码复用度变高</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一本技术类书籍</title>
    <link href="https://www.shengshiyu.cn/posts/59cc6e2d/"/>
    <id>https://www.shengshiyu.cn/posts/59cc6e2d/</id>
    <published>2018-09-16T16:00:00.000Z</published>
    <updated>2018-09-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%B1%BB%E4%B9%A6%E7%B1%8D.jpg" alt="如何阅读一本技术类书籍"></p><p>前不久重读了《如何阅读一本书》，这本书成书时并没有计算机相关的读物，在介绍阅读不同读物的方法时，我认为技术类的书籍可能更接近于它里面所提到的科学与数学，而且更多偏实用型而非理论型，并且计算机一类的阐述特定技术的书时新性很强，随着技术的更新换代，很多都会过时，这一点在其他一类的书上没那么明显，一旦过时，其实用性就会大大下降，这里结合我的认知，谈一下关于技术类书籍应该如何阅读。</p><p>这里指的阅读，并非<strong>粗读</strong>或是<strong>泛读</strong>，虽然很多技术类的书也可以作为手册，需要的时候再进行查阅即可，但也不乏很多经典，它们需要我们细细品读，结合实践会不断提高我们的技术水平。这里总结了一些值得参考的书：<a href="https://www.douban.com/doulist/110527931/" target="_blank" rel="noopener">每一个程序员都值得读的经典</a></p><p>首先我们明确它是否属于<strong>论说类</strong>的书籍，其次我们要分析这本书是否属于<em>*理论性</em>的，类似《算法导论》一类的书，还是属于实用性的，类似《effective java》这样的书。</p><p>然后我们可以用几句话<strong>简单的叙述</strong>一下这本书主要讲了啥，将书里面重要的章节<strong>列举</strong>出来，说明它是如何根据某种逻辑来组成一个相应<strong>体系</strong>的，进而能够用来<strong>解决实际问题</strong>。关注作者希望通过这本书来为我们解决一个什么样的具体问题，这个问题属于哪一类别。因为计算机体系的模块化，抽象化和层次化，所以不同的书针对的方向和层次也是不一样的。</p><p>然后我们要关注一些重要的名词，看是否在翻译的版本中所要表达的东西是你印象里熟悉的那一个概念，然后我们要关注一些核心重要的部分，因为技术类的书具有很<strong>完整的逻辑</strong>，我们要对这些重要且难以理解的部分去理顺逻辑，看作者是如何逐步叙述他所要表达的内容的。如果是因为欠缺了某一部分的内容，造成了阅读过程中理解的困难，如果你觉得跳过，并不影响后续阅读，而且它并不属于这本书的核心内容，或是所描述的技术类别已经过时了，那么你可以先跳过。反之，我们可能需要花一些时间去了解一下那些与此相关的我们所不懂的概念，然后再尝试回过头阅读，看逻辑是否通畅，是否能继续读下去。当然这个过程最好的方式就是<strong>多实践</strong>，将其中的一些能够实现的东西，自己尝试做一下，可能很多不理解的东西就理解了。</p><p>在你对作者的一些实践方法作出评价之前，你最好已经明白了它的所有细节，你知道作者想要以此解决的问题，并且你也<strong>亲自实现</strong>过，然后你才可以对所谓的“<strong>最佳实践</strong>”作出评判；因为有的“最佳实践”所针对的只是那个特定的历史时期。然后你就可以通过类比得出适合自己的技术实践方式，不断地去更新这些“最佳实践”，可以使你的开发效率和代码质量不断提高。</p><p><strong>尊重书中作者和你个人观点的不同</strong>，通过实践来证明，是否作者是针对某一特定的环境，而不是普遍的情况，寻找各自的理论基础作为支撑，另外技术类的书更新换代很快，我们在看一些经典“老书”时，要学会判断哪些观点和看法是过时了的，哪些是真知灼见，去<strong>吸收那些依然有用的思想洞见</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>PO、VO、BO、DTO、POJO、DAO之间的关系</title>
    <link href="https://www.shengshiyu.cn/posts/a24ff975/"/>
    <id>https://www.shengshiyu.cn/posts/a24ff975/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2018-09-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="PO（persistant-object持久对象）"><a href="#PO（persistant-object持久对象）" class="headerlink" title="PO（persistant object持久对象）"></a>PO（persistant object持久对象）</h1><p><strong>PO</strong> 就是数据库中的一条记录，只是把一条记录作为一个对象处理，可以方便的转化为其他对象。有时也被称为<strong>Data对象</strong>，对应数据库中的 entity 。PO中不应该包含任何对数据库的操作。PO是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。PO有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。PO的属性是跟数据库表的字段一一对应的</p><h1 id="VO（value-object值对象-view-object表现层对象"><a href="#VO（value-object值对象-view-object表现层对象" class="headerlink" title="VO（value object值对象/view object表现层对象)"></a>VO（value object值对象/view object表现层对象)</h1><p>主要<strong>对应界面显示的数据对象</strong>,可以和表对应，也可以不，这根据业务的需要。VO是用new关键字创建，由GC回收。存活在业务层，是业务逻辑使用的，他存活的的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。</p><p>一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！不过，另外一点，如果我们没有使用数据持久层，那么PO和VO也可以是同一个东西，但这并不好。</p><h1 id="BO-business-object业务对象"><a href="#BO-business-object业务对象" class="headerlink" title="BO(business object业务对象)"></a>BO(business object业务对象)</h1><p>主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。它只包含业务对象的属性或是方法，或者二者都包含。</p><h1 id="DTO（Data-Transfer-Object数据传输对象）"><a href="#DTO（Data-Transfer-Object数据传输对象）" class="headerlink" title="DTO（Data Transfer Object数据传输对象）"></a>DTO（Data Transfer Object数据传输对象）</h1><p>主要用于远程调用等需要大量传输对象的地方</p><h1 id="POJO（plain-ordinary-java-object-简单Java对象）"><a href="#POJO（plain-ordinary-java-object-简单Java对象）" class="headerlink" title="POJO（plain ordinary java object 简单Java对象）"></a>POJO（plain ordinary java object 简单Java对象）</h1><p>一个最常见的的对象了，只有属性字段及setter和getter方法,属于一个中间对象，可以转化为PO、DTO、VO，一个POJO持久化之后就是PO；POJO在传输过程中，就会转化为DTP，这个传输过程就是DTO；POJO用作表示层就是VO</p><h1 id="DAO（data-access-object数据访问对象）"><a href="#DAO（data-access-object数据访问对象）" class="headerlink" title="DAO（data access object数据访问对象）"></a>DAO（data access object数据访问对象）</h1><p>学习数据库时遇到最多的对象了，它负责持久层的操作,主要用来封装对数据库的访问，提供数据库的CRUD操作.通过他可以把POJO持久化为PO，</p>]]></content>
    
    <summary type="html">
    
      关于PO、VO、BO、DTO、POJO、DAO，这几个是我们在开发中经常遇到的专业术语缩略词，这里专门总结下它们各自之间所代表的意思以及区别
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类的理解</title>
    <link href="https://www.shengshiyu.cn/posts/f7cd9195/"/>
    <id>https://www.shengshiyu.cn/posts/f7cd9195/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2018-09-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Java%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3.jpg" alt="Java内部类的理解"></p><p>内部类是一个很实用的特性，可以将一个类定义在另一个类的内部，这就是内部类。内部类自动拥有对外部类成员的所有成员的访问权。可以将其看作一种有效的代码隐藏机制。</p><h1 id="内部类的本质"><a href="#内部类的本质" class="headerlink" title="内部类的本质"></a>内部类的本质</h1><p>对Java虚拟机而言，内部类只是Java编译器的概念，他并不知道内部类是什么，因为<strong>每个内部类最终都会被编译为一个独立的类</strong>。每一个内部类都可以替换为一个独立的类，就单纯的技术实现而言。<strong>内部类可以方便的访问外部类的私有变量</strong>，也可以通过 private 或是 protected 关键字，将内部类的实现<strong>对外完全隐藏</strong>，而一般的类只具有public和默认包访问权限。</p><p>如果在内部类里要生成对外部对象的引用，可以使用“<strong>外部类.this</strong>”，当我们要创建内部类的对象时与平时创建新对象略有不同，需要这样创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass oc = <span class="keyword">new</span> OutClass();</span><br><span class="line">OutClass.InnerClass oi = oc.new InnerClass();</span><br></pre></td></tr></table></figure></p><p>每个内部类都能<strong>独立的继承一个接口的实现</strong>，不会因为外部类已经实现了某个接口而影响内部类。而且内部类允许继承多个类或抽象类，内部类使得Java的“多重继承”变得更为完整。</p><p>内部类可以有<strong>多个实例</strong>，每个实例都可以有自己的状态，并且和外部类对象相互独立。我们可以在一个外部类中，利用内部类以不同的方式实现同一个接口，或继承同一个类。内部类和外部类之间并不存在“ <strong>is-a</strong> ”的关系，是独立的实体。内部类很像“<strong>闭包</strong>”，它具有很多和闭包接近的功能特征，如果你理解闭包，那么更有助于你理解内部类的一些思想。</p><h1 id="内部类的划分"><a href="#内部类的划分" class="headerlink" title="内部类的划分"></a>内部类的划分</h1><p>根据位置和方式的不同，主要有四种内部类</p><ul><li><strong>静态内部类</strong></li><li><strong>成员内部类</strong></li><li><strong>局部内部类</strong></li><li><strong>匿名内部类</strong></li></ul><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类有时也被称作嵌套类，静态内部类和静态方法或者静态代码块一样，都需要 <strong>static</strong> 关键字修饰，一个典型的静态内部类是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    String name1 = <span class="string">"Tom"</span>;</span><br><span class="line">    Static String name2 = <span class="string">"King"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">    Static String name3 = <span class="string">"Oliver"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name2);</span><br><span class="line">        System.out.println(name3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>非静态内部类是不能定义静态成员</strong>的，同时外部类的静态成员才可以直接使用静态内部类，对于静态内部类来说，也不能访问外部类的实例成员。</p><p><strong>静态内部类不能通过“外部类.this”引用外部类的对象</strong>，因为它并不存在 this 引用。</p><p>静态内部类可以在接口中使用，它也会自动的变为 <strong>public static</strong>，所以放在接口中的类是静态内部类，只是看上去没有public static，会以为是成员内部类。甚至我们可以在内部类中实现它的外围接口，但对于Java虚拟机来说，内部类最终还是会被看作一个独立的类，而在独立的类中实现接口并不矛盾。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义包内可见静态内部类的方式很常见，这样做的好处是</p><ul><li><strong>作用域不会扩散到包外</strong>。</li><li><strong>可以通过”外部类.内部类”的方式直接访问</strong>。</li><li><strong>内部类可以访问外部类申的所有静态属性和方法</strong>。</li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类也叫实例内部类，它作为外部类的一个成员存在，与外部类的属性和方法并列，成员内部类持有外部类的引用,只不过这个引用是隐式保存的，指向创建它的外部对象，成员内部类也是最常见的内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类也叫作方法内部类，它定义在外部类的方法中，局部内部类只在该<strong>方法</strong>中才能使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果内部类对象仅仅为外部类的某个方法使用，使用局部内部类，但要注意不能使用 private、protected、public 权限修饰符，因为它不是外部类的一部分，也不能包含静态成员，但它<strong>可以访问当前代码块内的常量和外部类的所有成员</strong>。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制，因为有时候有的内部类<strong>只需要创建一个它的对象</strong>就可以了，以后再不会用到这个类，这时候使用匿名内部类就比较合适。</p><p>匿名内部类使用<code>new</code>创建，没有具体位置，<strong>默认继承或实现new后面的类型</strong>。匿名内部类编译后生成的.class文件的命名方式是”<strong>外部类名称$数字.class</strong>”，数字为1，2，3…n，数字为x的文件对应的就是第x个匿名类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类末位的分号，并不是表示内部类结束，而是表示<strong>表达式的结束</strong>，只不过这个表达式正好包含了匿名内部类。</p><p>如果你需要在匿名内部类中使用一个外部类定义的对象，那么它的参数需要有 <strong>final</strong> 修饰才能通过编译，因为没有名字，所以也没有显式的构造器可以创建使用。</p><p>匿名内部类可以扩展类也可以用来实现接口，但不能二者兼备，而且对于接口来说，也只能实现一个接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vector、ArrayList、LinkedList的区别</title>
    <link href="https://www.shengshiyu.cn/posts/73a15e6/"/>
    <id>https://www.shengshiyu.cn/posts/73a15e6/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2018-09-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Vector%E3%80%81ArrayList%E3%80%81LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="Vector、ArrayList、LinkedList的区别"></p><h1 id="关于Vector、ArrayList、LinkedList"><a href="#关于Vector、ArrayList、LinkedList" class="headerlink" title="关于Vector、ArrayList、LinkedList"></a>关于Vector、ArrayList、LinkedList</h1><p>Java 提供了许多容器类型用以保存对象，合理使用它们可以大大提高开发效率。但不同的容器类型之间也存在着相似和不同，例如：Vector、ArrayList、LinkedList之间具体的区别是什么？</p><p>Vector、ArrayList、LinkedList 都是通过集合框架的<strong>List</strong>实现的，所以在一些功能上十分相似，比如可以通过提供具体的位置进行定位，添加或是删除的操作，都提供了迭代器可以进行内容的遍历，但因为内部设计的差异，在行为、性能和多线程上又有差异。</p><p>ArrayList 是可以改变的<strong>线程不安全</strong>的集合类型。也因为它是线程不安全的所以它的性能要好很多。内部存储使用的是<strong>动态数组</strong>进行存储，集合扩容时会自动创建更大的数组空间，把原有数据复制到新数组中。 ArrayList 支持对元素的<strong>快速随机访问</strong>，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动其他元素。</p><p>Vector 是 Java 早期提供的<strong>线程安全</strong>的动态数组，它的内部使用对象数组保存数据，可以需要自动增加容量，当数组空间到达上限时，会创建新的数组，将原数据“复制——移动”到新数组。</p><p>Vector和ArrayList作为动态数组，它内部的元素都是<strong>顺序存储的</strong>，很适合需要随机访问的场合，除非我们是在尾部插入删除元素，不然对于随机插入删除元素，需要移动后续所有元素，性能会差很多。实际开发过程，要事先估计应用的操作更偏向插入删除还是随机访问，</p><p>LinkedList其实就是<strong>双向链表</strong>，其中的<strong>每个对象包含数据的同时还包含指向链表中前一个和后一个元素的引用</strong>。它也不用像Vector、ArrayList一样调整容量大小，它也不是线程安全的。与ArrayList相比，LinkedList进行节点<strong>插入和删除速度效率更高</strong>，但是随机访问速度很慢。</p><h1 id="关于集合框架"><a href="#关于集合框架" class="headerlink" title="关于集合框架"></a>关于集合框架</h1><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/Vector%E3%80%81ArrayList%E3%80%81LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB1.png" alt="Vector、ArrayList、LinkedList的区别"></p><p>在Java的集合类里，Collection 接口是所有集合的根节点。它也衍生出了三种类型的集合，分别是 List、Set、Queue。</p><p>List 前面已经说了，它提供<strong>随机访问以及插入删除</strong>的操作，在随机访问效率上更出色。而Set类型不允许出现重复的元素，保证元素的唯一性，很多场合也会需要用到它的这个特性。</p><p>如果我们使用的是<strong>固定数量</strong>的元素，那么既可以选择使用 List ，也可以选择真正的<strong>数组</strong>，尽管通常来说首选的会是ArrayList，但这种弹性需要开销，而数组的效率要比ArrayList高。而且数组可以持有基本类型，而泛型之前的容器类型则不能。</p><p>Queue 是 Java 提供的队列结构的实现类型，除了基本的增删改查操作，它还提供 <strong>FIFO</strong> （先进先出）、<strong>LIFO</strong>（后进先出）的行为支持。</p><p>每一种具体的集合类型都会被抽象到相应的抽象类中，如 AbstractList、AbstractSet、AbstractQueue ，它们又进一步抽象到 AbstractCollection 类中，实现了接口和实现的分离和结构化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
</feed>

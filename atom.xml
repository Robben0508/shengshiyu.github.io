<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天马的故乡</title>
  <icon>https://www.gravatar.com/avatar/af826c880117989a83a2457623c21a52</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shengshiyu.cn/"/>
  <updated>2018-01-14T16:00:00.000Z</updated>
  <id>https://www.shengshiyu.cn/</id>
  
  <author>
    <name>沉默的超云星</name>
    <email>shengshiyu0508@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文化与媒介</title>
    <link href="https://www.shengshiyu.cn/2019/01/15/%E6%96%87%E5%8C%96%E4%B8%8E%E5%AA%92%E4%BB%8B/"/>
    <id>https://www.shengshiyu.cn/2019/01/15/文化与媒介/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2018-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Spring Bean的生命周期和作用域</title>
    <link href="https://www.shengshiyu.cn/2019/01/02/%E6%B5%85%E8%B0%88Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://www.shengshiyu.cn/2019/01/02/浅谈Spring Bean的生命周期和作用域/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-01-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP浅析</title>
    <link href="https://www.shengshiyu.cn/2018/12/26/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%90/"/>
    <id>https://www.shengshiyu.cn/2018/12/26/TCP和UDP浅析/</id>
    <published>2018-12-25T16:00:00.000Z</published>
    <updated>2018-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%90.jpg" alt="TCP和UDP浅析"></p><h1 id="关于UDP你需要知道"><a href="#关于UDP你需要知道" class="headerlink" title="关于UDP你需要知道"></a>关于UDP你需要知道</h1><p>UDP继承了IP包的特性，不保证不丢失，不保证顺序到达，它只管发出去，打个比方，它就像懵懂无知的小孩，它认为只要是发出去的东西，很容易就能送达，不会丢包。而且它<strong>不会建立连接，它也不会进行拥塞控制</strong>，只管往外发就行，一根筋。</p><p>虽然UDP报文<strong>没有可靠性保证</strong>、<strong>顺序保证和拥塞控制</strong>，<strong>可靠性较差</strong>。但也正因为如此，UDP协议的控制选项较少，在数据传输过程中<strong>延迟小</strong>、<strong>数据传输效率高</strong>，适合对可靠性要求不高的应用程序，需要处理速度快，时延低，可以容忍少数丢包，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。</p><p>在网络质量很差的环境下，UDP协议数据包丢失会比较严重。但是由于它传输过程中资源消耗小，处理速度快，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包到达的消息及时反馈回来，那么网络就是通的。在默认状态下，一次“ping”操作发送4个数据包，对方主机发回的确认收到的数据包也是4包，这充分说明了UDP协议是<strong>面向非连接</strong>的协议，没有建立连接的过程。</p><p>UDP协议使用报头中的校验值来保证数据的安全。校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。如果某个数据包在传输过程中被篡改或者损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测出是否出错。</p><h1 id="关于TCP你需要知道"><a href="#关于TCP你需要知道" class="headerlink" title="关于TCP你需要知道"></a>关于TCP你需要知道</h1><p>TCP是<strong>基于连接</strong>的协议，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来，也因为多了这样一个过程，TCP要比UDP复杂很多，可以看一下TCP头的格式。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%901.jpg" alt="TCP和UDP浅析1"></p><p>TCP的包是没有IP地址的，那是IP层上的事。可以对比看出，相对于UDP来说，TCP多了一个<strong>序号</strong>，这个序号的作用是为了给发送的包标号，<strong>防止乱序</strong>，这样我们好知道哪一个应该先来，哪一个后来，做到有理有序。</p><p>其次，它还具有一个<strong>滑动窗口</strong>，我们可以理解为这就是一个管道的大小，越大自然水的流速流量可以更大，越小自然流速就会变小，流量变少，TCP也一样，窗口的大小就是为了能够控制流量的，通过标识窗口大小，就可以知道对方的处理能力，而不会发送过快了，造成拥塞问题，用于<strong>解决流控</strong>的。</p><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>TCP连接的建立，我们通常称为“三次握手”，打个比方，大概就是这样：<br><strong>A：你好，我是A，想和你连接<br>B：你好A，我是B，我收到你提出的连接请求了<br>A：好的B，收到了</strong></p><p>为啥一定要是三次呢？不是两次或者四次，当A发起一个连接是，如果B没有回复，它又如何知道B收到了呢，它会以为包丢了，或者超时未达，又或者B压根不想和它连接，它会很懵逼，以至于可能再发。</p><p>当B收到了请求包，就知道了A的存在，也知道A想和它连接，而且它要是不回复，A会继续重试“骚扰”它一阵子，直到A自己放弃，建立连接失败。如果B愿意连接，OK，立马发个应答包过去，告诉A，我同意和你连接了。</p><p>但是，这个过程一样会遇到种种未知错误，比如这个应答包丢了。。。那A不知道啊，继续“骚扰”。。。所以B为了不受其烦，肯定要为了确保应答到达，不断尝试重发，只要一次到达，它就解脱了。至于怎么确认到达，当然是等A收到了应答包，然后欢呼雀跃的再发送一个应答包，表示”收到了，我们连接吧！“不过你可能会觉得，那我们也要确定A这个应答包到达B啊，不然B咋知道A收到他第二次握手发的包，难道不应该四次握手吗？<br>其实四次握手也是可以的，几十上百次都OK，但那也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了。</p><p>A当然可以建立连接后空闲着，就是不“搭理”B，对于B来说，对于A这种“占着茅坑不拉屎”的行为，自然可以选择主动关闭，从而把空出的资源给其他客户端使用。</p><p>TCP里的序号在“三次握手”中，可以很有效的解决丢包问题，当它俩连接后，A发送了很多个有序排列的包，但中途可能由于种种未知原因，丢了一个，A不知道，但B知道A发的包的总数，它一数，好像差了一个，然后再告诉A。而且这个序号的起始序号是随时间变化的，不会重复，为了防止某些包绕路，等到了其实已经无用了，所以IP包头里有个TTL，也就是生存时间。</p><p>这里有个<strong>时序图</strong>，可以看一下，而且TCP头里还有一些<strong>状态位</strong>，其中<strong>SYN</strong>表示发起一个连接，<strong>ACK</strong>表示回复，<strong>RST</strong>表示重新连接，<strong>FIN</strong>表示结束连接，这样这个时序图就好理解了。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%902.jpg" alt="TCP和UDP浅析2"></p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>嗯，说散就散，说完了连接，该说下“四次挥手”了，它大概是这样的：<br><strong>A：我们分手吧<br>B: 哦，你想分了啊，那好吧，知道了。。。</strong></p><p>这个时候，只是A想分手离开了，也就是A不再发送数据，那B能不能在ACK的时候直接选择关闭呢，反正A都要分了，自然是不行的，因为A可能是发完了最后的数据就准备分手了，但是B还没做完它的事情，还是可以发送数据的，处在一种半关闭状态，这个时候A可以选择不再接受数据，也可以选择最后再接受一段数据，等待B也主动关闭。于是就有了：<br><strong>B： OK，那我不陪你了，再见<br>A： 嗯，再见</strong></p><p>然后整个连接就关闭了，但是上面是一种理想情况下的分手，可能会遇到很多异常情况，例如，A说完分手后，直接走了，B不知道，B发的回复A就收不到了，B会陷入不知所措。也有可能是B说完分手后，他倒是处于半关闭的还在着，B直接生气走了，A也会陷入两难抉择，究竟B是还有事没处理完，还是一会就关闭了，针对这一系列问题，我们来看断开连接时候的时序图。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%903.jpg" alt="TCP和UDP浅析3"></p><p>从图中我们可以看到，当A说分手了，就进入<strong>FIN_WAIT_1</strong>的状态，可以理解为等待结束第一阶段，而B回复完A后也相应进入<strong>CLOSE_WAIT</strong>状态，理解为等待关闭。A收到B的回复，就进入了<strong>FIN_WAIT_2</strong>状态，如果此时B直接离开了，那A就一直保持在这个状态。如果B没有离开，主动地又说“再见”，然后它就进入了<strong>LSAT_ASK</strong>状态，然后A收到了B说得“再见”他也发送响应，“嗯，再见”然后进入了<strong>TIME_WAIT</strong>状态，当B收到A的ASK就会关闭了。而假如这个ASK没有到达，因为只有到达B才会进入关闭，但A已经进入关闭倒计时了，它会保持在这个状态一段时间，然后自动的关闭了，所以这段时间里，B会不断地发送“再见”，直到收到一条A的ASK为止。</p><p>假如B在A的最后这段“停留期”，还是没有等来一个回复，虽然它还是会发，当A收到这个后，就会直接回复一个<strong>RST</strong>，B就知道A跑了，就不再发“再见”了。</p><h2 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h2><p>其实就是将TCP连接和分手的两个时序图结合起来，就是表面看起来高大上的<strong>TCP状态机</strong>了。网络上的传输是没有连接的，包括TCP也是一样的，所谓的连接不过是通讯的双方维护的一个“<strong>连接状态</strong>”<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/TCP%E5%92%8CUDP%E6%B5%85%E6%9E%904.jpg" alt="TCP和UDP浅析4"></p>]]></content>
    
    <summary type="html">
    
      传输层里比较重要的两个协议，一个是TCP，一个就是UDP了，而且这两个协议往往放在一起来讲，那么它们之间具体的区别又是啥，又有什么联系呢？TCP的状态机又是什么？
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="TCP" scheme="https://www.shengshiyu.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>谈谈大众传媒</title>
    <link href="https://www.shengshiyu.cn/2018/12/13/%E8%B0%88%E8%B0%88%E5%A4%A7%E4%BC%97%E4%BC%A0%E5%AA%92/"/>
    <id>https://www.shengshiyu.cn/2018/12/13/谈谈大众传媒/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>新思想和旧思想</title>
    <link href="https://www.shengshiyu.cn/2018/12/03/%E6%96%B0%E6%80%9D%E6%83%B3%E5%92%8C%E6%97%A7%E6%80%9D%E6%83%B3/"/>
    <id>https://www.shengshiyu.cn/2018/12/03/新思想和旧思想/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2018-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>PO、VO、BO、DTO、POJO、DAO之间的关系</title>
    <link href="https://www.shengshiyu.cn/2018/11/22/PO%E3%80%81VO%E3%80%81BO%E3%80%81DTO%E3%80%81POJO%E3%80%81DAO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://www.shengshiyu.cn/2018/11/22/PO、VO、BO、DTO、POJO、DAO之间的关系/</id>
    <published>2018-11-21T16:00:00.000Z</published>
    <updated>2018-11-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>谈谈产品需求分析</title>
    <link href="https://www.shengshiyu.cn/2018/11/07/%E8%B0%88%E8%B0%88%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>https://www.shengshiyu.cn/2018/11/07/谈谈产品需求分析/</id>
    <published>2018-11-06T16:00:00.000Z</published>
    <updated>2018-11-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java线程池</title>
    <link href="https://www.shengshiyu.cn/2018/11/01/%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://www.shengshiyu.cn/2018/11/01/浅谈Java线程池/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-10-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP指北</title>
    <link href="https://www.shengshiyu.cn/2018/10/24/HTTP%E6%8C%87%E5%8C%97/"/>
    <id>https://www.shengshiyu.cn/2018/10/24/HTTP指北/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTP%E6%8C%87%E5%8C%971.jpg" alt="HTTP指北1"></p><h1 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h1><p>HTTP是应用层的协议，当我们打开一个网页时，例如：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>,浏览器会将这个域名地址发送给DNS服务器，然后解析为具体的IP地址。</p><p>建立好连接后，浏览器就可以发送HTTP的请求了，而一个完整的HTTP请求报文由三部分组成：<strong>请求行</strong>、<strong>请求头（首部）</strong>、<strong>请求体（实体）</strong>。每一行的末尾都有回车和换行，在请求体和请求头之间另起一行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是以key:value这样的键值对的形式存在的，请求体就是要传输的数据。<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTP%E6%8C%87%E5%8C%972.jpg" alt="HTTP指北2"></p><p>HTTP里有很多请求方法，其中最常用的就那么几个，对于访问网页来说，使用的最多的就是<strong>GET</strong>方法，用来向服务器端获取一些资源，具体返回什么，由服务端来决定。</p><p>另一个常用的请求方法类型是<strong>POST</strong>，它需要你主动告诉服务端一些信息，一般这些信息放在请求体里，与GET不同，POST更多是用来更新资源信息，GET提交请求的数据实体是放在URL后面，用?来分割，参数用&amp;连接，而且数据长度是有限制的，视具体的客户端而定，而POST没有限制，而且GET提交的数据是不安全的，因为相关参数会暴露在URL上。</p><p>还有一种类型，叫做<strong>PUT</strong>，它的作用是向指定资源位置上传最新内容，类似于FTP协议，文件内容包含在请求体里，不过HTTP服务器一般是不允许上传文件的，所以PUT和POST就都变成了要传给服务器内容的方法。</p><p>最后一种比较常见的方法就是<strong>DELETE</strong>，主要就是用来删除文件，是与PUT相反的方法，DELETE是要求返回URL指定的资源。</p><p>请求行的下面就是请求头了，保存了一些很重要的字段，例如, <strong>Content-Type</strong> 是指正文格式，如果是JSON格式的，就要把值设为JSON，而类似 <strong>Accept-Charset</strong> 则表示客户端可以接受的字符集，避免不必要的乱码。首部字段有很多，其实通过名字我们就能大概它的用法的，用到的时候可以想了解细节再去查。</p><p>当我们使用HTTP发送请求时，由于它是基于<strong>TCP</strong>协议，所以它使用面向连接的方式发送请求，在发送每段报文时，都需要对方回应一个ACK，确认已经到达，如果没有收到对方的回复，TCP就会重新进行传输，直到到达为止，而这个过程是TCP负责的，也就是说无论重新传输了几次，对于HTTP来说它只进行了一次传输，由TCP来完成这个送达的过程。</p><p>TCP每发送一个报文都会加上自己本身所在的地址以及它想要到达的另一端的位置，将它们放在IP头里，然后交给IP层进行传输。IP层会查看目标地址和自己所在的地址是否同在一个局域网里，如果在的话就发送ARP协议，获取目标地址的MAC地址，然后把自己的MAC地址和目标MAC地址放到MAC头发送出去，由另一端来进行层层对比确认，然后发送一个ACK，确认到达。如果不在一个局域网里，就要经过网关，而MAC头里放的就是网关的地址，因为我们不知道目标的MAC地址，网关再根据路由协议来获取下一跳的路由器MAC地址，然后加入到目标MAC地址那，由于还不是真正的目标MAC地址，会不断重复这个“寻找”的过程，直到下一跳是目标所在，然后获取到目标的MAC地址。</p><p>在TCP头里还有端口号，通过确认MAC地址，IP地址后，通过端口号，目标机器就会知道哪一个进程需要这个包，然后发送给那个进程，例如HTTP服务器，然后HTTP服务器就知道请求的资源是什么，然后把相关资源发送给客户端。</p><p>HTTP的返回报文和响应报文类似，简单来说响应报文由<strong>状态行</strong>、<strong>响应头（首部）</strong>、<strong>响应体（实体）</strong>组成，其中第一行是状态行，包含HTTP版本，状态码和状态短语，在一个回车换行之后是响应头，也是以键值对的形式，之后是响应体，也就是要传输的数据。</p><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTP%E6%8C%87%E5%8C%973.jpg" alt="HTTTP指北3"></p><h1 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h1><ul><li><strong>HTTP协议是无状态的</strong><br>什么是无状态，就是协议对于事务处理没有记忆能力，对于同一个URL请求没有上下文的联系，每一次的请求都是独立的，不会受前后结果的差异影响响应，但为了使它具有状态的特点，于是引入了 cookis 和 session 机制。</li><li><strong>基于TCP协议</strong><br>HTTP协议属于应用层，它的目的是规定客户端和服务端数据传输的格式和数据交互行为，而数据传输的实现，它是基于传输层TCP协议实现的，它本身并不能进行数据传输。</li></ul><h1 id="HTTP的响应状态码"><a href="#HTTP的响应状态码" class="headerlink" title="HTTP的响应状态码"></a>HTTP的响应状态码</h1><p>状态码是用来告知客户端服务器端处理请求的结果。凭借状态码用户可以知道服务器是请求处理成功、失败或者是被转发；这样出现了错误也好定位。状态码是由3位数字加原因短语组成。3位数字中的第一位是用来指定状态的类别。共有五个类别。<br><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/HTTTP%E6%8C%87%E5%8C%974.png" alt="HTTTP指北3"><br>不过常用的也就16种，下面来详细介绍下：</p><p><strong>1. 200：OK</strong><br>代表请求被正常的处理成功</p><p><strong>2. 204：No Content</strong><br>请求处理成功，但是没有数据实体返回，也不允许有实体返回。比如说HEAD请求，可能就会返回204 No Content，因为HEAD就是只获取头信息。</p><p><strong>3. 206：Partial Content</strong><br>这是客户端使用Content-Range指定了需要的实体数据的范围，然后服务端处理请求成功之后返回用户需要的这一部分数据而不是全部，执行的请求就是GET。返回码就是206：Partial Content。</p><p><strong>4. 301： Moved Permanently</strong><br>代表永久性定向。该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL。也就是说如果已经把资源对应的URL保存为书签了，这是应该按照Location首部字段提示的URL重新保存。</p><p><strong>5. 302：Found</strong><br>代表临时重定向。该状态码表示请求的资源已经被分配了新的URL，但是和301的区别是302代表的不是永久性的移动，只是临时的。就是说这个URL还可能会发生改变。如果保存成书签了也不会更新。</p><p><strong>6. 303：See Other</strong><br>和302的区别是303明确规定客户端应当使用GET方法。</p><p><strong>7. 304：Not Modified</strong><br>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但是没有满足条件。304状态码返回时不包含任何数据实体。304虽然被划分在3XX中但是和重定向没有关系。</p><p><strong>8. 307：Temporary Redirect</strong><br>临时重定向，与302 Found相同，但是302会把POST改成GET，而307就不会。</p><p><strong>9.  400：Bad Request</strong><br>表示请求报文中存在语法错误。需要修改后再次发送。</p><p><strong>10. 401：Unauthorized</strong><br>表示发送的请求需要有通过HTTP认证的认证信息。</p><p><strong>11. 403：Forbidden</strong><br>表明请求访问的资源被拒绝了。没有获得服务器的访问权限，IP被禁止等。</p><p><strong>12. 404：Not Found</strong><br>表明请求的资源在服务器上找不到。当然也可以在服务器拒绝请求且不想说明理由时使用。</p><p><strong>13. 408：Request Timeout</strong><br>表示客户端请求超时，就是在客户端和服务器建立连接后服务器在一定时间内没有收到客户端的请求。</p><p><strong>14. 500：Internal Server Error</strong><br>表明服务器端在执行请求时发生了错误，很有可能是服务端程序的Bug或者临时故障。</p><p><strong>15. 503：Service Unavailable</strong><br>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After字段再返回给客户端。</p><p><strong>16. 504：Getaway Timeout</strong><br>网关超时，是代理服务器等待应用服务器响应时的超时，和408 Request Timeout的却别就是504是服务器的原因而不是客户端的原因。</p>]]></content>
    
    <summary type="html">
    
      HTTP的重要性无需多言了，几乎是每一个人上网使用的第一个协议，尤其对于技术岗位来说理解掌握HTTP协议是必须的，这里记录了HTTP的基础知识以及一些常见的用法。
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="HTTP" scheme="https://www.shengshiyu.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>IOC与需求变化</title>
    <link href="https://www.shengshiyu.cn/2018/10/21/IOC%E4%B8%8E%E9%9C%80%E6%B1%82%E5%8F%98%E5%8C%96/"/>
    <id>https://www.shengshiyu.cn/2018/10/21/IOC与需求变化/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>声望的陷阱</title>
    <link href="https://www.shengshiyu.cn/2018/10/11/%E5%A3%B0%E6%9C%9B%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>https://www.shengshiyu.cn/2018/10/11/声望的陷阱/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E5%A3%B0%E6%9C%9B%E7%9A%84%E9%99%B7%E9%98%B1.jpeg" alt="声望的陷阱"></p><p><br></p><blockquote><p>命运是解不开的谜团，声望是没有实际意义的云烟。</p></blockquote><p>什么是声望？一个官方的解释是：声望是众所仰望的名声。人生在世，我们总有为声望所累的时候，但我的阅历尚浅，对于“声望”不好妄作评判，仅仅只能按我的理解，谈谈在当前时代下的“声望”的影响。</p><p>个人具有声望，组织和团体也具有声望，声望是一种看不见的影响力，它不好量化，但它却能无形中影响很多东西，就像我们玩的游戏，会有所谓的声望值，当你具备不同声望值时，就有权限获得一些稀有物品一样。</p><p>但游戏终究和现实不同，现实世界充满着许许多多的不确定性。可能具有很高声望的人或事物，会对人们的判断施加一定的影响，因为我们辨别和判断一件事物的好坏需要经过深思熟虑，这个过程对很多人而言并不那么“友好”，而具有了高声望，就能在判断上给予一定的肯定，简化了“深思熟虑”这项工作的任务量，因为声望的积累是基于大量的评价和时间的考量的，更能使人确信“它”对自身是有益的，由于思维的“惯性”我们就会自然而然选择了相信。</p><p>如同品牌效应，大厂出品一定会因为它完善的工艺和流程，质量上一定比同类产品更好。但销量高并不一定代表质量好，它们之间并不存在绝对意义上的正相关。对外部具有很高声望事物的盲目肯定，终会使我们的判断受制于对方。</p><p>假如没有了声望对判断施加的影响，那么真正吸引我们的，又是对方的什么呢？就拿衣食住行来说，我们选购一件衣物的判断，究竟是基于对品牌所积累的声望的信任，认为它一定用了优质的物料，一流的设计，还是商品本身质量就很不错呢？毕竟我们的世界是变化的，同样的产品或是服务，终究会随着时间的流逝产生差异的变动，很难“始终如一”。</p><p>如果商品和服务是我们还能切身在短时间内能感受到变化的，比较容易减小声望对人判断的影响。那么人呢？评判和了解一个人或许是一件复杂度极高的任务，我们难以短时间真正了解一个人，我们所基于的判断，来源于那个人的过去经历，例如他的受教育水平，是否具有本科学历，进而又要细分是否是名牌一流大学，因为那些大学本身所具有的声望能证明很多东西。如果是在校时就看在校的比赛获奖情况，进而又要区别看比赛的规模和大小，因为一些比赛具备参考价值，它确实选拔出了许多出色的人才，随着时间的积累，这个比赛所积累的声望就成为了一种“隐性标志”，暗示只要我获奖了，那么代表了我和曾经获奖的那些名人也具备同样的素质和潜力，而名人的成功也间接为类似比赛的声望添砖加瓦。但事物是变化的，我们只能保证在那样一个时间段里，它确实具有参考价值，含金量十足，但随着时代的发展，事物的更迭，能时刻保持领先，并始终拥有与之匹配的声望的事物是何其稀少。</p><p>当前的时代是网络时代，处于这个时代背景下的我们无法避免声望对我们判断施加的影响，而且网络的虚拟化，谁又知道一切是真的，而非虚张声势搭建起来的声望呢？网上购物商城的一些评价可以通过刷单刷好评取得消费者的信任，而最近大火的抖音，我们可以搬运别人的创意，成为自己涨粉的途径，哪怕只是从一些科普常识上搬运一些看起来有价值的东西，加上一个相关行业的背景，却能带来巨大的流量，点赞量和粉丝量无形为其树立起了某种声望，因为这类开放平台的用户量太多了，聚集了不同层次的人，但点赞量和粉丝量却是“一视同仁”的。</p><p>在这样的时代里，最能直接影响声望变化的，或许就是建立于社交媒体之上的舆论导向的，通过巧妙刻意的包装，引起舆论的关注，随即带来巨大的流量，无论是提高声望还是影响竞争对手的声望，都是无形的，如果对方的公关不能应对得当，那么就会陷入舆论的漩涡，或许可以通过一些形式“洗白”，但也依然会产生一些无形的影响，而往往这些“看不见”的东西更具风险性。</p><p>不要因为“声望”影响了我们对真实世界的认知，它可以作为评判的依据和参考，但不能作为先入为主的第一选择，无论是对任何事物，亦或是任何人，我们要关注于那些真正决定其本身的东西，避免陷入声望的陷阱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Vector、ArrayList、LinkedList的区别</title>
    <link href="https://www.shengshiyu.cn/2018/10/02/Vector%E3%80%81ArrayList%E3%80%81LinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.shengshiyu.cn/2018/10/02/Vector、ArrayList、LinkedList的区别/</id>
    <published>2018-10-01T16:00:00.000Z</published>
    <updated>2018-10-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>我为何会选择技术之路</title>
    <link href="https://www.shengshiyu.cn/2018/09/28/%E6%88%91%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/"/>
    <id>https://www.shengshiyu.cn/2018/09/28/我为何会选择技术之路/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-09-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E6%88%91%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF.jpeg" alt="我为何会选择技术之路"></p><p>回顾往昔，当初我为何会选择技术这一条路，与接触新媒体息息相关，理解了媒介变化的本质，就理解了技术在其中所产生的作用。在这个时代，能推动信息流动的加快，那么这样的技术是富有潜力的。</p><p>传播速度的加快，在我看来，不仅仅是数据传输速度的加快，还包括处理的速度，也就是信息是否更容易被吸收和理解。不同媒介的传播速度是不一样的，文字作为人类文明承载信息的重要媒介之一，其本身并不是一个出色的媒介，通过文字所记录的信息，难免会在传递的过程中，由于个体的背景差异产生一些信息的失真。尤其我们在阅读一本晦涩难懂的书时，很难将作者所要表达的原意通过文字完完整整的解析出来，如果这本书还是翻译的版本，又会在翻译的过程中损失一部分信息，全靠译者来把关，如果译者水平有限。。。那就只能听天由命或者直接选择阅读原著了。</p><p>相对于文字来说，图像更利于传递和接收信息，人们更容易从图像中获取其中包含的信息，而图片和视频很好的在静态和动态的</p><p>通过某种方式依靠技术手段对信息进行加工，实现信息在传输和理解的“便利”化，一定程度上是可以推动信息的快速流动，然而一旦这样的形式出现了弊端，但在发展普及的过程中成为了主流，大众便失去了接受信息后对信息的“再处理”的能力，简化信息，使得用户不用思考便能吸收，真的好吗？抖音，今日头条，微信公众号，微博，它们通过不同的交互手段和信息呈现形式，不断地冲刷和改变着人们的意识流，我们的世界观似乎不再是由我们自己来主导，而是由这些新媒介，它们把控着我们对世界，对人和事物的认知。媒介的发展不应该如此，它发展的目的应该是使用户接受原有信息的速度加快，通过技术手段实现的多样化的表现形式，通过发掘触觉，听觉，视觉等等形式，根本上的重构信息的展现形式，毕竟文字并不是一个很好的用来表现思想的媒介，重新唤醒人们接受信息，处理信息的深度思考的能力，在我看来比起听书或是得到这样，将原有体系精炼肢解后，以人们最便于立刻理解的形式要更重要，因为他确实会促进人们的进步，使人们主动地去判断信息的价值。只要技术能实现和解决这些痛点，就是颠覆就有体系，创建新行业形式的开始，反之，技术仅仅侧重于去更深入得提高原有“错误形式”的影响力，那么技术始终只是技术。比起实现需求，分析需求背后所带来的价值比单纯的需求更为重要。我为何会选技术之路，因为我希望看到不同技术背后对社会和人的影响，如果他并不能带来积极的影响，促使人和社会的进步，我希望我能发现更好的形式取代他。因为本质上我想推动的是媒介的变革，只是这一切的基石是技术，需要靠它来实现，也只有自身更懂它才能更好的实现这一过程。只有这样，技术在我手里才具有了意义，而不再是单纯的程序员。分析一个技术项目的好坏和成功，或许就可以通过分析他在加快媒介变革中所起到的作用大小来进行分析，他处在那一个点，哪一个方面，最大的作用是啥，是否有更好的形式比他带来的作用要更好更进一步，而那些曾经夭折失败的项目和产品，它们是为何没有成功落地的，去思索和发现，便是寻找到路的前进方向的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat学习总结</title>
    <link href="https://www.shengshiyu.cn/2018/09/23/Tomcat%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://www.shengshiyu.cn/2018/09/23/Tomcat学习总结/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-09-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p># </p>]]></content>
    
    <summary type="html">
    
      Tomcat是一个免费的开源的Serlvet容器
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java泛型</title>
    <link href="https://www.shengshiyu.cn/2018/09/19/%E6%B5%85%E6%9E%90Java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://www.shengshiyu.cn/2018/09/19/浅析Java泛型/</id>
    <published>2018-09-18T16:00:00.000Z</published>
    <updated>2018-09-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一本技术类书籍</title>
    <link href="https://www.shengshiyu.cn/2018/09/17/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%B1%BB%E4%B9%A6%E7%B1%8D/"/>
    <id>https://www.shengshiyu.cn/2018/09/17/如何阅读一本技术类书籍/</id>
    <published>2018-09-16T16:00:00.000Z</published>
    <updated>2018-09-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类的理解</title>
    <link href="https://www.shengshiyu.cn/2018/09/12/Java%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.shengshiyu.cn/2018/09/12/Java内部类的理解/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2018-09-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别浅析</title>
    <link href="https://www.shengshiyu.cn/2018/08/26/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90/"/>
    <id>https://www.shengshiyu.cn/2018/08/26/String、StringBuffer、StringBuilder的区别浅析/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2018-08-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="Java" scheme="https://www.shengshiyu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何高效提问</title>
    <link href="https://www.shengshiyu.cn/2018/08/21/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%8F%90%E9%97%AE/"/>
    <id>https://www.shengshiyu.cn/2018/08/21/如何高效提问/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2018-08-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://www.shengshiyu.cn/categories/Thinking/"/>
    
    
      <category term="思考" scheme="https://www.shengshiyu.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript中的继承机制</title>
    <link href="https://www.shengshiyu.cn/2018/08/21/%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.shengshiyu.cn/2018/08/21/关于Javascript中的继承机制/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2018-08-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="http://blog0508.oss-cn-beijing.aliyuncs.com/image/%E5%85%B3%E4%BA%8EJavascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6.jpg" alt="关于Javascript中的继承机制"></p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>传统的面向对象语言里，基本都支持继承的两种方式：<strong>接口继承</strong>和<strong>实现继承</strong>。接口继承<strong>继承方法签名</strong>，而实现继承则<strong>继承实际的方法</strong>。至于JavaScript里的继承，由于函数没有签名，只能支持实现继承，而且主要通过<strong>原型链</strong>来实现的。每一个<strong>构造函数</strong>都有一个<strong>原型对象</strong>，原型对象都包含一个<strong>指向构造函数的指针</strong>，而实例又都包含一个<strong>指向原型对象的内部指针</strong>，通过使用原型，将方法添加在”父类“的原型里，然后”子类“的原型就是父类的一个实例化对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass() ;</span><br></pre></td></tr></table></figure></p><p>如此层层递进，就构成了<strong>实例与原型的链条</strong>，这就是原型链。但原型链也有问题，原先实例的属性会在这个继承的过程中顺理成章的成为其“子类”的原型属性。而且创建的”子类“的实例，无法在不影响所有对象实例的情况下，像”超类“的构造函数传递参数，于是有了构造函数继承。</p><h1 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h1><p>构造函数继承的核心思想就是<code>SuperClass.call(this)</code>,通过<code>call()</code>和<code>apply()</code>方法，<strong>在新创建的对象上执行构造函数，然后改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"read"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClsss</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h1><p>组合式继承，也叫作伪经典继承，结合了前两者的特点，既不会使每个实例化的“子类”互相影响，也避免了内存的浪费。它<strong>使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承</strong>。既可以在原型上定义方法实现实现函数复用，又能保证每个实例都有它自己单独的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"read"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//继承属性</span></span><br><span class="line">SuperClass.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line">SubClass.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>寄生式继承的思路是<strong>创建一个仅用于封装继承过程的函数，该函数的内部以某种方式来增强对象，然后返回对象</strong>，就像所有都是它做的一样，很像工厂模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    <span class="keyword">var</span> clone = object(original);</span><br><span class="line">    clone.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过使用这种模式来为对象添加函数，会因为不能做到函数复用而降低效率，所以出现了寄生组合式继承。</p><h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p>组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。集寄生式继承和组合继承的优点于一身，本质上就是<strong>使用寄生式继承来继承“超类”的原型，然后再将结果指定给“子类”的原型。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">subClass,superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//复制一份父类的原型保存在变量中</span></span><br><span class="line"><span class="keyword">var</span> p = inheritObject(superClass.prototype);</span><br><span class="line">    <span class="comment">//修正因为重写子类原型导致子类constructor属性被修改</span></span><br><span class="line">p.constructor = subClass;</span><br><span class="line">    <span class="comment">//设置子类的原型</span></span><br><span class="line">    subClass.prototype = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义父类</span></span><br><span class="line"><span class="keyword">var</span> SuperClass = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.books = [<span class="string">'javascript'</span>,<span class="string">'html'</span>,<span class="string">'css'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//定义父类原型方法</span></span><br><span class="line">SuperClass.prototype.getBooks = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.books)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义子类</span></span><br><span class="line"><span class="keyword">var</span> SubClass = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>,name)</span><br><span class="line">&#125;</span><br><span class="line">inheritObject(SubClass,SuperClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subclass1 = <span class="keyword">new</span> SubClass(<span class="string">'Java'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Technology" scheme="https://www.shengshiyu.cn/categories/Technology/"/>
    
    
      <category term="JavaScript" scheme="https://www.shengshiyu.cn/tags/JavaScript/"/>
    
  </entry>
  
</feed>
